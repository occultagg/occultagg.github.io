<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="概念 通俗点地理解: 对于操作系统来说,一个任务就是一个进程(process),比如打开一个浏览器就是启动一个浏览器进程,打开两个记事本就是打开两个记事本进程. 有些进程它同时不止干一件事,比如word,它同时可以打字,拼写检查,打印等.在一个进程内部可以同时运行多个”子任务”,则称之为线程(Thread). 由于每个进程至少要干一件事,所以每个进程至少要有一个线程.  进程(process) 进"><meta property="og:type" content="article"><meta property="og:title" content="python笔记-进程和线程"><meta property="og:url" content="http://example.com/2024/08/28/python-process-thread/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="概念 通俗点地理解: 对于操作系统来说,一个任务就是一个进程(process),比如打开一个浏览器就是启动一个浏览器进程,打开两个记事本就是打开两个记事本进程. 有些进程它同时不止干一件事,比如word,它同时可以打字,拼写检查,打印等.在一个进程内部可以同时运行多个”子任务”,则称之为线程(Thread). 由于每个进程至少要干一件事,所以每个进程至少要有一个线程.  进程(process) 进"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta property="article:published_time" content="2024-08-28T08:40:36.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.058Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="python"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta name="referrer" content="no-referrer-when-downgrade"><title>python笔记-进程和线程 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">python笔记-进程和线程</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-08-28 16:40" pubdate>2024年8月28日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 39 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">python笔记-进程和线程</h1><div class="markdown-body"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>通俗点地理解:</p><p>对于操作系统来说,一个任务就是一个进程(process),比如打开一个浏览器就是启动一个浏览器进程,打开两个记事本就是打开两个记事本进程.</p><p>有些进程它同时不止干一件事,比如word,它同时可以打字,拼写检查,打印等.在一个进程内部可以同时运行多个”子任务”,则称之为线程(Thread).</p><p>由于每个进程至少要干一件事,所以每个进程至少要有一个线程.</p></blockquote><h2 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h2><ul><li>进程是计算机中<code>正在运行的程序的实例</code></li><li>它是操作系统<code>分配资源的基本单位</code><ul><li>所以每个进程都有自己的内存空间,系统资源和状态信息</li></ul></li></ul><h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><ul><li>线程是进程内的<code>执行单元</code></li><li>它是<code>cpu调度和分配的基本单位</code></li><li>同一进程内多个线程共享该进程的资源</li></ul><table><thead><tr><th>区别</th><th>资源占用</th><th>开销</th><th>通信</th><th>安全</th><th>并行</th></tr></thead><tbody><tr><td>进程</td><td>每个进程独立</td><td>创建和切换开销大</td><td>进程间通信(IPC)比较复杂</td><td>进程之间不会相互影响</td><td>在多核处理器上实现真正并行</td></tr><tr><td>线程</td><td>每个线程共享进程的资源</td><td>创建和切换开销小</td><td>线程间通信比较简单,直接读写进程中的数据</td><td>一个线程的奔溃可能导致整个进程奔溃</td><td>在单核处理器上是并发执行,在多核上可以并行</td></tr></tbody></table><h2 id="并发与并行-concurrency-parallelism"><a href="#并发与并行-concurrency-parallelism" class="headerlink" title="并发与并行(concurrency &amp; parallelism)"></a>并发与并行(concurrency &amp; parallelism)</h2><blockquote><ul><li>进程在多核处理器上实现真正并行:<br>多个进程在多核处理器上同时运行,每个核心执行一个进程,实现真正并行.操作系统将不同进程分配到不同的cpu核心上,这是在硬件级别实现的并行.</li><li>线程在单核处理器上是并发执行:<br>多线程通过时间片轮转(time-slicing)实现的并发,线程上下文会不停地,给人一种同时执行的错觉.<br>这种称为并发(concurrency),并不是真正的并行.</li><li>线程在多核上可以并行:<br>类似多进程,不同的线程分配到不同的核心上同时执行.<br>这种称为并行(parallelism)</li></ul></blockquote><p>那么,多任务的执行就有三种模型:</p><ul><li>多进程</li><li>多线程</li><li>多进程+多线程</li></ul><p>通常,同时执行多个任务时,各个任务之间并不是完全没有关联,通常都需要互相通信和协调,有时,任务1需要等待任务2完成后才能继续执行,有时任务3和4又不能同时执行,所以多进程和多线程程序的复杂度是很高的.</p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>unix&#x2F;linux 提供了一个<code>fork()</code>调用. 它调用一次,返回两次.因为操作系统会自动把当前进程(父进程)复制一份(子进程),然后分别在父子进程内返回.在<code>fork()</code>中:</p><ul><li><p>子进程永远返回<code>0</code></p></li><li><p>父进程返回子进程的<code>id</code></p></li></ul><p>python的<code>os</code>模块有fork调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;process <span class="hljs-subst">&#123;os.getpid()&#125;</span> start...&#x27;</span>)<br><br>pid = os.fork() <span class="hljs-comment"># 创建子进程</span><br><br><span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;I am child process <span class="hljs-subst">&#123;os.getpid()&#125;</span>, my pranent is <span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;I <span class="hljs-subst">&#123;os.getpid&#125;</span> just create a child process <span class="hljs-subst">&#123;pid&#125;</span>.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Process (876) start...<br>I (876) just created a child process (877).<br>I am child process (877) and my parent is 876.<br></code></pre></td></tr></table></figure><p>因为父进程需要记住每个子进程的pid以便后续:</p><ul><li>等待子进程结束(wait)</li><li>向子进程发送信号(kill)</li><li>监控子进程状态</li></ul><p>而子进程可以通过<code>getppid()</code>获取父进程的pid,所以不需要在fork()时候特别记录</p><h2 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h2><p>windows没有<code>fork</code>调用,如果要在windows上使用python编写多进程程序.<code>multiprocessing</code>就是一个跨平台版本的多进程模块.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process <span class="hljs-comment"># multiprocess提供一个Process类来代表一个进程对象</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_proc</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Run child process <span class="hljs-subst">&#123;name&#125;</span> (<span class="hljs-subst">&#123;os.getpid()&#125;</span>)...&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Parent process <span class="hljs-subst">&#123;os.getpid()&#125;</span>.&#x27;</span>)<br>    p = Process(traget=run_proc, args=(<span class="hljs-string">&#x27;test&#x27;</span>,)) <span class="hljs-comment"># 输入执行函数和函数的参数,args需要以元组形式传入,所以即使只有一个元素也要加逗号</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process will start.&#x27;</span>)<br>    p.start() <span class="hljs-comment"># 启动子进程</span><br>    p.join() <span class="hljs-comment"># 等待子进程结束后再继续往下运行,通常用于进程间的同步</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process end.&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>需要大量创建子进程时,可以通过进程池的方式批量创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_time_task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Run task <span class="hljs-subst">&#123;name&#125;</span> (<span class="hljs-subst">&#123;os.getpid()&#125;</span>)&#x27;</span>)<br>    strat = time.time()<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Task <span class="hljs-subst">&#123;name&#125;</span> runs <span class="hljs-subst">&#123;(end - start)&#125;</span> seconds.&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-comment"># windows下必须在if __name__ == &#x27;__main__&#x27;:下使用进程池</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Parent process <span class="hljs-subst">&#123;os.getpid()&#125;</span>&#x27;</span>)<br>    p = Pool(<span class="hljs-number">4</span>) <span class="hljs-comment"># Pool同时执行的进程数,默认与cpu核数相同</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p.apply_async(long_time_task, arg=(i,)) <span class="hljs-comment"># 异步执行(不等待任务完成直接返回)</span><br>        <span class="hljs-comment"># 与之相对的是p.apply(),它会阻塞等待任务完成</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waitting for all subprocesses done...&#x27;</span>)<br>    p.close() <span class="hljs-comment"># 调用join()之前必须调用close(),执行了close()后就不能继续添加新的process了</span><br>    p.join() <span class="hljs-comment"># Pool对象调用join()方法会等待所有子进程执行完毕</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;All subprocesses done.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">Parent process 669.<br>Waiting for all subprocesses done...<br>Run task 0 (671)...<br>Run task 1 (672)...<br>Run task 2 (673)...<br>Run task 3 (674)... # 这里服务器以4核为例,Pool(4)同时执行4个进程,所以task0-3同时执行<br>Task 2 runs 0.14 seconds.<br>Run task 4 (673)... # task 4要等前面某个task完成后才能执行,如果你的服务器是8核,则要写Pool(9),才能看到等待效果<br>Task 1 runs 0.27 seconds.<br>Task 3 runs 0.86 seconds.<br>Task 0 runs 1.41 seconds.<br>Task 4 runs 1.91 seconds.<br>All subprocesses done.<br></code></pre></td></tr></table></figure><h2 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h2><p>很多时候子进程是一个外部程序.我们创建子进程后还要控制子进程的输入输出.<code>subprocess</code>模块可以很方便地做到.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;run nslookup www.python.org&#x27;</span>)<br>r = subprocess.call([<span class="hljs-string">&#x27;nslookup&#x27;</span>, <span class="hljs-string">&#x27;www.python.org&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exit code:&#x27;</span>, r)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">run nslookup www.python.org<br>Server:		192.168.19.4<br>Address:	192.168.19.4#53<br><br>Non-authoritative answer:<br>www.python.org	canonical name = python.map.fastly.net.<br>Name:	python.map.fastly.net<br>Address: 199.27.79.223<br><br>Exit code: 0<br></code></pre></td></tr></table></figure><p>如果子进程需要输入,则可以通过<code>communicate()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;$ nslookup&#x27;</span>)<br>p = subprocess.Popen([<span class="hljs-string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<br>output, err = p.communicate(<span class="hljs-string">b&#x27;set q=mx\npython.org\nexit\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(output.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exit code:&#x27;</span>, p.returncode)<br></code></pre></td></tr></table></figure><p>实际实现的就是这种效果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> q=mx</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">python.org</span><br>Server:		127.0.0.53<br>Address:	127.0.0.53#53<br><br>Non-authoritative answer:<br>python.org	mail exchanger = 50 mail.python.org.<br><br>Authoritative answers can be found from:<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br></code></pre></td></tr></table></figure><h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><p>python的<code>multiprocessing</code>模块包装了底层的机制,提供<code>queue</code>, <code>pipes</code>等多种方式交换数据.</p><table><thead><tr><th>特性</th><th>Queue</th><th>Pipes</th></tr></thead><tbody><tr><td>进程数量</td><td>支持多进程</td><td>仅支两个进程</td></tr><tr><td>通信方向</td><td>单向(FIFO)</td><td>双向</td></tr><tr><td>使用场景</td><td>多生产者&#x2F;消费者(实际开发中如果不需要pipes的特殊功能,建议使用Queue,因为它更安全更易用)</td><td>点对点通信</td></tr><tr><td>安全性</td><td>进程安全(并发时不会出现数据混乱,因为有锁机制)</td><td>自行处理同步</td></tr><tr><td>性能</td><td>较慢(有锁机制)</td><td>较快</td></tr></tbody></table><p>更多通讯方式:</p><table><thead><tr><th>通信方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Queue</td><td>使用简单,进程安全</td><td>相对较慢</td><td>多生产者&#x2F;消费者</td></tr><tr><td>Pipe</td><td>速度快,双向通讯</td><td>仅支持两个进程</td><td>两进程间频繁通信</td></tr><tr><td>共享内存</td><td>最快的IPC方式</td><td>需要自行处理同步</td><td>大量数据共享</td></tr><tr><td>Manager</td><td>支持复杂的python对象</td><td>慢</td><td>需要共享复杂数据结构</td></tr><tr><td>Value&#x2F;Array</td><td>简单高效</td><td>仅支持基本数据类型</td><td>共享简单数据</td></tr><tr><td>文件系统</td><td>简单,持久化</td><td>最慢,需要IO操作</td><td>少量数据,需要持久化</td></tr></tbody></table><p>下面以<code>Queue</code>为例,在父进程中创建两个子进程,一个往Queue写数据,一个往Queue读数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-comment"># 写数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process to write: <span class="hljs-subst">&#123;os.getpid()&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Put <span class="hljs-subst">&#123;value&#125;</span> to queue...&#x27;</span>)<br>        q.put(value)<br>        time.sleep(random.random())<br>        <br><span class="hljs-comment"># 读数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process to read <span class="hljs-subst">&#123;os.getpid()&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        value = q.get(<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Get <span class="hljs-subst">&#123;value&#125;</span> from queue&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 父进程创建Queue,并传入子进程</span><br>    q = Queue()<br>    pw = Process(target=write, args=(q,))<br>    pr = Process(target=read, args=(q,))<br>    <span class="hljs-comment"># 子进程qw启动,写入</span><br>    pw.start()<br>    <span class="hljs-comment"># 子进程qr启动,读取</span><br>    pr.start()<br>    <span class="hljs-comment"># 等到pw结束</span><br>    pw.join()<br>    <span class="hljs-comment"># pr内是死循环,无法等待结束,只能强行终止</span><br>    pr.terminate()<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>父进程和子进程间的通讯必须通过pickle序列化来传递数据.也就是说传入的args必须是可序列化的对象.比如:</p><ol><li>基本数据类型(数字, 字符串, 布尔值)</li><li>列表,字典,元组等内置容器</li><li>类实例(该类需要可实例化)</li></ol><p>以下类型则不能被实例化:</p><ol><li>函数对象</li><li>线程对象</li><li>文件句柄</li><li>数据库连接</li><li>Socket连接</li></ol><p>当你在windows系统下使用multiprocess遇到问题,首先检查是否涉及不能序列化的对象.</p></li></ol></blockquote><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><p>一个进程至少有一个线程,线程是操作系统直接支持的执行单元.python的线程是真正的Posix Thread,不是模拟出来的线程.</p><p>python的标准库有两个模块: <code>_thread</code>和<code>threading</code>.</p><p><code>threading</code>是<code>_thread</code>的高级封装,一般我们只要使用<code>threading</code>就行.</p><p>任何<code>进程</code>都会默认启动一个线程,称为<code>主线程</code>,主线程又可以启动新的线程.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time, threading<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>():<br>    thread_name = threading.current_thread().name <span class="hljs-comment"># current_thread()返回当前线程得实例,主线程名字就叫MainThread</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;thread_name&#125;</span> is running...&#x27;</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>:<br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;thread_name&#125;</span> &gt;&gt;&gt; <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;thread_name&#125;</span> ended&#x27;</span>)<br>    <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;threading.current_thread().name&#125;</span> is running&#x27;</span>)<br>t = threading.Thread(target=loop, name=<span class="hljs-string">&#x27;LoopThread&#x27;</span>) <span class="hljs-comment"># 创建子线程,执行loop函数,命名LoopThread,不命名的话默认是Thread-1,Thread-2,...</span><br>t.start()<br>t.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;threading.current_thread().name&#125;</span> ended.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">thread MainThread is running...<br>thread LoopThread is running...<br>thread LoopThread &gt;&gt;&gt; 1<br>thread LoopThread &gt;&gt;&gt; 2<br>thread LoopThread &gt;&gt;&gt; 3<br>thread LoopThread &gt;&gt;&gt; 4<br>thread LoopThread &gt;&gt;&gt; 5<br>thread LoopThread ended.<br>thread MainThread ended.<br></code></pre></td></tr></table></figure><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><blockquote><ul><li>多进程中,同一个变量各自有一份拷贝存在于每个进程中,互不影响</li><li>多线程中,所有变量都是共享的,所以任何一个变量都可以被任何一个线程修改</li></ul></blockquote><p>下面是一个多线程同时操作导致变量数据混乱的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># multithread</span><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-comment"># 假定这是你的银行存款</span><br>balance = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_it</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 先存后取,结果应该为0</span><br>    <span class="hljs-keyword">global</span> balance <span class="hljs-comment"># 定义一个共享变量balance</span><br>    balance = balance + n<br>    balance = balance - n<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_thread</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>):<br>        change_it(n)<br>        <br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(balance) <span class="hljs-comment"># 理论上,因为先存后取,所以不管循环多少次,balance都应该为0</span><br></code></pre></td></tr></table></figure><blockquote><p>但是,由于线程的调度是由操作系统决定的,当<code>t1</code>,<code>t2</code>交替执行,balance就有出错的可能</p></blockquote><p>因为,高级语言的一条语句,在CPU执行时,实际上是若干条语句.比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">balance = balance + n<br></code></pre></td></tr></table></figure><p>在实际执行时,会分两步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">x = balance + n # 存入临时变量x<br>balance = x # 把临时变量的值赋给balance<br></code></pre></td></tr></table></figure><p>t1,t2交替执行,<code>临时变量x</code>在两个线程中单独存在,可能会出现这样的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始值 balance = 0</span><br><br>t1: x1 = balance + 5  # x1 = 0 + 5 = 5<br><br>t2: x2 = balance + 8  # x2 = 0 + 8 = 8<br>t2: balance = x2      # balance = 8<br><br>t1: balance = x1      # balance = 5<br>t1: x1 = balance - 5  # x1 = 5 - 5 = 0<br>t1: balance = x1      # balance = 0<br><br>t2: x2 = balance - 8  # x2 = 0 - 8 = -8<br>t2: balance = x2      # balance = -8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">结果 balance = -8</span><br></code></pre></td></tr></table></figure><p>究其原因,是因为修改<code>balance</code>需要多条语句,而执行这几条语句时,线程可能中断,从而导致把同一个对象的内容改乱.</p><p>那么要确保一个线程修改<code>balance</code>的时候,别的线程一定不能改,此时就需要<code>锁机制</code>.</p><p>锁只有一个,无论有多少线程,同一时刻最多只能由一个线程持有锁.从而避免并发冲突.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br>balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_thread</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        <span class="hljs-comment"># 先要获取锁:</span><br>        lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 放心地改吧:</span><br>            change_it(n)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 改完了一定要释放锁:</span><br>            lock.release()<br></code></pre></td></tr></table></figure><blockquote><p>当多个线程同时执行<code>lock.acquire()</code>时,只有一个线程能成功地获取锁,然后继续执行代码,其他线程就要继续等待知道获得锁为止.使用<code>try...finally</code>来保证锁的释放.</p><ul><li><p>所以锁虽然可以保证一个线程从头到尾地完整执行,但是也会导致其他线程一直处于等待状态,没办法实现真正并发,大大降低效率.</p></li><li><p>另外,可以存在多个锁,不同的线程持有不同的锁,并试图获取对方的锁时,可能会导致<code>死锁</code>,多个线程全部挂起,既不能执行,也无法结束,只能靠操作系统强制终止.</p></li></ul></blockquote><h2 id="python的多线程"><a href="#python的多线程" class="headerlink" title="python的多线程"></a>python的多线程</h2><p>按理来说,多核CPU可以同时跑多个线程,假如创建n个死循环线程,那么n个核就会被100%跑满.C, C++, Java都是如此.但是如果用python来实现时:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, multiprocessing<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>():<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        x = x ^ <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(multiprocessing.cpu_count()): <span class="hljs-comment"># 启动与CPU核心数量相同的n个线程</span><br>    t = threading.Thread(target=loop)<br>    t.start()<br></code></pre></td></tr></table></figure><p>你会发现,cpu占用只去到102%,也就是仅跑满一个核.</p><blockquote><p>因为python解释器CPython在设计时,引入了GIL(Global Interpreter Lock)全局锁: 任何python线程执行前,必须先获得GIL锁,每执行100条字节码,解释器就会自动释放GIL锁,这才轮到别的进程.有了GIL的存在,python便无法真正地实现多线程并发.</p><p>目前(2024),GIL还无法移除,因此如果要使用python实现并发提升效率,目前主要的解决方案是:</p><ul><li>使用多进程编程</li><li>使用asyncio异步</li><li>使用C扩展在关键性能代码中释放GIL</li></ul></blockquote><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>多线程下,每个线程都有自己的数据.一个线程使用自己的局部变量比使用全局变量好.局部变量只有线程自己能用,全局变量要加锁.</p><p><code>ThreadLocal</code>是一个特殊的对象,它能够为每个线程存储独立的数据副本.这意味着,即使多个线程同时访问同一个<code>ThreadLocal</code>对象,每个线程都只能看到和操作自己的数据,不会影响其他线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> local<br><br><span class="hljs-comment"># 创建 ThreadLocal 对象</span><br>thread_local = local()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    <span class="hljs-comment"># 每个线程设置自己的数据</span><br>    thread_local.value = threading.current_thread().name<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;线程 <span class="hljs-subst">&#123;threading.current_theead().name&#125;</span> 设置的值: <span class="hljs-subst">&#123;thread_local.value&#125;</span>&#x27;</span>)<br>    <br><span class="hljs-comment"># 创建两个线程</span><br>t1 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;Thread-1&#x27;</span>)<br>t2 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;Thread-2&#x27;</span>)<br><br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br></code></pre></td></tr></table></figure><blockquote><p>主要用途包括:</p><ol><li>线程隔离: 每个线程都有自己的数据副本,避免了线程间的数据竞争.</li><li>全局变量替代: 可以避免使用全局变量来传递线程相关数据.</li><li>常见应用场景:<ol><li>数据库连接管理: 每个线程维护自己的数据库连接</li><li>用户身份信息: 在web应用重保存当前请求用户的信息</li><li>事务管理: 维护线程本地的事务状态</li></ol></li></ol></blockquote><p><code>ThreadLocal</code>在内存中的存储机制:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化的内部实现原理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># meige ThreadLocal 对象都有一个字典</span><br>        <span class="hljs-comment"># key 是线程ID, value是该线程的数据</span><br>        <span class="hljs-variable language_">self</span>._storage = &#123;&#125;<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        thread_id = current_thread_id()<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._storage.get(thread_id)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, value</span>):<br>        thread_id = current_thread_id()<br>        <span class="hljs-variable language_">self</span>._storage[thread_id] = value<br></code></pre></td></tr></table></figure><p>存储的数据结构实际上类似这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<br>    <span class="hljs-string">&#x27;Thread-1&#x27;</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;User-0&#x27;</span>&#125;,<br>    <span class="hljs-string">&#x27;Thread-2&#x27;</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;User-1&#x27;</span>&#125;,<br>    <span class="hljs-string">&#x27;Thread-3&#x27;</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;User-0&#x27;</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="进程-VS-线程"><a href="#进程-VS-线程" class="headerlink" title="进程 VS 线程"></a>进程 VS 线程</h1><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/python/process-thread/process-vs-thread/index.html">https://liaoxuefeng.com/books/python/process-thread/process-vs-thread/index.html</a></p><p>nginx是多进程+异步IO的Web服务器.</p><p>在多进程和多线程中应该优选多进程.因为进程更稳定,多线程下某个线程出问题很有可能导致整个进程都出问题.而且多进程可以分布到多台服务器上,而多进程只能同一台机器上的多个CPU.</p><h1 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h1><blockquote><p>python的<code>multiprocessing</code>的子模块<code>managers</code>支持把多进程分布到多台机器上.一个服务进程可以作为调度者,将任务分布到其他多个进程中,依靠网络来通信.</p></blockquote><p>比如之前我们写了一个用<code>Queue</code>通信的多进程程序,现在由于任务加重,希望把发送任务的进程和处理任务的进程分布到两台机器上.</p><p>通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去,就可以让其他机器访问<code>Queue</code>了.</p><blockquote><p>在一台机器上写多进程程序时,创建的<code>Queue</code>可以直接拿来用,但是在分布式进程环境中,添加任务到Queue不可以直接对原始的<code>task_queue</code>进行操作,这样就绕过了<code>QueueManager</code>的封装,必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加.</p></blockquote><p>先在一台机器上启动<code>任务进程</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># task_master.py</span><br><br><span class="hljs-keyword">import</span> random, time, queue<br><span class="hljs-keyword">from</span> multiprocessing.managers <span class="hljs-keyword">import</span> BaseManager<br><br><span class="hljs-comment"># 发送任务的队列</span><br>task_queue = queue.Queue()<br><span class="hljs-comment"># 接收结果的队列</span><br>result_queue = queue.Queue()<br><br><span class="hljs-comment"># 从BaseManager继承的QueueManager</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueManager</span>(<span class="hljs-title class_ inherited__">BaseManager</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义两个函数，用于获取任务队列和结果队列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_task_queue</span>():<br>    <span class="hljs-keyword">return</span> task_queue<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_result_queue</span>():<br>    <span class="hljs-keyword">return</span> result_queue<br><br><span class="hljs-comment"># 注册这两个函数</span><br>QueueManager.register(<span class="hljs-string">&#x27;get_task_queue&#x27;</span>, <span class="hljs-built_in">callable</span>= get_task_queue)<br>QueueManager.register(<span class="hljs-string">&#x27;get_result_queue&#x27;</span>,<span class="hljs-built_in">callable</span>= get_result_queue)<br><br><span class="hljs-comment"># 绑定端口5000, 设置验证码&#x27;abc&#x27;</span><br>manager = QueueManager(address=(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">5000</span>), authkey=<span class="hljs-string">b&#x27;abc&#x27;</span>)<br><span class="hljs-comment"># 启动Queue</span><br>manager.start()<br><span class="hljs-comment"># 通过网络访问Queue对象</span><br>task = manager.get_task_queue()<br>result = manager.get_result_queue()<br><span class="hljs-comment"># 放几个任务进去</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    n = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Put task <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>    task.put(n)<br><span class="hljs-comment"># 从result读取任务</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try get results...&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    r = result.get(timeout=<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Result: <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 关闭</span><br>manager.shutdown()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;master exit.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在另一台机器上启动任务进程(本次测试在本机也行)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># task_worker.py</span><br><span class="hljs-keyword">import</span> time, sys, queue<br><span class="hljs-keyword">from</span> multiprocessing.managers <span class="hljs-keyword">import</span> BaseManager<br><br><span class="hljs-comment"># 创建类似的QueueManager</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueManager</span>(<span class="hljs-title class_ inherited__">BaseManager</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 由于这个QueueManager只从网络上获取Queue,所以注册时只提供名字</span><br>QueueManager.register(<span class="hljs-string">&#x27;get_task_queue&#x27;</span>)<br>QueueManager.register(<span class="hljs-string">&#x27;get_result_queue&#x27;</span>)<br><br><span class="hljs-comment"># 连接到服务器,也就是运行task_master.py的机器</span><br>server_addr = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Connect to Server <span class="hljs-subst">&#123;server_addr&#125;</span> ...&#x27;</span>)<br><br><span class="hljs-comment"># 端口和验证码注意保持与task_master.py设置的一致</span><br>m = QueueManager(address=(server_addr, <span class="hljs-number">5000</span>), authkey=<span class="hljs-string">b&#x27;abc&#x27;</span>)<br><span class="hljs-comment"># 从网络连接</span><br>m.connect()<br><span class="hljs-comment"># 获取Queue的对象</span><br>task = m.get_task_queue()<br>result = m.get_result_queue()<br><span class="hljs-comment"># 从task队列取任务,并把结果写入result队列</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">try</span>:<br>        n = task.get(timeout=<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;run task <span class="hljs-subst">&#123;n&#125;</span> * <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;n&#125;</span> * <span class="hljs-subst">&#123;n&#125;</span> = <span class="hljs-subst">&#123;n*n&#125;</span>&#x27;</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        result.put(r)<br>    <span class="hljs-keyword">except</span> Queue.Empty:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;task queue is empty.&#x27;</span>)<br><span class="hljs-comment"># 处理结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;worker exit.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">                                             │<br>┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐<br>│task_master<span class="hljs-selector-class">.py</span>                           │  │  │task_worker<span class="hljs-selector-class">.py</span>                        │<br>│                                         │     │                                      │<br>│  task = manager<span class="hljs-selector-class">.get_task_queue</span>()        │  │  │  task = manager<span class="hljs-selector-class">.get_task_queue</span>()     │<br>│  result = manager<span class="hljs-selector-class">.get_result_queue</span>()    │     │  result = manager<span class="hljs-selector-class">.get_result_queue</span>() │<br>│              │                          │  │  │              │                       │<br>│              │                          │     │              │                       │<br>│              ▼                          │  │  │              │                       │<br>│  ┌─────────────────────────────────┐    │     │              │                       │<br>│  │QueueManager                     │    │  │  │              │                       │<br>│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │<br>│  │ │ task_queue │ │ result_queue │ │◀───┼──┼──┼──────────────┘                       │<br>│  │ └────────────┘ └──────────────┘ │    │     │                                      │<br>│  └─────────────────────────────────┘    │  │  │                                      │<br>└─────────────────────────────────────────┘     └──────────────────────────────────────┘<br>                                             │<br><br>                                          Network<br></code></pre></td></tr></table></figure><blockquote><ol><li>Queue对象存储在task_master.py中</li><li>Queue可以通过网络访问是通过QueueManager实现的.由于QueueManager管理的不止一个Queue,所以要给每个Queue的网络调用接口起个名字,比如get_task_queue</li></ol></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/python/" class="print-no-link">#python</a></div></div><div class="license-box my-3"><div class="license-title"><div>python笔记-进程和线程</div><div>http://example.com/2024/08/28/python-process-thread/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年8月28日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/10/29/python-asyncio/" title="python笔记-异步IO"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">python笔记-异步IO</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/08/22/pyhton-io/" title="pyhton笔记-IO编程"><span class="hidden-mobile">pyhton笔记-IO编程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>