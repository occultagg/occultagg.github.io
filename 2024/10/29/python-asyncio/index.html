<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="CPU速度远远快于磁盘,网络等IO.在一个线程中,cpu执行代码的速度极快,但一旦遇到IO操作,比如读写文件,发送网络数据时,就需要等待IO操作完成,才能继续进行下一步.这种情况称为同步IO.此时一个IO就阻塞了当前线程,导致代码无法继续,所以我们需要多线程或者多进程,为多个用户服务.每个用户分配一个线程,如果遇到IO导致线程被挂起,起码其他用户不会受影响.   1234567891011121"><meta property="og:type" content="article"><meta property="og:title" content="python笔记-异步IO"><meta property="og:url" content="http://example.com/2024/10/29/python-asyncio/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="CPU速度远远快于磁盘,网络等IO.在一个线程中,cpu执行代码的速度极快,但一旦遇到IO操作,比如读写文件,发送网络数据时,就需要等待IO操作完成,才能继续进行下一步.这种情况称为同步IO.此时一个IO就阻塞了当前线程,导致代码无法继续,所以我们需要多线程或者多进程,为多个用户服务.每个用户分配一个线程,如果遇到IO导致线程被挂起,起码其他用户不会受影响.   1234567891011121"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta property="article:published_time" content="2024-10-29T06:45:21.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.058Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="python"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta name="referrer" content="no-referrer-when-downgrade"><title>python笔记-异步IO - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">python笔记-异步IO</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-10-29 14:45" pubdate>2024年10月29日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 36 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">python笔记-异步IO</h1><div class="markdown-body"><blockquote><p>CPU速度远远快于磁盘,网络等IO.在一个线程中,cpu执行代码的速度极快,但一旦遇到IO操作,比如读写文件,发送网络数据时,就需要等待IO操作完成,才能继续进行下一步.这种情况称为<code>同步IO</code>.此时一个IO就阻塞了当前线程,导致代码无法继续,所以我们需要多线程或者多进程,为多个用户服务.每个用户分配一个线程,如果遇到IO导致线程被挂起,起码其他用户不会受影响.</p></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">真正意义上的 异步IO 是说内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">select</span> / poll / epoll 都是同步IO的多路复用模式</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.同步和异步</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同步和异步关注的是消息通信机制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所谓同步，就是在发出一个*调用*时，没得到结果之前，该*调用*就不返回。但是一旦调用返回就得到返回值了，*调用者*主动等待这个*调用*的结果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所谓异步，就是在发出一个*调用*时，这个*调用*就直接返回了，不管返回有没有结果。当一个异步过程调用发出后，*被调用者*通过状态，通知来通知*调用者*，或者通过回调函数处理这个调用</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.阻塞和非阻塞</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阻塞和非阻塞关注的是程序在等待调用结果时的状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">网络上的例子</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">老张爱喝茶，废话不说，煮开水。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1 老张把水壶放到火上，立等水开。（同步阻塞）；立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）；老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3 老张把响水壶放到火上，立等水开。（异步阻塞）；立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）；老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。对应的也就是消息通信机制</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；对应的也就是程序等待结果时的状态</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">看电视的老张，非阻塞。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>多进程&#x2F;多线程虽然可以解决并发问题,但系统不能无上限地增加线程.由于系统切换线程的开销也很大,所以一旦线程数量过多,cpu的时间就花在线程切换上,真正运行代码的时间就减少了,性能就会下降.我们要解决的核心问题是CPU和IO设备处理速度的严重不匹配.多进程&#x2F;多线程只是解决这个问题的一个办法,而另一个办法就是<code>异步IO</code>.</p><blockquote><p>异步IO:</p><p>当代码需要执行一个耗时的IO操作时,它只发出IO指令,并不等待IO结果,然后就直接执行其他代码.一段时间后,当IO返回结果时,再通知CPU进行处理.</p></blockquote><p>异步IO模型需要一个<code>消息循环</code>,在这个循环中,主线程不断地重复”读取消息-处理消息”这个过程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = get_event_loop()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    event = loop.get_event()<br>    process_event(event)<br></code></pre></td></tr></table></figure><blockquote><p>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。</p><p>由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p><p>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。</p><p>在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p></blockquote><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>又称<code>微线程</code>&#x2F;<code>纤程</code>.英文名Coroutine</p><blockquote><p><code>子程序</code>,或者称为<code>函数</code>,在所有语言中都是<code>层级调用</code>,比如A调用B,B又调用C,C执行完毕返回,B执行完毕返回,最后才是A执行完毕.</p><p>所以子程序调用是通过栈实现的,一个线程就是执行一个子程序.</p><p>子程序调用总是一个入口,一次返回,调用顺序是明确的.</p></blockquote><p>但协程与子程序不同.携程看上去也是子程序,但是在执行过程中,子程序内部可中断,然后转而执行别的子程序,在适当的时候再返回来接着执行.这一点有点类似CPU的中断.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如子程序A和B</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">A</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;z&#x27;</span>)<br>   <br><span class="hljs-comment"># 假如由携程执行,结果可能就是</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>x<br>y<br><span class="hljs-number">3</span><br>z<br></code></pre></td></tr></table></figure><p>协程的特点在于,它是<code>一个线程</code>执行,与多线程相比优势有:</p><ul><li>极高的执行效率: 子程序切换不是线程切换,而是由程序自身控制.因此没有切换的开销.与多线程相比,线程越多,协程的性能优势越明显.</li><li>不需要线程的锁机制: 因为协程只有一个线程,在协程中控制共享资源不加锁,只需要判断状态,所以执行效率比多线程高.</li></ul><blockquote><p>由于协程是一个线程执行,要充分利用多核CPU,最简单的方法就是<code>多线程+协程</code>.</p></blockquote><p>底层实现机制:</p><ol><li>python协程的本质是基于<code>生成器(generator)</code>实现的状态机</li><li>通过字节码操作来实现协程的挂起和恢复</li><li>事件循环负责调度和切换不同的协程</li></ol><p>与操作系统的关系:</p><ol><li>协程是用户态的轻量级线程</li><li>切换由程序自身控制,不需要系统介入</li><li>没有线程上下文切换的开销,无锁</li></ol><p>来看一个例子:</p><p>传统生产者-消费者模型是一个线程写消息,一个线程取消息,通过锁机制控制队列和等待,但一不小心就会死锁.</p><p>如果改用协程:</p><ol><li>生产者生产一条消息后通过<code>yield</code>让出CPU,切换到消费者</li><li>消费者开始处理消息,但生产者并不需要等待消费者处理完</li><li>消费者可以再处理过程中随时通过<code>yield</code>让出CPU,切换回生产者继续生产新消息</li><li>两者可以交替执行,互不阻塞</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>    r = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment"># 初始化返回值</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span> r <span class="hljs-comment"># 核心语句: 让consumer函数变成一个生成器,接受发送过来的值,赋值给n,同时产出r</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n: <span class="hljs-comment"># n=None,if not n--&gt; True, 表示想consumer 生成器不发送东西的话就会直接返回</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)<br>        r = <span class="hljs-string">&#x27;200 OK&#x27;</span> <span class="hljs-comment"># 设置返回值</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">produce</span>(<span class="hljs-params">c</span>):<br>    c.send(<span class="hljs-literal">None</span>) <span class="hljs-comment"># 启动生成器,发送None</span><br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>: <span class="hljs-comment"># 生产5次</span><br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)<br>        r = c.send(n) <span class="hljs-comment"># 发送生产的值,会从yield语句继续执行,yield获取新的n并返回新的r</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)<br>    c.close()<br><br>c = consumer()<br>produce(c)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[PRODUCER] Producing 1...<br>[CONSUMER] Consuming 1...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 2...<br>[CONSUMER] Consuming 2...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 3...<br>[CONSUMER] Consuming 3...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 4...<br>[CONSUMER] Consuming 4...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 5...<br>[CONSUMER] Consuming 5...<br>[PRODUCER] Consumer return: 200 OK<br></code></pre></td></tr></table></figure><blockquote><p>这里最难理解的就是<code>n = yield r</code></p><p>这一行的执行顺序是:</p><ul><li>先返回”返回值r”给调用者</li><li>然后暂停在这里</li><li>等待下一次send()时,把send的值赋给n</li></ul><p>所以上面consumer的代码执行顺序大概这样:</p><ol><li>执行到yield行,先返回”返回值(r)”,然后暂停在这里,等待下一个send</li><li>下一个send到来,把send的值赋给n,然后继续执行下面的代码,再次执行到yield行,再一次返回返回值(r),再一次暂停</li><li>等待再下一个send继续循环</li></ol></blockquote><h1 id="理论对比"><a href="#理论对比" class="headerlink" title="理论对比"></a>理论对比</h1><p>先来理一下协程,异步IO和asyncio三者:</p><ol><li><p>协程(Coroutine)</p><ul><li><p>是一种编程概念,是实现异步编程的基础</p></li><li><p>可以理解为<code>能暂停的函数</code>: 在等待IO时可以主动让出控制权</p></li><li><p>使用async&#x2F;await语法来定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停,让出控制权</span><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure></li></ul></li><li><p>异步IO(Asynchronous IO)</p><ul><li><p>是一种IO操作模型</p></li><li><p>发起IO请求后不等待结果,继续执行其他任务</p></li><li><p>当IO结果就绪时再回来处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例如读文件</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        content = <span class="hljs-keyword">await</span> f.read() <span class="hljs-comment"># 不阻塞等待</span><br>    <span class="hljs-keyword">return</span> content<br></code></pre></td></tr></table></figure></li></ul></li><li><p>asyncio</p><ul><li><p>python的异步编程框架</p></li><li><p>提供运行和管理协程的完整工具集</p></li><li><p>包含时间循环,任务调度,IO操作等功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例如</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    task1 = asyncio.create_task(fetch_data())<br>    task2 = asyncio.create_task(fread_file())<br>    <span class="hljs-comment"># 并发执行多个协程 (虽然是并发,但实际上还是单线程在工作)</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(task1, task2)<br>    <br><span class="hljs-comment"># 启动时间循环运行协程</span><br>asyncio.run(main())<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>asyncio 是框架</li><li>协程是核心机制</li><li>异步IO是主要应用场景</li></ul><p>优点:</p><ol><li>一个线程可以同时处理多个IO操作</li><li>IO等待时间被利用起来做其他工作</li><li>避免多线程的复杂性</li></ol></blockquote></li></ol><h1 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>asyncio</code>是python的异步编程框架,用于编写并发代码.它使用协程,事件循环和任务实现异步编程.</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>协程(Coroutine): 可以暂停执行的函数</li><li>事件循环(Event Loop): 程序调度和执行异步代码的核心</li><li>任务(Task): 协程的包装器,用于跟踪协程的执行</li><li>Future: 表示异步操作的最终结果</li><li>await: 等待一个协程完成</li></ul><h2 id="关键字和语法"><a href="#关键字和语法" class="headerlink" title="关键字和语法"></a>关键字和语法</h2><h3 id="基础关键字"><a href="#基础关键字" class="headerlink" title="基础关键字"></a>基础关键字</h3><ul><li><code>async def</code>: 定义一个协程函数</li><li><code>async with</code>: 异步上下文管理器,相当于<code>with</code>的异步版本</li><li><code>await</code>: 等待一个协程执行完成</li><li><code>asyncio.run()</code>: 运行异步程序的入口点</li><li><code>asyncio.create_task()</code>: 创建一个任务</li><li><code>asyncio.gather()</code>: 并发运行多个协程</li><li><code>asyncio.sleep(n)</code>: 当前协程暂停执行n秒,不会阻塞事件循环,其他协程正常运行.</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建事件循环</span><br>loop = asyncio.get_event_loop()<br><span class="hljs-comment"># 运行协程</span><br>asyncio.run(main())<br><span class="hljs-comment"># 创建任务</span><br>task = asyncio.create_task(coro())<br><span class="hljs-comment"># 等待多个协程完成</span><br><span class="hljs-keyword">await</span> asyncio.gather(coro1(), coro2())<br><span class="hljs-comment"># 延时</span><br><span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="异步爬虫例子"><a href="#异步爬虫例子" class="headerlink" title="异步爬虫例子"></a>异步爬虫例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio <span class="hljs-comment"># python标准库,提供异步编程的基础设施</span><br><span class="hljs-keyword">import</span> aiohttp <span class="hljs-comment"># 第三方库,提供异步的http客户端和服务端</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup <span class="hljs-comment"># 用于解析html和xml</span><br><br><span class="hljs-comment"># 这个函数使用aiohttp发送一个异步GET请求到指定的url</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_html</span>(<span class="hljs-params">session, url</span>): <span class="hljs-comment"># async def 定义一个异步函数</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response: <span class="hljs-comment"># session.get()发送一个GET请求到指定url并返回一个ClientResponse对象</span><br>        <span class="hljs-comment"># async with用于正确管理异步上下文,确保在请求完成后正确释放资源</span><br>        <span class="hljs-keyword">if</span> response.statue == <span class="hljs-number">200</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.text() <span class="hljs-comment"># 获取响应的文本内容(HTML)</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 这里就是使用beautiful soup来解析html</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">此函数其实没有执行任何异步操作,所以它也可以定义为一个普通的同步函数,但是把它也定义为异步函数也是没问题的,主要是为了:</span><br><span class="hljs-string">1. 保持一致性</span><br><span class="hljs-string">2. 未来扩展考虑, 可能未来需要在这个函数内加上异步操作</span><br><span class="hljs-string">不过从性能角度考虑,如果一个函数内没有任何异步操作,最好还是直接定义为同步函数,不然会增加开销</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_links</span>(<span class="hljs-params">html</span>):<br>    soup = Beautifulsoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    links = [a[<span class="hljs-string">&#x27;href&#x27;</span>] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>, href=<span class="hljs-literal">True</span>)]<br>    <span class="hljs-keyword">return</span> links<br><br><span class="hljs-comment"># 递归爬取网页</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl</span>(<span class="hljs-params">url, max_depth=<span class="hljs-number">2</span>, depth=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session: <span class="hljs-comment"># 创建一个ClientSession对象,用于发送HTTP请求</span><br>        html = <span class="hljs-keyword">await</span> fetch_html(session, url) <span class="hljs-comment"># 调用fetch_html函数获取html</span><br>        <span class="hljs-keyword">if</span> html:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Crawling: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>) <span class="hljs-comment"># 如果获取到html就打印正在爬取的url</span><br>            links = <span class="hljs-keyword">await</span> extract_link(html) <span class="hljs-comment"># 并调用extract_link提取连接</span><br>            <span class="hljs-keyword">if</span> depth &lt; max_depth: <span class="hljs-comment"># 递归调用,爬取depth深度的网页</span><br>                <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>                    <span class="hljs-keyword">await</span> crawl(link, max_depth, depth+<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 主函数                   </span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    start_url = <span class="hljs-string">&quot;https://example.com&quot;</span><br>    <span class="hljs-keyword">await</span> crawl(start_url)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main()) <span class="hljs-comment"># 创建事件循环,并在该循环中运行main()</span><br></code></pre></td></tr></table></figure><p>再来看一下关键字的用法:</p><ul><li><p><code>async def</code>:</p><p>此关键字用于定义一个异步函数,需要在以下情况使用<code>async def</code>:</p><ol><li>函数内部需要使用<code>await</code>等待一个耗时的异步操作完成,比如网络请求,文件IO等</li><li>函数需要调用另一个异步函数</li></ol></li><li><p><code>await</code>:</p><p>此关键字只能在<code>async def</code>定义个异步函数内使用.作用是暂停当前异步函数的执行,等待一个耗时的异步操作完成,然后继续执行.一般在以下情况下使用:</p><ol><li>发送网络请求,等待响应返回</li><li>读写文件,等待IO完成</li><li>调用另一个异步函数,等待它执行完毕</li></ol></li><li><p><code>async with</code>:</p><p>当你使用了一个实现了<code>__aenter__</code>和<code>__aexit__</code>方法的<code>异步上下文管理器</code>对象,那么你应该使用<code>async with</code>来获取和释放该对象管理的资源.一些常见的异步上下文管理器包括但不限于:</p><ol><li><code>aiohttp.ClientSession</code></li><li><code>asyncpg.Connection</code></li><li><code>aiomysql.Connection</code></li><li><code>aiofiles.open</code></li></ol></li><li><p><code>asyncio.sleep()</code>:</p><p>这是一个异步函数,可以用于模拟一个耗时的异步操作,让事件循环有机会切换到其他任务.在爬虫中如果你需要控制爬取的速度,避免给网站过高的负载,可以在每次爬取后使用<code>await asyncio.sleep(delay)</code>来暂停一段时间.</p></li></ul><h1 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h1><p><code>asyncio</code>可以实现单线程并发IO.但是这是仅在客户端.如果把asyncio用来服务端,例如web服务器,http连接本身就是IO操作,所以可以通过单线程+<code>async</code>函数实现多用户的高并发操作.</p><p><code>asyncio</code>实现了TCP,UDP,SSL等协议,而<code>aiohttp</code>则是基于<code>asyncio</code>实现的HTTP框架.</p><p><code>aiohttp</code>是第三方库所以要用pip安装.</p><p>下面用<code>aiohttp</code>写一个http服务器,处理以下URL:</p><ul><li><code>/</code>: 首页返回<code>index.html</code></li><li><code>/&#123;name&#125;</code>: 根据URL 返回<code>hello, &#123;name&#125;!</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    text = <span class="hljs-string">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> web.Response(text=text, content_type=<span class="hljs-string">&#x27;text/html&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">request</span>):<br>    name = request.match_info.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>)<br>    text = <span class="hljs-string">f&#x27;&lt;h1&gt;Hello, <span class="hljs-subst">&#123;name&#125;</span>&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> web.Response(text=text, content_type=<span class="hljs-string">&#x27;text/html&#x27;</span>)<br><br>app = web.Application()<br><br><span class="hljs-comment"># 添加路由</span><br>app.add_routes([web.get(<span class="hljs-string">&quot;/&quot;</span>, index), web.get(<span class="hljs-string">&quot;/&#123;name&#125;&quot;</span>, hello)])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    web.run_app(app)<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/python/" class="print-no-link">#python</a></div></div><div class="license-box my-3"><div class="license-title"><div>python笔记-异步IO</div><div>http://example.com/2024/10/29/python-asyncio/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年10月29日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/04/js-begining/" title="JavaScript-入门"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">JavaScript-入门</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/08/28/python-process-thread/" title="python笔记-进程和线程"><span class="hidden-mobile">python笔记-进程和线程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>