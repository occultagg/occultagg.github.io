<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="Linux LinuxA磁盘的文件全部迁移到B磁盘 dd命令  如何创建lvm卷? fdisk分区–&gt;pvcreate–&gt;vgcreate–&gt;lvcreate–&gt;格式化–&gt;挂载  100亿小文件删除，对比怎么删除比较高效?  find + xargs实现分批删除 find命令可以在找到文件的同时逐个处理,不需要将整个文件列表读入内存. find命令的算法可以更快地便"><meta property="og:type" content="article"><meta property="og:title" content="面经"><meta property="og:url" content="http://example.com/2024/06/20/interview-git/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="Linux LinuxA磁盘的文件全部迁移到B磁盘 dd命令  如何创建lvm卷? fdisk分区–&gt;pvcreate–&gt;vgcreate–&gt;lvcreate–&gt;格式化–&gt;挂载  100亿小文件删除，对比怎么删除比较高效?  find + xargs实现分批删除 find命令可以在找到文件的同时逐个处理,不需要将整个文件列表读入内存. find命令的算法可以更快地便"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/interview-1018333_640.png"><meta property="article:published_time" content="2024-06-20T10:13:36.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.055Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="Interview"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/interview-1018333_640.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>面经 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">面经</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-06-20 18:13" pubdate>2024年6月20日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 126 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">面经</h1><div class="markdown-body"><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/interview-1018333_640.png" srcset="/img/loading.gif" lazyload></p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ol><li><p>LinuxA磁盘的文件全部迁移到B磁盘</p><p>dd命令</p></li><li><p>如何创建lvm卷?</p><p>fdisk分区–&gt;pvcreate–&gt;vgcreate–&gt;lvcreate–&gt;格式化–&gt;挂载</p></li><li><p>100亿小文件删除，对比怎么删除比较高效?</p><ol><li><p>find + xargs实现分批删除</p><p>find命令可以在找到文件的同时逐个处理,不需要将整个文件列表读入内存.</p><p>find命令的算法可以更快地便利目录结构,避免不必要的IO操作</p></li><li><p>使用rsync创建一个空目录然后同步过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir empty_dir<br>rsync -a --delete emplty_dir/ /path/to/files<br></code></pre></td></tr></table></figure></li><li><p>并发删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /path/to/files -type f -name &quot;*.ext&quot; | parallel -j 10 rm<br></code></pre></td></tr></table></figure></li></ol></li><li><p>1亿行日志文件,要根据关键字统计出现次数前十的日志,只用脚本,如何做效率比较高?</p><p>将日志拆成多份,使用awk,sed,sort等工具统计排序,可以通过shell的parallel或者python的subprocess多进程&#x2F;多线程提升效率.</p></li><li><p>shell逐行处理大日志文件,有哪几种方式,有什么区别?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span>会一次过读取整个文件的内容</span><br>cat filename.log | while read line<br>do<br>	echo &quot;$line&quot;<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">while</span> + 输入重定向,边读边处理,效率更高</span><br>while read line<br>do<br>	echo &quot;$line&quot;<br>done &lt; filename.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">awk/sed也是默认逐行处理</span><br>awk &#x27;&#123;print&#125;&#x27; filename.log<br>sed -n &#x27;p&#x27; filename.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取实时写入的日志文件</span><br>tail --f filename.log | while read line<br>do<br>	echo &quot;$line&quot;<br>done<br></code></pre></td></tr></table></figure></li></ol><h1 id="中间件-DB"><a href="#中间件-DB" class="headerlink" title="中间件&#x2F;DB"></a>中间件&#x2F;DB</h1><ol><li><p>zookeeper</p></li><li><p>kafka</p><p>架构: 生产者–&gt;broker–&gt;消费者</p><p>topic: 消息类别,生产者和消费者根据topic发送消息或消费消息</p><p>partition: 副本机制</p></li><li><p>redis</p><p>哨兵集群</p></li><li><p>mariadb</p><p>主从集群</p></li><li><p>mongodb</p><p>副本集</p></li><li><p>SQL联表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 内连接<br># 只返回两个表中匹配的记录,如果表A的行与表B的行相匹配,则返回<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br># 左连接<br># 返回左表所有记录和右表中与匹配的记录,没有匹配就显示空值<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br># 右连接<br># 返回右表所有记录以及左表中匹配的记录,没有匹配就显示空值<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br># 全外连接<br># 返回两个表中所有的记录.当左表的行在右表中没有匹配,则在右侧显示空值,反之亦然<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br></code></pre></td></tr></table></figure></li></ol><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><ol><li><p>团队维护同一份github repo,你们是工作流是怎么样的?</p><p>一般采用类似Feature Branch Workflow的流程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;repo_url&gt;<br>git checkout -b &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在分支上开发</span><br>git add .<br>git commit -m &quot;Commit message&quot;<br>git push -u origin &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会在repo上创建一个PR,团队成员对代码进行审查(code review),通过后merge到master分支</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后删除本地和远程的开发分支</span><br>git branch -d feature_branch_name  # 删除本地分支<br>git push origin --delete feature_branch_name  # 删除远程分支<br></code></pre></td></tr></table></figure><p>这是基本的工作流程,期间还可以加入其他步骤,例如代码静态分析(snoarQ),自动化测试,CI&#x2F;CD等</p></li></ol><h1 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h1><ul><li><p>Region &amp; AZs</p><p>region是指地球上的一个物理位置,比如北京,悉尼等.每个region底下都有多个AZ(可用区),AZ是指一个或者多个IDC,AZ之间独立电源和设备,相互之间通过专用线路连接,延迟低的同时也实现故障分离.也就是说一个AZ出问题了不会影响另一个AZ.所以AWS很多服务,比如EC2,RDS的高可用都是通过多可用区去实现的.</p></li><li><p>EC2</p><ul><li>autoscaling组: 自动扩展组</li><li>购买类型<ul><li>预留: 预定(一年或三年)的计算资源,折扣比按需大</li><li>spot: 将aws上未被使用的资源分配给你用,随时停止,按供需变化价格</li><li>按需: 按小时或秒收费</li><li>节省: 在一定时间内(一年或三年)使用一定量的计算资源,换取更低的价格</li></ul></li><li>集群放置组: 单可用区内将实例分配在一起(同一台物理服务器或同一个机架),实现低延迟高吞吐</li><li>分区放置组: 将一批ec2实例分布在一个region下的不同分区中(或者不同机架不同服务器),实现故障隔离.</li><li>实例类型:<ul><li>T3:通用</li><li>R5: 内存优化</li></ul></li><li>终止挂起: EC2 autoscaling检测在实例不健康会自动删除实例创建新实例,有时不方便排查问题,我们可以设置一个生命周期钩子来暂停实例的终止,设置足够长的保留时间来排查问题</li></ul></li><li><p>AWS organization</p><p>集中管理，治理多个aws账户，提供policy为基础的管理功能，用于统筹管理权限.还支持集中账单和提供自动化API.</p><ul><li><p>OUs： 组织单元，允许你按照工作负载，部门，生命周期阶段（测试，开发，生产）等来<code>分组账户</code>.</p></li><li><p>SCP: 服务控制策略，用来管理成员账户的权限.应用到组织的root,OUs或单个账户</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cloudtrail:StopLogging&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁止关闭cloudtrail日志记录</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>IAM</p><ul><li><p>Access Analyzer: 可以通过分析couldtrail日志记录的活动生成IAM访问策略</p></li><li><p>AAA: 认证(authentic)&#x2F;授权(Authorized)&#x2F;记录(Acounting)</p><p>解决谁可以访问什么资源的问题</p></li><li><p>用户:</p><ul><li><p>根用户: 超级管理员,注册aws的账户</p></li><li><p>普通IAM用户: 代表一个具体的人或服务,每个用户都有特定的权限</p></li><li><p>IAM组: 一组具有同样身份的用户</p></li><li><p>IAM 角色(role): 一种权限的集合,任何授权的用户或aws服务都可以暂时性地采用</p></li><li><p>IAM policy</p><p>用户和角色的授权都是通过IAM policy实现,IAM policy一般直接绑定到用户&#x2F;用户组&#x2F;角色,所以不需要写<code>principal</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;ec2:Describe*&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;ec2:StartInstances&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;ec2:StopInstances&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;ec2:TerminateInstances&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>IAM role trust policy</p><p><code>角色信任策略</code>,定义<code>哪些账户或服务可以扮演IAM角色</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;Service&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ec2.amazonaws.com&quot;</span> <span class="hljs-comment">// 允许ec2服务扮演(assume)这个角色</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRole&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br>---<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:iam::123456789012:root&quot;</span> <span class="hljs-comment">// 允许特定的账户扮演这个角色</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRole&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>VPC</p><p>虚拟私有云,可以理解为一个局域网,aws提供的虚拟网络</p><ul><li><p>Peering Link: 对等连接,连接两个vpc(不通过公共互联网传输),两个vpc都要加路由(目的地是对方vpc cidr,指向peering connection),双向,网络对网络</p></li><li><p>Private Link: 在你的vpc中通过私有的网络路径安全地访问aws服务或vpc终端节点,单向,一对一</p><ul><li>VPC endpoint:<ul><li>interface endpoint: 实际上是vpc内创建一个于特定AWS服务相关联的弹性网络接口(ENI),无需修改路由表</li><li>gateway endpoint: 针对S3和dynamoDB的流量优化端点,需要修改路由表</li></ul></li></ul></li><li><p>NACLs: 网络访问控制列表,子网级别的访问控制</p><ul><li>默认拒绝所有</li><li>无状态</li><li>作用在子网,一个NACLs可以关联多个子网,但一个子网只能关联一个NACL</li><li>按顺序匹配规则,第一个匹配的规则生效</li><li>支持黑白名单</li></ul></li><li><p>VPC endpoint policy: 资源策略,用于管理和控制到VPC Endpoint服务的访问,控制哪些aws主题可以使用该端点访问服务</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:iam::123456789012:user/MyUser&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::my-s3-bucket/*&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;StringEquals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;aws:sourceVpce&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vpce-01a23456b789c0d1e&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>AWS的policy默认是拒绝所有的,它的显式拒绝(effect: Deny)会<code>覆盖允许</code>.就是显式拒绝后,就算有其他策略允许了,还是会被拒绝.</p></blockquote></li><li><p>安全组: 虚拟防火墙,控制实例之间的出入流量</p><ul><li>有状态</li><li>默认允许出禁止入</li><li>作用在实例级别.安全组和实例是多对多的关系</li><li>所有规则同时生效(只要有允许该流量的规则,流量就会被放行)</li><li>白名单</li></ul></li><li><p>公有子网: 公有子网的实例可以直接通过<code>互联网网关</code>连接到互联网</p></li><li><p>私有子网: 私有子网通过<code>nat网关</code>去到公有子网再通过<code>互联网网关</code>出到互联网</p><ul><li>nat gateway: 运行在公有子网中给私有子网实例</li></ul></li></ul></li><li><p>ELB</p><ul><li><p>ALB</p><ul><li><p>可以通过安全组控制访问源，仅允许cloudfront流量(com.amazonaws.global.cloudfront)进入，这样客户端就只能访问cloudfront</p></li><li><p>工作在7层的负载均衡</p></li><li><p>根据URL或http头信息路由</p></li><li><p>支持websocket和http&#x2F;2</p></li><li><p>集成ECS和EKS</p><ul><li><p>代理EKS流量</p><blockquote><ol><li>在EKS中部署ALB Ingress Controller</li><li>部署ingress资源</li><li>在应用ingress资源时,ALB ingress controller会为你创建ALB并配置对应的监听器(linstener)和转发规则</li></ol></blockquote></li></ul></li><li><p>提供SSL&#x2F;TLS加解密功能,可以挂https证书</p></li><li><p>元素</p><ul><li><p>监听器(listener): 监听客户端请求(一般是80&#x2F;443),并根据请求路由到目标组的组件</p><ul><li>监听器上可以挂TLS证书(https)</li></ul></li><li><p>目标组(target group): 多个服务端点(ECS容器&#x2F;EC2实例或Lambda函数)组成的集合,每个target group针对特定的服务和端口</p><ul><li>ALB到target group也可以配置TLS</li></ul></li><li><p>规则(rules): 通过监听器上定义的条件和优先级路由到不同的目标组</p></li><li><p>健康检查: 判断目标组中的服务端点是否可以正常接受流量</p><ul><li>HTTP&#x2F;HTTPS&#x2F;TCP</li></ul></li></ul></li></ul></li><li><p>NLB</p><ul><li>工作在4层的负载均衡器</li><li>针对TCP流量优化,可以处理不稳定的和突发的流量</li><li>每个NLB都可以使用一个<code>静态IP</code></li><li>每个AZ一个独立端点,确保扩展性和容错</li><li>使用TCP长连接(websocket)</li><li>元素:<ul><li>监听器(listener)</li><li>目标组(target group)</li><li>健康检查</li><li>NLB也提供TLS监听器</li><li>粘性会话: 通过source IP</li></ul></li></ul></li></ul></li><li><p>Lambda</p><p>程序运行不可以超过15分钟</p><p>内存提供128MB-10GB</p><p>成本计算按<code>GB-秒</code>,也就是1GB用1s多少钱</p></li><li><p>S3</p><ul><li><p>版本控制</p><ol><li>上传的每个对象都会被分配一个唯一的<code>版本ID</code></li><li>对象被覆盖或删除时,旧版本不会被删除而是保留下来</li><li>上传一个跟已存在对象同名的文件,旧文件不会被覆盖,新文件会获得一个唯一的版本ID</li><li>检索开启版本控制的对象,要指定其版本ID,默认返回最新的</li><li>删除开启版本控制的对象,只会逻辑删除.删除对象的特定版本,该版本就会被删除;删除所有版本,对象才会被永久删除</li><li>开启版本控制后的存储桶才能设置<code>生命周期策略</code>,例如自动删除一定时间后的旧版本</li></ol></li><li><p>MFA delete: 多因素删除,要通过多因素认证才能删除对象</p></li><li><p>总的来说S3存储的类型可以这么划分:</p><ul><li><p>standard: 默认.即存即取</p></li><li><p>IA: 非频繁访问</p></li><li><p>Glacier(冰川): 更低的访问频率,读取需要时间,需要收费</p><ul><li>Glacier Deep: 读取延迟12-48小时</li></ul></li><li><p>Intelligent-tiering: 根据访问频率自动归类,免费</p></li></ul></li><li><p>加密</p><ul><li>SSE-S3: 使用S3自己管理的密钥加密数据,每个对象都有唯一的密钥且使用一个主密钥加固</li><li>SSE-KMS: 使用KMS管理的密钥加密数据,KMS提供密钥审计,访问控制和rotate等功能</li></ul></li><li><p>object-lock</p><ul><li>治理模式: 大多数用户不能修改对象,但可以授权某些用户可以修改对象</li><li>和规模式: 任何用户(包括根用户)在保护期之前都不能修改对象</li></ul></li><li><p>访问控制:</p><ol><li><p>存储桶策略: json定义账户对s3的访问,一般都是直接使用存储桶策略</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// policy版本&quot;2008-10-17&quot;或&quot;2012-10-17&quot;,建议选最新的以使用最新功能</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PublicReadForGetBucketObjects&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:PutObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;DenyPublicDelete&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:DeleteObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>ACLs: 粒度比桶策略粗</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccessControlPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Owner</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>owner-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Owner</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AccessControlList</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grant</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Grantee</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">&quot;CanonicalUser&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>owner-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Grantee</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span>&gt;</span>FULL_CONTROL<span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grant</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grant</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Grantee</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">&quot;CanonicalUser&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>user-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Grantee</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span>&gt;</span>READ<span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grant</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">AccessControlList</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AccessControlPolicy</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>IAM policy: 授权用户,组或角色对s3访问</p></li><li><p>预签名URL: 生成一个临时连接,允许用户在没有aws身份验证的前提下访问你的s3对象,有限时</p></li><li><p>跨资源共享(CORS): 设置CORS规则,允许一个或多个指定源的web应用程序对你的s3对象操作</p></li></ol></li></ul></li><li><p>ECS&#x2F;EKS&#x2F;Fargate</p><blockquote><p><code>ECS</code>是高度可扩展的容器管理服务,用于运行,停止和管理docker容器,提供两种模式,其中一种就是fargate,由AWS管理底层资源,用户无需关心底层配置,另一种是EC2模式,创建EC2实例来运行容器,用户需要自己管理EC2.<code>EKS</code>也是类似,有EC2和fargate模式,不过不论哪种模式,使用EKS都不需要管理控制平面的组件,即时是EC2模式,也是通过EC2实例来运行工作节点.</p></blockquote><ul><li><p>task definition: 类似<code>dockerfile+docker run</code>,用来定义如何在ECS上运行容器</p></li><li><p>TaskRoleARN: ECS task关联的IAM角色的ARN.这个角色赋予ECS任务中容器所需权限.</p></li></ul><p>EKS集群如何升级:</p><ul><li><p>影响</p><blockquote><p><code>控制平面</code>的升级是AWS负责的,即使是多可用去高可用,控制平面的升级仍然可能会遇到短暂影响,因为:</p><ol><li>即使使用滚动更新,依然不能排除会有一瞬间的连接失败,因为始终都会有流量转移的操作</li><li>假如还要升级etcd,etcd的中断也会造成某个时间点API的短暂不可用</li><li>ELB和网络路由可能会随着集群升级而进行调整或替换,AWS会尽力保证平滑过渡,但是短暂的抖动是无法避免的</li><li>控制平面升级,集群API会有短暂的不可用,会影响监控,调度等</li></ol><p><code>工作节点</code>升级分两种,一种是EC2模式,一种是fargate模式</p><p>EC2模式又分两种:</p><ul><li>托管节点组<ul><li>AWS会帮你完成大部分工作节点的运维操作,比如:<ul><li>自动化补丁更新和版本升级</li><li>自动替换不健康的节点</li><li>自动使用EKS优化的AMI</li><li>升级过程自动替换节点<ul><li>先启用新版本(新AMI)的节点</li><li>新节点加入集群</li><li>对新节点进行健康检查</li><li>排空旧节点上的pod</li><li>排空后终止旧节点</li></ul></li></ul></li><li>你只需要在EKS控制台,AWS CLI或AWS SDK发起升级即可,AWS会完成剩余操作</li></ul></li><li>自管理节点组<ul><li>则需要用户手动完成上面的操作</li><li>首先要确保控制平面升级成功</li><li>以<code>蓝绿发布</code>的方式升级:<ul><li>使用新的AMI或者手动升级好工作组件版本的AMI来创建新节点</li><li>把新节点加入到集群</li><li>把旧节点排空,确认pod有正常调度到别的节点或者新节点中</li><li>把旧节点踢除</li></ul></li></ul></li></ul><p>至于<code>fargate</code>模式,你只需要确保你的pod在新版本中兼容即可.对比EC2的托管节点组,还是有些区别:</p><ul><li>使用托管节点组,用户需要配置节点组,比如实例类型,数量和自动缩放设置,AWS负责节点的生命周期管理;fargate模式下用户不需要管这些</li><li>fargate完全serverless,以为着你不能进入到节点中做操作</li><li>对于持久存储,ec2模式可以直接使用ebs,如果要共享持久存储,可以使用EFS,FSx for linux&#x2F;windows或S3,以及第三方存储解决方案ceph等,fargate不支持ebs</li></ul></blockquote></li><li><p>备份: 升级前对etcd执行快照备份是必须的,EKS默认会定期备份etcd快照到S3</p></li></ul><p>EKS监控:</p><ul><li>cloudwatch: metrics&#x2F;logs&#x2F;alarms</li><li>eventBridge</li><li>AWS X-Ray: 跟踪分析调试微服务之间的通信</li><li>AMP(Amazon Managed Service for Prometheus): 相当于完全托管的prometheus+grafana服务,与EKS集成,自动发现和监控集群资源</li><li>第三方: datadog</li></ul></li><li><p>Confluent</p><p>完全托管的Kafka服务,可以与lambda,S3等aws服务无缝集成</p></li><li><p>Cloudfront</p><p>CDN服务,提供基础的DDos防护.另外也有故障切换功能</p></li><li><p>AWS glue</p><p>完全托管的ETL(提取,转换,加载)服务,用于处理大量复杂数据准备和载入工作.</p><ul><li><p>glue爬虫(Crawler)</p><p>数据探索: 自动连接到你的数据存储,分析并推断你的数据结构和模式(表,列,数据类型等)</p></li><li><p>自定义分类器(Custom Classifier)</p><p>标准的分类器无法准确识别你的数据格式就需要创建自定义的grok模式来识别</p></li><li><p>grok: 用于解析复杂文本数据和日志的强大工具,由一系列正则表达式组成.grok模式广泛应用在logstash中</p></li></ul></li><li><p>R53</p><p>提供DNS解析,域名注册,健康检查等服务</p><ul><li><p>故障转移:</p><ul><li><p>主动&#x2F;被动: 只有主资源在服务,主资源不健康,流量转到备用资源中</p></li><li><p>主动&#x2F;主动: 多份资源同时服务</p></li></ul></li><li><p>路由策略</p><ul><li>简单: 基础dns查询,不支持健康检查</li><li>延迟: 资源部署在多个aws区域,基于网络延迟,向延迟最低的region路由</li><li>多值: 关联多个资源,并进行健康检查,随机选一个健康的来响应</li><li>地理位置: 根据dns查询发起的地理位置来路由</li></ul></li></ul></li><li><p>secret manager</p><p>专门保护管理敏感信息(用户名密码,密钥等),支持密钥自动rotate,可以使用kms的密钥来加密</p></li><li><p>Event bridge</p><p>无服务器的事件(aws资源状态变更&#x2F;时间表等)总线,基于事件触发aws服务,api调用等</p></li><li><p>SNS: 简单通知服务,发邮件</p></li><li><p>CloudWatch</p><p>有仪表盘,可以监控可以告警,与autoscaling集成,自动调整资源</p><p>复合告警: 通过监控其他告警状态来确定复合告警的状态</p><p>可以监控:</p><ul><li>性能: 实时监控aws资源(ec2实例,rds数据库,s3等)的性能(cpu,流量,IO等)</li><li>日志: 从ec2实例,cloudTrail等源中获取日志</li><li>服务配额监控</li></ul></li><li><p>CloudTrail</p><p>记录存储aws账户中api调用的历史(console,SDKs,awscli等),相当于记录aws上所有操作</p></li><li><p>AWS CLI</p><ul><li>登录<ol><li><p>直接登录账号</p><p>access key id and secret access key</p></li><li><p>通过AssumeRole</p></li></ol></li></ul></li></ul><ol><li><p>假如我需要创建一个VPC,terraform上需要定义哪些资源</p><p>首先是<code>VPC本身</code>,要计划好ip range,然后<code>公有子网</code>,<code>私有子网</code>,如果要出外网,公有子网要创个<code>internet gateway</code>,私有子网一般用<code>nat gateway</code>,创了gateway还要创建<code>路由表</code>,如果VPC内资源要访问S3或者dynamoDB就要创建个<code>网关端口</code>,有了endpoint还要有<code>endpoint policy</code>,有需要的话给子网创个<code>NACL</code>.</p></li><li><p>AWS上做过的项目描述</p><ol><li>建立private link允许别的aws账号下的vpc访问自己vpc下confluent<ol><li>通过lambda 获取confluent实例ip,写到ELB</li></ol></li><li>lambda自动rotate secret for RDS<ol><li>创建lambda通过eventbridge定时触发secret manager 去rotate secret</li></ol></li></ol></li><li><p>限制了EC2的外网访问,却无法阻止DNS查询</p><ul><li>DNS包含TCP和UDP的53端口,可能漏了个协议</li><li>VPC的DHCP选项中提供了一个默认DNS(通常是VPC范围的DNS)</li><li>VPC有与其他VPC有连接(private link,peering link,transit gateway等)</li><li>主要是NACL和安全组的问题,另外私有子网通过nat网关访问互联网,nat网关上也是设置阻止DNS访问</li></ul></li></ol><ul><li><p>SQS</p><ul><li><p>可见性超时</p><p>队列有多个消费者时,消息发送到A消费者消费,在一定时间内,其他消费者对此消息不可见.这就是可见性超时,用来避免消息的重复消费.</p></li><li><p>死信队列</p><p>消息多次消费失败,可以把它发送到一个特定的队列,用于日后问题排查,这个队列就叫死信队列</p></li><li><p>标准队列</p><ul><li>无限吞吐</li><li>不保证消息顺序</li><li>偶发消息重传</li></ul></li><li><p>FIFO队列</p><ul><li>有序传递</li><li>每条消息在给定时间内只会被传递一次</li><li>吞吐有限,最高300条&#x2F;s或者按批次发送,最高3000条&#x2F;批</li><li>支持消息去重</li></ul></li></ul></li><li><p>dynamoDB</p><p>完全托管的noSQL数据库,对标mongodb,提供最终一致性读取和强一致性读取</p><ul><li>TTL: 和mongodb一样,可以对index设置TTL,TTL超时就删除数据,适用于大量小项目持续吞吐的场景</li><li>全局表: 一种具有多个AWS区域复制功能的dynamoDB特性.将两个或多个dynamoDB表,将其连接起来作为全局表的一部分,每个区域的表都视为一个副本,dynamoDB负载数据的复制同步.<ul><li>多活: 所有区域的表都是活的,可以随时读写</li><li>实时: 基于流技术,在几秒或更短的时间内将更新应用到全球所有复制区域</li><li>冲突处理: 使用last-write-win(最后写入胜出)策略</li><li>跨区域一致性: 在几秒内实现跨区域的最终一致性(同一时刻所有区域看到完全一致的数据)</li></ul></li></ul></li></ul><h1 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h1><ol><li><p>terraform语法怎么写</p><p>terrafrom使用的HCL声明式语言,以块的形式组织代码,通过大括号来划分块,常用的块有:</p><ul><li>local{}: 定义本地变量</li><li>resource{}: 定义资源</li><li>data{}: 用于数据查询或计算</li><li>module{}: 引用模块</li><li>ouput{}: 输出数据</li></ul></li><li><p>terrafrom原理</p><p>我们平时所用的terraform,其实是包含两个进程,一个是terraform自身,还有一个就是provider.对应不同的平台有不同的provider,也可以理解成插件或者SDK.terraform主进程主要负责理解并翻译我们写的terraform代码,把它转化成provider可以理解的形式,然后provider负责调用对应平台的API最终实现资源的管理.当我们执行terraform init的时候,terraform会下载所需要的provider,并且会根据配置连接backend,获取statefile,statefile记录这通过terraform管理的平台上的资源的最新状态,通过跟statefile和我们的代码进行对比,terraform plan得出这次我们要对哪些资源做哪些操作,然后通过terraform apply应用变更.</p></li><li><p>如果不用任何第三方backend,如何存储和管理terraform的statefile</p><p>terraform支持pgdb作为后端,同时它也支持通过restful-API请求来与backend交互,意味着我们可以写一个http服务器作为backend.</p></li><li><p>terraform的锁机制</p><p>terraform的状态锁是用来避免并发时发生资源抢占问题的机制,它确保同一时间内只有一个terraform进程可以修改状态文件.当运行一个terrafrom命令时,它会生成一个锁文件并获取它,执行过程中其他terraform进程因为无法获取到这个锁文件所以无法执行.</p></li><li><p>terraform的backend配置写错了,会发生什么?</p><p>backend写错了,会连不上backend,terraform默认会把statefile写在本地,修改好backend后,再次尝试连接,会发现还是连不上backend,terraform根据本地的statefile发现backend配置更改过了,它会尝试连接之前的backend并迁移到新的backend,但之前的backend本身就是错的,所以还是连不上.解决办法就是把本地的statefile移除即可.</p></li><li><p>terraform statefile如何迁移</p><p>比如已经在本地init并apply,terraform会在本地生成statefile.然后修改新的backend配置再次init.terrafrom会检测到backend改变了,它会先确认新backend中有没有状态文件,没有的话就自动迁移状态文件,用户需要手动确定.</p><p>如果检测到新backend已有了状态文件,它会把新旧statefile选在到本地的一个临时目录,然后要求用户人工核对后决定是否覆盖既有的statefile.</p></li><li><p>terraform常用命令</p><p>init&#x2F;plan&#x2F;apply&#x2F;destory&#x2F;fmt&#x2F;validate&#x2F;import&#x2F;froce-unlock&#x2F;output</p></li><li><p>terrafrom工作目录常用文件</p><p>backend.tf&#x2F;provider.tf&#x2F;version.tf: backend配置&#x2F;provider配置和版本信息&#x2F;terraform版本要求</p><p>main.tf&#x2F;data.tf&#x2F;outputs.tf: terraform资源定义代码&#x2F;查询数据data块代码&#x2F;输出代码</p><p>variables.tf: 定义变量代码</p></li><li><p>statefile的安全性</p><ul><li>使用第三方backend,比如S3</li><li>ACL</li><li>加密statefile</li><li>使用版本控制</li></ul></li><li><p>module的管理</p><ul><li>所有module存放在同一个repo里面</li><li>module单独的repo存放管理</li><li><code>source</code>引用官方module</li></ul></li><li><p>你如何管理你的状态文件和锁文件?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hcl">terraform &#123;<br>  required_version = &quot;&gt;= 0.12&quot;<br><br>  backend &quot;s3&quot; &#123;<br>    bucket         = &quot;my-terraform-state-bucket&quot;<br>    key            = &quot;path/to/my/terraform.tfstate&quot;<br>    region         = &quot;us-west-2&quot;<br>    dynamodb_table = &quot;my-terraform-lock-table&quot;<br>    encrypt        = true<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>状态文件存在S3,启用版本控制,锁文件存在dynamodb是推荐的配置.锁文件推荐存放在数据库,这是因为:</p><ul><li>S3提供的是<code>最终一致性</code>,也就是说对象更新后,s3不保证可以立即列出最新的文件版本.但锁文件的读取必须保证每次都是最新的,所以s3并不是最优解</li><li>高并发场景下,数据库可以提供原子操作(要么完成,要么完全不发生)和事务性(一系列操作都作为一个整体来执行,要么所有操作都成功完成要么遇到错误时撤销所有操作,一个事务包括一系列的原子操作),确保并发写入的一致性和隔离性,s3并没有相关的优化</li><li>在S3中,如果多个进程同时对对象操作,会产生竞争条件,这可能会导致锁的并发控制失败.</li></ul></li><li><p>terrafrom执行错误(有人通过console修改了资源,没有通过terraform,状态文件上的状态就跟平台上的状态不一致,此时执行terraform就会报错),如何修正?</p><p>如果是云平台上有的但是statefile没有的,可以通过terraform import,把资源import进去.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform import ADDRESS ID<br></code></pre></td></tr></table></figure><p>ADDRESS: terraform代码中配置的地址,比如aws_instance.my_instance</p><p>ID: AWS资源实例在云平台上的ID(通过console&#x2F;SDK&#x2F;CLI获取)</p></li><li><p>针对不同环境,terraform代码应该如何管理?</p><p>一般是根据环境划分,比如dev对应dev分支,master对应生产环境</p></li><li><p>如何规划管理terraform模块</p><p>一般都是根据完整功能来划分,比如我做过的rotate secret,里面包括secret manager, lambda和event bridge等,就全写到同一个模块里面.但是长久以往,特别是你这一份terraform要负责管理的team多的时候,很容易出现代码重复的问题.这时可以通过将常用的基础模块独立出来,比如vpc,安全组等单独一个模块,然后要组件别的infra的时候就用source引用,模块设计的时候也要注意,根据实际多设一些变量或默认值,让你的基础模块有更大的灵活性和可用性.另外其实一般公有云都有写好的基础模块,比如aws,gcp都有对应的vpc模块在github上,可以直接引用.</p></li><li><p>我terraform代码模块的路径改变了,如何让statefile也随之更新,为什么要更新?</p><p>terrafrom的状态文件主要包含三个状态信息:</p><ol><li>资源当前状态</li><li>配置中定义的期望状态</li><li>上面二者之间的映射</li></ol><p>当terraform配置的路径和结构与statefile不一致时,会丢失资源的跟踪.比如你把module.a移动到了module.b,apply时terraform会更根据现有的statefile去寻找资源,这些资源仍然关联着旧的路径(module.a),此时terraform会认为无法找到module.b这个资源,而尝试重新创建它. 因此路径变更如果未及时反映到状态文件中,会导致terraform状态与实际云环境的状态不一致,plan和apply可能会提出错误的改动计划,可能会导致资源无意中的破坏或重复创建.另外状态文件不更新也会导致依赖关系混论.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新状态文件的方法主要靠terraform state子命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">address: module.&lt;模块名&gt;.&lt;资源类型&gt;.&lt;资源名称&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">module路径改动</span><br>terraform state mv module.old_module.resource_name module.new_module.resource_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在terraform管理中移除资源但不实际销毁它</span><br>terraform state rm &lt;address&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出当前terraform状态文件中所有资源</span><br>terraform state list<br>terraform state show &lt;address&gt;<br></code></pre></td></tr></table></figure></li><li><p>terraform我在module.a中定义了一个output或data块,我如何在module.b中引用它,但不创建module.a的资源?</p><p>首先定义module.a的output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hcl"># module.a/outputs.tf<br>output &quot;example_output&quot; &#123;<br>  value = aws_instance.example.id<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用module.a的output要先声明,然后才能引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl"># 主 Terraform 配置<br>module &quot;a&quot; &#123;<br>  source = &quot;./path/to/module.a&quot;<br>  # module.a 的其他输入变量...<br>&#125;<br>module &quot;b&quot; &#123;<br>  source = &quot;./path/to/module.b&quot;<br>  input_variable = module.a.example_output<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只用到module.a的output而不创建module.a的资源,可以通过<code>有条件创建</code>来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl"># module.a 中的资源<br>resource &quot;aws_instance&quot; &quot;example&quot; &#123;<br>  count = var.create_instance ? 1 : 0<br>  # 其他配置...<br>&#125;<br></code></pre></td></tr></table></figure><p>不过output一般都依赖于资源,所以大部分情况下是跨模块引用data的值.要做到这一点,需要先在module.a中定义data块,然后通过output块公开你的data查询的值,再使用上面的方式来实现.更优雅的做法是,定义个<code>专门用于数据查询的模块</code>,里面不写任何resource,只写data,查询出来的值如果要在别的地方引用就通过output公开,然后通过上面的方式引用.</p></li></ol><h1 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h1><ol><li><p>Jenkinsfile具体语法怎么写</p><p>我一般使用声明式来写,首先是<code>pipeline</code>,如果有需要的话通过<code>agent</code>指定执行pipeline的jenkins节点,<code>parameter</code>定义参数,<code>environment</code>定义环境变量,然后就是<code>stages</code>和<code>stage</code>定义pipeline的各个阶段,每个stage中通过<code>steps</code>块来定义具体要做的动作,有时候pipeline的场景比较复杂,我会通过<code>script</code>块来写groovy,加一些判断,循环或者错误检测.最后通过<code>post</code>做一些收尾操作,比如clean work dir之类的.</p><p>另外我还写过一些功能块,比如<code>trigger</code>配合cron,定时运行pipeline;通过<code>when</code>来有条件地执行某些stage.还有<code>environment</code>可以定义在<code>stage</code>内,只在该stage内生效.</p></li><li><p>jenkins的凭证如何分级</p><p>凭证的管理分两个维度,一个叫<code>范围</code>,一个叫<code>域</code></p><p>范围有:</p><ol><li>全局: 所有项目可用,除非在域中做了限制</li><li>系统: 只允许jenkins自身以及它的节点使用</li><li>用户: 只能该用户使用</li><li>folder: 只有该folder下的项目可以使用</li></ol><p>域: 是一个对凭证<code>逻辑分组</code>的机制,比如说我们可以创建一个域,该域下的凭证只有在访问某个域名的时候才能使用.凭证默认创建在全局域下,全局域没有任何限制.</p></li><li><p>jenkinsfile如何处理并发</p><p>通过<code>parallel</code>关键字声明并发任务,下面的task1和task2会并发执行,通过<code>执行器</code>来实现,所以执行器数量决定了并发任务的数量.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent any<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;Parallel Stage&#x27;</span>) &#123;<br>            steps &#123;<br>                script &#123;<br>                    parallel(<br>                        <span class="hljs-symbol">failFast:</span> <span class="hljs-literal">false</span>, <span class="hljs-comment">// true: 其中一个任务执行失败,其他任务也会停止执行</span><br>                        <span class="hljs-symbol">task1:</span> &#123;<br>                            <span class="hljs-comment">// Task 1 steps</span><br>                            echo <span class="hljs-string">&#x27;Running task 1&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-symbol">task2:</span> &#123;<br>                            <span class="hljs-comment">// Task 2 steps</span><br>                            echo <span class="hljs-string">&#x27;Running task 2&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-comment">// Add more tasks if needed</span><br>                    )<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>jenkinsfile中三个单引号引用的代码和3个双引号引用的代码有什么区别?</p><p>3个引号都是用来引用多行字符串,单引号不会解析特殊字符,比如shell的变量引用$,双引号会解析.</p></li></ol><h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><ol><li><p>ansible语法怎么写</p><p>主机清单用INI,playbook和role用yaml和jinja2模板</p><p>常见的flag有:</p><p>name: playbook的名字</p><p>host: 远程主机名或组名</p><p>become: 是否要提升权限</p><p>become_method: 提升权限的方式,一般是sudo</p><p>remote_user: 登录到远程主机的的账号</p><p>vars: playbook定义的变量</p><p>tasks: 任务列表,每个任务都有单独的name,具体task里面的操作都是通过模块来实现,比如ping,yum,service,shell,command等等</p><p>notify和handler: 触发器和响应器,比如说一个task修改配置文件,在这个task里面定义notify,配置文件修改成功,就触发handler去重启服务</p><p>tags: 在任务中定义,用来单独执行某个task或跳过某个task</p></li><li><p>ansible的role是什么?如何编写?</p><p>role是一种组织playbook的方式,也是一种代码复用的方式.它通过一个目录结构来组织,比如:</p><p>task文件夹下写task列表</p><p>vars文件夹下定义变量</p><p>files文件夹放需要传输的文件</p><p>template文件夹放jinja2模板</p></li><li><p>ansible的变量</p><ul><li>内部变量,比如:<ul><li>: 主机清单中定义的主机的信息(主机名/ip等),以及主机清单中定义的变量和fact收集的主机的信息,字典</li><li>: 主机变量中组变量字典</li><li>: 当前远端主机的fact收集的信息字典</li><li>: 当前playbook所有主机列表</li></ul></li><li>fact: 在task中通过setup模块获取到的远端主机的系统信息</li><li>role的vars文件夹中定义的变量</li><li>主机清单中定义的变量</li></ul></li></ol><h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><ol><li><p>K8S由哪些组件构成,每个组件的功能是什么。</p><p>控制面板:</p><ul><li>apiserver: 集群API入口,也负责集群其他组件的交互,集群的大脑,也负责验证授权等</li><li>controller-manager: 管理控制器,管理deployment,statefulset,daemonset这些控制器的,另外service的clusterIP是虚拟IP,其实也是controller-manager负责分配的</li><li>scheduler: 调度器,根据算法计算pod分配到哪个node</li><li>core-dns: 提供集群内的DNS服务</li><li>etcd: k-v存储数据库,存储集群的所有配置数据</li></ul><p>工作平面:</p><ul><li>kubelet: 负责节点上的pod的生命周期管理</li><li>kube-proxy: 维护ipvs&#x2F;iptables规则,service实际上就是通过这些规则转发</li></ul></li><li><p>daemonset,deployment和statefulset的区别是什么?</p><ul><li>daemonset用来保证pod在<code>每一个节点上都运行一个</code>,一般用来运行日志收集,监控,存储等应用</li><li>deployment用来部署<code>无状态的应用</code>,并且支持声明式更新,可以实现滚动更新和回滚</li><li>statefulset用来部署<code>有状态应用</code>,它会给每个副本分配<code>稳定且唯一的网络标识和持久存储</code>,它的部署,扩展,回滚,终止以及滚动更新都是<code>有序</code>的</li></ul></li><li><p>有无写过yaml文件，里面一般有什么参数和变量</p><ul><li><p>apiVersion: 不同的资源不同的k8s版本都会有点不一样</p></li><li><p>kind: 定义资源类型</p></li><li><p>metadata: 资源的元数据,包括namespace和资源name</p></li><li><p>label: 资源的标签</p></li><li><p>spec: 定义对资源的期望状态,不同的资源有不同的参数定义,</p><p>比如deployment要定义replicas(副本数),selector(标签选择器),template(pod模板)</p><p>比如service要定义service-type,默认是clusterIP,ports和targetPort</p></li><li><p>configmap: 配置文件</p></li><li><p>secret: 敏感数据</p></li><li><p>PV和PVC: 定义持久存储</p><ul><li>accessMode: readWriteOnce&#x2F;readWriteMany&#x2F;readOnlyMany</li><li>storageClassName: 指定使用哪个存储类</li></ul></li></ul></li><li><p>有无用过探针，有几种类型，yaml文件怎么写</p><ul><li>启动探针(startup):用来判断容器内应用是否已经启动完成,只有这个探针成功了,才会开始应用后面两个探针,失败了就杀死容器然后重启</li><li>存活探针(liveness): 用来判断容器是否正在运行,检测失败就会杀死容器并重启</li><li>就绪探针(readiness): 用来判断容器是否可以接受流量,检测失败,service就不会转发流量给它</li></ul><blockquote><p>三个探针都有http get&#x2F;tcp socket&#x2F;exec的探测方式</p></blockquote><p>重启策略:</p><ul><li>Always: 不论容器返回状态码是什么,都会尝试重启容器</li><li>Onfailure: 容器返回状态码非0(非正常退出),就重启</li><li>Never: 不论容器返回状态码是什么,不论探针检测结果是什么都不会重启</li></ul><blockquote><p>一个pod内的容器共享生命周期,所以容器重启也代表pod重启.</p></blockquote><p>参数:</p><ul><li>exec<ul><li>command</li></ul></li><li>httpGet<ul><li>path</li><li>port</li><li>host</li><li>scheme: http&#x2F;https</li><li>httpHeaders</li></ul></li><li>tcpsocket:<ul><li>port</li><li>host</li></ul></li><li>initialDelaySeconds: 容器启动后多久执行第一次探测</li><li>periodSeconds: 执行探针的频率</li><li>timeoutSeconds: 超时时间</li><li>successThreshold: 成功多少次才判断成功</li><li>failureThreshold: 失败多少次才判断失败</li></ul></li><li><p>有无听过节点亲和性，具体怎么实现</p><p>节点亲和性基于nodeSelector和节点标签实现,它有两种类型,一种叫required(硬亲和),一种叫perfer(软亲和).硬亲和就是pod只能调度到匹配规则的节点上,没有就不调度,软亲和则是优先把pod调度到符合规则的节点,没有匹配的就调度到其他节点.软亲和何以设定多个并根据权重设置优先级.</p><p>它通过几个操作符来匹配:</p><ul><li>In&#x2F;NotIn: 节点必须具有&#x2F;没有指定的标签(key)和值(value)</li><li>key只能指定一个,value可以指定<code>一个列表</code>,只要节点标签的值在列表中有&#x2F;没有就算符合</li><li>Exists&#x2F;DoesNotExist: 节点必须有&#x2F;没有指定的标签(key)</li><li>Gt&#x2F;Lt: 节点标签的值必须大于&#x2F;小于指定值</li></ul><p>通过关键字<code>affinity</code>下的<code>nodeaffinity</code>定义</p></li><li><p>有无听过水平扩容和垂直扩容，具体怎么实现</p><p>水平扩容就是(<code>HPA</code>),基于metrics-server获取的实时资源使用数据来实现,比如我设置HPA的值是cpu平均利用率80%,那么K8S就会尽量将它保持在80%.利用率大于80%就扩容,小于80%就缩容.但是为了避免频繁地扩缩容,左右横跳,HPA提供一些参数和机制,比如扩缩容后有<code>冷却时间</code>,计算触发值的时候会把<code>平均值</code>也纳入计算,以及还有一个<code>稳定窗口</code>的概念(触发值超过设定值一定时间后才会触发扩缩容)</p><p>垂直扩容(<code>VPA</code>)同样也是基于metrics-server的数据来实现.它不是通过加副本来加强性能,而是通过调节pod的cpu和内存来加强性能.VPA适用于不能随便扩展副本数来加强负载的应用,比如数据库.但是VPA有个地方需要注意,它是有可能导致pod直接重启,生产环境应该选择<code>Off</code>或者<code>Initial</code>模式</p></li><li><p>有无听过动态扩容，具体怎么实现，动态扩容应用在什么地方（pod还是节点）</p><p>Cluster AutoScaler,使用一个特定的容器实现(k8s.gcr.io&#x2F;cluster-autoscaler),它会通过k8s的API获取它所需要的信息,比如集群的资源使用情况,有多少个pod处于pending状态等,然后调用对应底层平台的API,比如AWS的GCP的或者私有云的openstack的,来实现节点的按需扩缩容</p></li><li><p>如何升级k8s集群</p><p>使用kubeadm部署的集群也是通过kubeadm来升级.首先通过<code>kubeadm upgrade plan</code>来验证升级计划,然后通过<code>kubeadm upgrade apply</code>来应用升级,kubeadm主要负责控制平面组件的升级,一般生产环境中master都会部署高可用,所以需要一个个节点来.至于工作平面的组件,先要通过<code>cordon</code>命令禁止pod的调度,然后通过<code>drain</code>命令驱逐节点上的pod,然后再升级节点的kubelet,升级完通过<code>uncordon</code>来恢复调度,也是要一个个节点来.</p><p>生产环境一般采用滚动更新的方式,先创建一个新版本的新节点,然后加入到集群,再驱逐旧版本的一个节点并把它从集群中剔除.</p></li><li><p>secret如何增加安全性?</p><p>集群内组件的通信都要配上TLS,保证传输过程加密</p><p>etcd数据加密</p><p>配置RBAC和network policy对secret进行访问控制</p><p>可以使用第三方来存储secret,比如AWS的secret manager</p><p>禁止hardcode,包括日志中</p></li><li><p>pod创建过程</p><ul><li>用户提交创建pod的请求给API-server</li><li>apiserver会将相关信息写入etcd,写入完成就返回确认信息给客户端</li><li>apiserver会反映etcd中的状态变化,所有k8s组件都会通过watch机制来跟踪检查api server上的变动</li><li>比如scheduler通过watch机制觉擦到apiserver创建了一个pod但未绑定到任何节点,它就会使用调度算法为这个pod计算节点,并更新到apiserver</li><li>apiserver会把调度结果写入etcd</li><li>被调度到的节点上的kubelet会在本地抵用容器运行时(CRT)运行容器,并将容器状态同步给apiserver</li><li>apiserver更新写入到etcd,写入完成,apiserver通知kubelet完成.</li></ul></li><li><p>K8s中的跨节点通讯</p><ul><li><p>flannel有两种模式,默认是VxLan,类似VPN,在两个pod之间建立一条虚拟的隧道,使用VxLan封装,因为需要额外的封装,所以开销大性能弱</p><p>另一个是host-gw,它会在每个节点上维护一个静态的路由表,根据路由表进行流量转发,它要求每个节点都有一个单独的子网</p></li><li><p>calico的原理跟flannel的host-gw类似,也是维护路由表,但是它使用动态路由协议BGP,所以它不需要为每个节点单独分配一个子网</p></li></ul></li><li><p>k8s的资源限制</p><ul><li>ResourceQuota: 限制名称空间内<code>所有资源总量限制</code>,包括pod&#x2F;service&#x2F;pvc等数量,也包括cpu&#x2F;内存的总量</li><li>LimitRange: 限制namspace内<code>单个pod或container</code>层面上的资源分配</li></ul></li><li><p>写一份NetworkPolicy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-network-policy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># 策略所在的名称空间,也是策略生效的名称空间</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span> <span class="hljs-comment"># 策略应用的具体pod</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">db</span><br>  <span class="hljs-attr">policyTypes:</span> <span class="hljs-comment"># 表示该策略是应用到哪个方向的流量</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Egress</span><br>  <span class="hljs-attr">ingress:</span> <span class="hljs-comment"># 入流量白名单</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/16</span><br>        <span class="hljs-attr">except:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">172.17</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">project:</span> <span class="hljs-string">myproject</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 这是允许被连接到的端口,也就是入方向流量可以连接到的端口</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>  <span class="hljs-attr">egress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">5978</span><br></code></pre></td></tr></table></figure></li><li><p>etcd如何备份还原</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">etcdctl snapshot save/restore<br></code></pre></td></tr></table></figure></li><li><p>如何写helm,如何管理helm包</p><blockquote><ul><li>helm v3后直接通过kubeconfig连接apiserver</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">wordpress/<br>├── charts # 这个目录用于存放本 Helm chart 依赖的其他 chart。如果你的应用程序依赖于其他服务（如数据库、缓存等），对应的 chart 应该放在这个目录下。默认情况下，此文件夹为空。<br>├── Chart.yaml # 这个文件包含了 chart 的基本信息，如版权、版本、名称和描述。这是 chart 的元数据文件和身份信息<br>├── templates # 这个目录包含定义 Kubernetes 资源的模板文件。Helm 会结合 `values.yaml` 中的值和这些模板来生成 Kubernetes 资源定义文件。<br>│   ├── deployment.yaml # 定义了用于创建和管理应用程序基础 Pod 的 Deployment 资源。<br>│   ├── _helpers.tpl # 包含模板帮助信息和定义模板函数，可以在其他模板文件中重用。<br>│   ├── hpa.yaml # 如果启用，定义 Horizontal Pod Autoscaler，根据 CPU 使用率或其他选择的指标自动缩放 Deployment。<br>│   ├── ingress.yaml # 定义 Ingress 资源，用于管理外部访问到你的应用程序的 HTTP/HTTPS 路由。<br>│   ├── NOTES.txt # 包含安装后的使用说明，当执行 `helm install` 命令后，这些信息会显示给用户。<br>│   ├── serviceaccount.yaml # 创建 ServiceAccount，以便为 pod 提供身份认证。<br>│   ├── service.yaml # 定义 Service 资源，用于定义如何访问和暴露你的应用程序。<br>│   └── tests # 包含测试资源<br>│       └── test-connection.yaml # 定义了一个后置测试，用于验证应用程序是否可以正常连接。<br>└── values.yaml # 包含默认的配置值，这些值在结合 templates/ 中的模板时使用。用户可以自定义这些值来覆盖默认设置<br></code></pre></td></tr></table></figure><ol><li>使用<code>helm create &lt;name&gt;</code>创建helm包(chart)</li><li>编辑<code>Chart.yaml</code>写chart包的元信息(版本信息,作者,描述等)</li><li>写<code>templates</code>目录下的k8s资源模板(deployment.yaml,hpa.yaml等)</li><li>写<code>values.yaml</code>定义变量和默认值</li><li><code>files</code>目录下放一些模板中引用的文件(脚本或配置文件)</li><li>使用<code>helm install &lt;release_name&gt; &lt;path_to_chart&gt;</code>安装测试chart</li></ol><p>常用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm create &lt;name&gt;<br>helm install &lt;release_name&gt; &lt;path_to_chart&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打包成.tgz方便存储或分发</span><br>helm package &lt;path_to_chart&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加仓库</span><br>helm add &lt;repo_name&gt; &lt;repo_url&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级</span><br>helm upgrade &lt;release_name&gt; &lt;repo_name&gt;/&lt;chart_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本控制/回滚</span><br>helm rollback &lt;release_name&gt; &lt;revision&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="EFK"><a href="#EFK" class="headerlink" title="EFK"></a>EFK</h2><ol><li><p>有无用过ELK，具体搭建过环境</p><p>部署过EFK,<code>headless service代理statefulset 3节点 es集群</code>,使用<code>daemonset部署fluentd</code>,监听的是宿主机的容器日志目录<code>/var/log/containers</code></p><p>使用fliter的<code>concat</code>插件实现多行信息拼接,使用filter的<code>grep</code>插件只采集特定标签的pod的日志</p></li><li><p>ES index的生命周期管理(ILM)</p><p>热&#x2F;温&#x2F;冷&#x2F;删除,一般是根据数据的读写频率以及物理磁盘的性能分层存放,不过我做过的就只是热+删除,实现过了一定时间就删除日志数据的功能</p></li><li><p>ES索引如何备份</p><p>使用es的快照与恢复功能: 支持各种快照仓库(S3,HDFS,本地文件系统等)</p><ul><li><p>配置快照仓库</p><p>elasticsearch.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">path.repo:</span> [<span class="hljs-string">&quot;/mount/backups/my_backup&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>注册快照仓库</p><p>PUT &#x2F;_snapshot&#x2F;my_backup_repository&lt;自定义仓库名称&gt;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fs&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/mount/backups/my_backup&quot;</span><br> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建快照</p><p>PUT &#x2F;_snapshot&#x2F;my_backup_repository&#x2F;my_snapshot&lt;自定义快照名称&gt;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;indices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;log_index&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ignore_unavailable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include_global_state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>恢复快照</p><p>POST &#x2F;_snapshot&#x2F;my_backup_repository&#x2F;my_snapshot&#x2F;_restore</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;indices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;log_index&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ignore_unavailable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include_global_state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><ol><li><p>有无用过普罗米修斯等监控工具，知不知道普罗米修斯的语法怎那么写</p><p>部署过prometheus 联邦集群监控超过500台混合云环境的虚拟机,和一个k8s集群.它的查询语法叫promQL,基本语法就是metric-name{lables:value},查询支持pattern匹配,另外prometheus自带很多聚合函数,比如max(),avg()等等</p></li><li><p>如何用prometheus监控k8s集群</p><p>部署kube-state-metrics,通过这个容器获取metrics,另外api-server,control-manager,secheduler,core-dns等组件都有原生的metrics API,可以通过在prometheus中直接配置获取metrics.</p></li></ol><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol><li><p>有无写过dockerfile，语法是什么，公司的项目组用到什么镜像</p><p>FROM: docker的镜像是层级结构的,所以每次build镜像都要有一个最底层的基础镜像,from用来指定这个基础镜像</p><p>ADD: 复制文件到镜像中</p><p>COPY: 也是复制文件,不过它支持tar包和URL,tar包还可以自动展开</p><p>RUN: 在镜像<code>build</code>的过程中执行的命令</p><p>CMD: 定义镜像运行时要执行的命令,不过一般是用来给entrypoint传参用</p><p>ENTRYPOINT: 定义镜像的父进程</p></li></ol><h2 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h2><ol><li><p>helm架构?</p><p>V3后的helm,取消了中间件tiller,直接通过kubeconfig连接集群</p></li><li><p>helm动态环境支持</p><p>value.yaml配置变量,template定义模板来实现对不同环境的支持</p></li><li><p>helm不验证登录,如何获取镜像</p><p>如果是私有仓库,可以通过管理员配置允许匿名访问,另外可以提前在k8s集群中配好secret,然后在helm chart中定义imagePullSecret就可以免密获取镜像</p></li></ol><h1 id="Python运维脚本"><a href="#Python运维脚本" class="headerlink" title="Python运维脚本"></a>Python运维脚本</h1><ol><li><p>有无经常用python写运维脚本</p><p>曾经用python开发了一个prometheus的exporter基于它的官方SDK,也二开了一个alertmanager的webhook实现自定义告警</p></li><li><p>python创建一个父类,假如我不希望继承这个父类的子类使用父类中的某个变量,我可以怎么做?</p><p><code>__</code>双下划线定义私有变量</p></li><li><p>python中有哪些数据类型?</p></li><li><p>深浅拷贝的区别?</p></li><li><p>装饰器是做什么用的?</p></li><li><p>单元测试</p></li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="基本编程算法"><a href="#基本编程算法" class="headerlink" title="基本编程算法"></a>基本编程算法</h2><ol><li><p>排序算法</p><p>快速排序</p><p>归并排序</p><p>冒泡</p></li><li><p>搜索算法</p><p>二分查找</p></li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ol><li>轮询</li><li>最少连接</li><li>哈希</li><li>随机</li></ol><h2 id="故障诊断和恢复"><a href="#故障诊断和恢复" class="headerlink" title="故障诊断和恢复"></a>故障诊断和恢复</h2><ol><li><p>冗余</p><p>raid 0</p><p>raid 5</p></li><li><p>备份</p><p>全量</p><p>增量</p><p>差异备份</p><p>快照</p></li></ol><h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><ol><li>二分法</li><li>动态规划&#x2F;贪心算法</li></ol><h2 id="网络算法"><a href="#网络算法" class="headerlink" title="网络算法"></a>网络算法</h2><p>最短路径</p><p>流控制(滑动窗口协议)</p><h2 id="数据一致性和同步"><a href="#数据一致性和同步" class="headerlink" title="数据一致性和同步"></a>数据一致性和同步</h2><p>一致性哈希算法</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ol><li>AES</li><li>RSA(非对称加密): 安全管理密钥</li></ol><h2 id="版本控制算法"><a href="#版本控制算法" class="headerlink" title="版本控制算法"></a>版本控制算法</h2><ol><li>合并算法(三向合并)</li></ol><h2 id="系统设计算法"><a href="#系统设计算法" class="headerlink" title="系统设计算法"></a>系统设计算法</h2><ol><li>队列(kafka,rabbitMQ,rocketMQ)</li></ol><h2 id="监控和日志分析"><a href="#监控和日志分析" class="headerlink" title="监控和日志分析"></a>监控和日志分析</h2><ol><li>正则表达式</li></ol><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ol><li><p>OSI7层模型</p><p>应用层: 用户交互和数据最终处理</p><p>表示层: 数据的编码和解码,给应用层翻译数据</p><p>会话层: 应用之间的会话管理</p><p>传输层: TPC&#x2F;UDP协议</p><p>网络层: IP协议</p><p>数据链路层: mac地址寻址,arp协议</p><p>物理层: 物理链路</p></li><li><p>TCP&#x2F;IP4层模型</p><p>应用层: http&#x2F;https&#x2F;smtp&#x2F;ftp等</p><p>传输层: TCP&#x2F;UDP</p><p>网络层: IP协议</p><p>数据链路层: 网络硬件</p></li><li><p>TCP协议</p><p>面向连接: 数据传输之前需要先建立连接(<code>3次握手</code>)</p><p>可靠传输: 使用序列号和ack响应来保证数据的<code>顺序和可靠</code>,在特定时间没有收到ack就会<code>重传</code></p><p>数据流: 数据以<code>无结构的字节流</code>发送</p><p>流量控制: <code>滑动窗口协议</code>避免快发送方淹没慢接受方</p><p>拥塞控制: 算法(慢启动,拥塞避免,快速重传和快速恢复)</p><p>错误检测: tcp头包含一个<code>校验和字段</code>,用于 检测数据在传输过程中的错误</p></li><li><p>TCP3次握手4次挥手</p><p>3次握手:</p><ol><li>客户端发起SYN包给服务端</li><li>服务端收到后回一个SYN+ACK</li><li>客户端收到服务端的ACK后再回一个ACK,握手完成,连接建立</li></ol><p>4次挥手</p><ol><li>客户端发一个FIN包,申请断开连接</li><li>服务端返回一个ACK,表示收到请求</li><li>服务端没有数据发了,再发一个FIN包,表示它也可以断开连接了</li><li>客户端返回一个ACK,并等待2MSL时间,正式断开连接</li></ol></li><li><p>HTTP协议</p><ol><li><p>通过TCP3次握手建立连接</p></li><li><p>发送http请求(请求方法,请求资源URI,请求头等)</p></li><li><p>服务器响应请求(状态码,响应头和响应体等)</p></li><li><p>响应完成tcp4次挥手断开连接</p><blockquote><p>http是无状态协议,跟踪对话需要用cookie,session机制</p></blockquote></li></ol></li><li><p>HTTPS协议</p><p>握手阶段(非对称加密)</p><ol><li>客户端发起一个https请求,附带客户端支持TLS版本,加密方式等</li><li>服务端根据客户端支持的TLS版本,加密方式等发服务端的<code>https证书</code>和服务端的<code>公钥</code>给客户端</li><li>客户端验证证书是否可以信任(公信力CA),并随机生成一个<code>对称密钥</code>,用服务端的公钥加密后发送给服务端</li><li>服务端使用<code>私钥解密</code>对称密钥,至此握手完成</li></ol><p>通信阶段(对称加密)</p><p>双方通过<code>对称密钥</code>加解密通信</p></li></ol><h1 id="DEVOPS和CI-CD理念"><a href="#DEVOPS和CI-CD理念" class="headerlink" title="DEVOPS和CI&#x2F;CD理念"></a>DEVOPS和CI&#x2F;CD理念</h1><ol><li><p>如何理解CICD?</p><p>CI是持续集成,是一种开发实践,每次代码合并后都自动运行测试和其他验证过程就是CI</p><p>CD是持续部署,是CI的延申,实现自动化的构建,测试和部署</p><p>CI&#x2F;CD的一般流程就是代码提交合并触发CI过程,运行自动化测试(比如用sonarQ检查代码质量,漏洞等),测试通过就开始编译,打包,然后触发CD过程,自动部署到一个或多个非生产环境进行测试,测试都通过了没问题,就可以计划部署到生产环境</p></li><li><p>如何理解敏捷开发?</p><p>与敏捷开发模型(Agile Development Model)相对是的瀑布流模型(Waterfall Model).</p><p>敏捷开发模型:</p><pre><code class="hljs">- 强调灵活,变更成本低,迭代增量式开发,适合需求不明确
</code></pre><p>瀑布流模型:</p><ul><li>严格遵从阶段顺序线性开发,变更成本高,需求需要明确</li></ul></li><li><p>git工作流</p><p>适合敏捷开发模型的git工作有两个Git Flow 和 GitHub Flow.</p><p>Git Flow:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">- main #(稳定分支) 永远保存可部署的稳定版本,通常用tag标记具体版本号,用来记录版本发布历史,每次合并代表一个正式版本<br>- develop #(主开发分支) 所有开发在develop分支执行,develop不会直接合并到main<br>- feature/* #(特性分支) 新功能从develop创建feature分支,功能完成后合并回develop分支<br>- release/* #(发布分支) 发布时从develop创建release分支,发布完成合并到develop和main<br>- hotfix/* #(紧急修复分支) 从main分支创建hotfix分支,修复生产环境紧急bug,完成后合并到develop和main<br></code></pre></td></tr></table></figure><p>GitHub Flow:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">- main #(生产分支)<br>- feature/* #(特性分支)<br></code></pre></td></tr></table></figure></li><li><p>devops排查问题的思路?</p><ul><li>收集信息</li><li>复现问题</li><li>寻找根因</li><li>制定解决方案</li><li>测试验证</li><li>分析记录</li></ul></li><li><p>遇到网络流量异常,如何排查问题?</p><p>在上面的基础上有些特定的操作:</p><ul><li>分析流量制造者,确定它的行为模式和停止它们的方法</li><li>分析网络路径: 通过traceroute,ping,dig,tcpdump等工具捉包分析</li><li>检查负载均衡器: 是否负责策略有问题</li></ul></li><li><p>常见监控指标?</p><ol><li>服务器运行状态: cpu&#x2F;mem&#x2F;disk&#x2F;network</li><li>app状态: 运行状态&#x2F;响应时间&#x2F;错误率&#x2F;日志&#x2F;异常</li><li>服务性能: 网络延迟&#x2F;http响应时间&#x2F;db响应时间&#x2F;缓存命中</li><li>安全性: 入侵检测&#x2F;访问控制&#x2F;DDos攻击</li><li>日志系统</li><li>资源使用情况: 带宽&#x2F;虚拟机状态&#x2F;存储&#x2F;硬件状态</li></ol></li><li><p>说说你运维生涯遇到印象最深的一个问题.</p><blockquote><p>我曾经遇到过一个端口复用的问题,当时我们部署的是一个IM应用,现象是A用户本该发送给B用户的消息,结果发送给了C用户.后来查出的问题就是因为用户太多,连接数不够,出现了端口复用.</p><p>当时其实查得挺困难的,因为一开始没有这个概念,日志只是一条条地输出,很难看得出来.后面开了debug level日志,发现发错的信息所用的连接的本地ip和端口与正常发送的消息所用的ip和端口是一样的.</p><p>这才想到MSL的问题.因为我们的IM使用的是TCP长连接,当时的架构在前端有一个nginx作为负载,所以可以理解为所有连接都是同样的源ip和目标ip,当用户数一多,新用户不停登录,</p><p>默认的4次挥手的等待时间,也就是2*MSL不够用,其中一方数据没有传输完端口就被用到另一个用户,就导致了消息发送的错乱.当时给出的解决方案是加节点,但是加节点涉及资源申请,要走流程;当然也许可以手动</p><p>调大每个包的MSL,不过也会有风险,每个连接断开的等待时间变长,新用户登录建立新连接的时间可能也会拉长.最终与客户沟通,决定这个问题作为当前版本的一个bug处理,等下个版本发版顺便加节点.</p></blockquote></li><li><p>如何理解DEVOPS?</p><p>根据google SRE这本书所说,DEVOPS源自google,最开始google的运维也想我们传统运维一样,手动敲命令,手动重启,日常繁琐的工作很多,后面就有了脚本可以做一些简单的自动化.但是还不够,毕竟脚本还是面向过程的嘛,你很难说一个脚本覆盖多个场景.所以就引入了开发的能力,通过开发将运维的工作实现自动化,并适配多种场景.这最开始</p></li><li><p>做过的CI&#x2F;CD流程?</p><p>gcp项目</p><p>新旧方案示意图:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240506120957837.png" srcset="/img/loading.gif" lazyload alt="image-20240506120957837"></p><p>上面是旧方案,下面是新方案.旧方案的master分支基本是没用的,每次用release都要根据现有的dev分支复制一个release专用的分支出来,然后通过ansible拉取,model也是类似,每次做release,就把对应版本的model上传到gcs,然后ansible去拉取.为了区分版本,那就要加版本号啦,所以每次做release都要手动去改ansible代码指定拉取那个版本,就比较麻烦.</p><blockquote><p>新方案会根据dev(测试审批通过后)打一个tag,到做release的时候就通过python脚本将tag自动PR并merge到master分支(PR主要是为了审计),ansible那边就固定拉取master分支的代码即可.而github上tag的页面也可以清晰看到一个版本列表(用于版本追踪&#x2F;回滚).model也是类似,不过在我进去之前他们已经定好了先把model存在nexus,做release的时候通过jenkins把model上传到gcs,然后ansible拉取部署.nexus是别的团队管理的,我们没有删除文件的权限,时间久了会有模型文件堆积的问题,所以我们也有在讨论要不是把nexus换了,比如换到github,把model各个版本存在github之类的方案.</p></blockquote><blockquote><p>旧方案主要的问题是master分支浪费了,而且分支会很多,一个release一个分支,每次都要改ansible(包括回滚),容易会人为错误的风险(墨菲定律).新方案用上了master分支,通过tag list有清晰的版本列表,ansible固定拉取master分支,不需要每次都手工修改.</p></blockquote></li><li><p>github管理代码,版本分支如何规划?</p></li><li><p>我们devops主要是管理terraform&#x2F;ansible&#x2F;Jenkinsfile的代码,都是根据环境来划分分支</p></li><li><p>业务代码一般是根据版本,也有根据环境来划分</p></li></ol><p>一般主分支都是用于生产环境</p><blockquote><p>gcp的项目中,是按环境划分分支,最开始当需要release的时候,会根据dev分支单独创建一个release用的分支,部署的时候就部署这个分支.后面则是通过jenkins做的CICD,先是根据审批后的dev代码版本打一个tag,release的时候就把这个tag merge到主分支,生产环境就只使用主分支</p></blockquote><h1 id="架构概念"><a href="#架构概念" class="headerlink" title="架构概念"></a>架构概念</h1><ol><li><p>CAP理论</p><p>一个分布式计算系统不可能同时满足以下三个保证:</p><ul><li>一致性: 系统中所有数据副本,在同一时间内都是一致的.任何对数据的读取请求都将返回最新的写操作结果</li><li>可用性: 所有请求都会收到一个响应(但不保证返回的数据是最新的)</li><li>分区容忍性: 系统可以在任何网络分区(系统的一部分在网络中不可访问)发生时继续运行</li></ul><p>任何给定时刻,只能同时满足以上两个保证.</p><p>在现实世界设计中,分区容忍性是必须要有的(因为网络失败是难以避免的),所以设计的关键就在一致性和可用性之间做出权衡.</p></li><li><p>写时复制</p><p>copy on write:</p><ol><li>当系统需要复制一个资源(文件,对象或内存页)时,不会立即创建一个完全独立的副本,而是新旧副本共享相同的实际数据(降低内存占用)</li><li>当其中一个副本需要修改时,系统才会创建一个真正的副本(即写入数据之前先进行复制)</li><li>在新的副本修改后,其他副本仍然指向原始数据</li><li>修改不会影响原始数据或其他副本,保证数据的完整性和隔离性</li></ol></li></ol><h1 id="GIT-1"><a href="#GIT-1" class="headerlink" title="GIT"></a>GIT</h1><ol><li><p>团队维护同一份github repo,你们是工作流是怎么样的?</p><p>一般采用类似Feature Branch Workflow的流程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;repo_url&gt;<br>git checkout -b &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在分支上开发</span><br>git add .<br>git commit -m &quot;Commit message&quot;<br>git push -u origin &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会在repo上创建一个PR,团队成员对代码进行审查(code review),通过后merge到master分支</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后删除本地和远程的开发分支</span><br>git branch -d feature_branch_name  # 删除本地分支<br>git push origin --delete feature_branch_name  # 删除远程分支<br></code></pre></td></tr></table></figure><p>这是基本的工作流程,期间还可以加入其他步骤,例如代码静态分析(snoarQ),自动化测试,CI&#x2F;CD等</p></li><li><p>git常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">always pull before push</span><br>git pull<br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">display current status of git repository</span><br>git status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">display git commit <span class="hljs-built_in">history</span></span><br>git log<br>git log --oneline<br>git log --oneline --graph --decorate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">show the difference between 2 commits</span><br>git diff &lt;commitID1&gt; &lt;commitID2&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">撤销本地更改(未commit)</span><br>git reset --hard HEAD~<br></code></pre></td></tr></table></figure></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E9%9D%A2%E7%BB%8F/" class="category-chain-item">面经</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Interview/" class="print-no-link">#Interview</a></div></div><div class="license-box my-3"><div class="license-title"><div>面经</div><div>http://example.com/2024/06/20/interview-git/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年6月20日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/07/28/python-error-n-test/" title="python笔记-错误和测试"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">python笔记-错误和测试</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/03/20/AWS-SAP/" title="AWS-SAP-MustKnow"><span class="hidden-mobile">AWS-SAP-MustKnow</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>