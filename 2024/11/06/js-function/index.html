<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="函数基础定义1234567function abs(x) &#123;    if (x &gt;&#x3D; 0) &#123;        return x;    &#125; else &#123;        return -x;    &#125;&#125;   funciton: 定义函数的关键字 abs: 函数名 (x): 函数参数 &#123;...&#125;: 函数体  还有一种"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript-函数"><meta property="og:url" content="http://example.com/2024/11/06/js-function/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="函数基础定义1234567function abs(x) &#123;    if (x &gt;&#x3D; 0) &#123;        return x;    &#125; else &#123;        return -x;    &#125;&#125;   funciton: 定义函数的关键字 abs: 函数名 (x): 函数参数 &#123;...&#125;: 函数体  还有一种"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png"><meta property="article:published_time" content="2024-11-06T01:44:34.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.056Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="JavaScript"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>JavaScript-函数 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">JavaScript-函数</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-11-06 09:44" pubdate>2024年11月6日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 62 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">JavaScript-函数</h1><div class="markdown-body"><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>funciton</code>: 定义函数的关键字</li><li><code>abs</code>: 函数名</li><li><code>(x)</code>: 函数参数</li><li><code>&#123;...&#125;</code>: 函数体</li></ul><p>还有一种定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> abs = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;; <span class="hljs-comment">// 注意这种方式末尾需要加;</span><br></code></pre></td></tr></table></figure><ul><li><code>function (x) &#123;...&#125;</code>: 是一个匿名函数</li><li><code>abs</code>: 这个匿名函数赋值给了变量abs,所以通过<code>abs</code>就能调用该函数</li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">abs</span>(-<span class="hljs-number">9</span>); <span class="hljs-comment">// 返回9</span><br><span class="hljs-comment">// JS允许传入任意数量的参数,所以不论传多了还是传少了都不影响调用</span><br><span class="hljs-title function_">abs</span>(-<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-string">&#x27;hehe&#x27;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 返回9</span><br><span class="hljs-title function_">abs</span>(); <span class="hljs-comment">//返回NaN</span><br><span class="hljs-comment">// 此时abs的参数x将收到undefined,计算结果就是NaN</span><br></code></pre></td></tr></table></figure><p>为了避免收到undefined,可以对参数检查</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Not a number&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><code>arguments</code>是js的一个关键字,只能在函数内部起作用,永远指向当前函数的调用者传入的<code>所有参数</code>.类似<code>array</code>但并不是<code>array</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x = &#x27;</span> + x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arg &#x27;</span> + i + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-variable language_">arguments</span>[i]); <span class="hljs-comment">// 10, 20, 30</span><br>    &#125;<br>&#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>利用<code>arguments</code>就可以获取传入的所有参数,所以即使不定义参数,也能获取传入的参数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> ? x : -x; <span class="hljs-comment">// 三元运算符/条件运算符,很多语言都有类似的写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上<code>arguments</code>最常用于判断传入参数的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// foo(a[, b], c)</span><br><span class="hljs-comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 实际拿到的参数是a和b，c为undefined</span><br>        c = b; <span class="hljs-comment">// 把b赋给c</span><br>        b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// b变为默认值</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h2><p>假如你的函数只定义了2个参数,但我们<code>要使用除了前两个已定义参数外的所有参数</code>,此时是使用<code>arguments</code>就会显得很麻烦.ES6后引入了<code>...rest</code>关键字来获取不定参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b, ...rest</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a = &#x27;</span> + a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b = &#x27;</span> + b);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = 2</span><br><span class="hljs-comment">// Array [ 3, 4, 5 ]</span><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = undefined</span><br><span class="hljs-comment">// Array []</span><br></code></pre></td></tr></table></figure><ul><li><code>...rest</code>只能写在最后</li><li>如果传入的参数连已定义的参数都没有填满,rest会接收一个空数组(非undefined)</li></ul><h2 id="return不要分行"><a href="#return不要分行" class="headerlink" title="return不要分行"></a>return不要分行</h2><p>因为JS引擎会自动加<code>;</code>,如果return分行写的话容易变成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 引擎自动加上;</span><br>    	&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么返回值就会出错.正确的写法是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// &#123; 表示语句还没完结,不会自动加;</span><br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span> <br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><ul><li><p>如果一个变量在函数体内申明,该变量的作用域为整个函数体,函数体外不可引用该变量</p></li><li><p>不同函数内部的同名变量互相独立,互不影响</p></li><li><p>JS的函数可以嵌套,内部函数可以访问外部函数定义的变量,反之则不行</p></li><li><p>JS的函数在查找变量时从自身函数定义开始,如果内部函数定义了与外部函数重名的变量,则以内部变量的定义为准</p></li><li><p>JS会扫描整个函数体的语句,把所有申明的变量<code>提升</code>到函数顶部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;Hello, &#x27;</span> + y; <span class="hljs-comment">// 这里不会报错,因为JS会自动提升变量y的申明</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-comment">// 但是它只提升申明,不提升赋值,所以最终输出会是undefined</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出如下:</span><br><span class="hljs-comment">Hello, undefined.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><p>因此,我们在函数内部定义变量,必须严格遵守<code>在函数内部首先申明所有变量</code>这一原则.最常见的做法是用一个<code>var</code>申明所有用到的变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span><br>    	x = <span class="hljs-number">1</span>, <span class="hljs-comment">// x初始化为1</span><br>        y = x + <span class="hljs-number">1</span>, <span class="hljs-comment">// y初始化为2</span><br>        z, i; <span class="hljs-comment">// z,i初始化为undefined</span><br>    <span class="hljs-comment">//其他语句</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ES6后,建议使用<code>let</code>代替<code>var</code>.</p></blockquote><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>不在任何函数内定义的变量就具有<code>全局作用域</code>.JS默认有一个全局对象<code>window</code>,全局作用域的变量都会被绑定成<code>window</code>的一个<code>属性</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> course = <span class="hljs-string">&#x27;Learn JavaScript&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(course);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">course</span>);<br><span class="hljs-comment">// 因此上面两个访问方式等价</span><br></code></pre></td></tr></table></figure><p>同理,函数的另一种定义方式,把匿名函数赋值给变量,这个变量实际上也是一个全局变量.因此,顶层函数的定义也被视为一个全局变量,绑定到<code>window</code>的一个属性.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//两种调用同价</span><br></code></pre></td></tr></table></figure><p>其实不难想到,每次调用的<code>alert()</code>函数其实也是<code>window</code>的一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;调用window.alert()&#x27;</span>);<br><span class="hljs-comment">// 把alert保存到另一个变量:</span><br><span class="hljs-keyword">let</span> old_alert = <span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span>;<br><span class="hljs-comment">// 给alert赋一个新函数:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;无法用alert()显示了!&#x27;</span>);<br><br><span class="hljs-comment">// 恢复alert:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span> = old_alert;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;又可以用alert()了!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这说明JS<code>只有一个全局作用域</code>,任何变量(函数也被视为变量),如果在当前函数作用域没有找到,就会继续往上查找,最后如果在全局作用域中也没有,就会报<code>ReferenceError</code>.</p><h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><p>所有全局变量都会绑定到<code>window</code>上,不同的JS文件如果使用了相同的全局变量,或者定义了相同名字的顶层函数,就会造成冲突,而且难以发现.一个解决办法就是,把自己的所有变量和函数全部绑定到一个全局变量中.这个全局变量也被称为<code>名字空间</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 唯一全局变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">MYAPP</span> = &#123;&#125;;<br><br><span class="hljs-comment">// 其他变量</span><br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;myapp&#x27;</span>;<br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">version</span> = <span class="hljs-string">&#x27;1.0&#x27;</span>;<br><br><span class="hljs-comment">// 其他函数</span><br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很多著名的JS库都是这样做: JQuery, YUI, underscore等</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>JS的变量作用域实际上是函数内部,我们在<code>for</code>循环等语句块中无法定义具有局部作用域的变量.</p><p>因此,ES6引入了<code>let</code>关键字,可以用来申明一个块级作用域的变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>        sum += i; <span class="hljs-comment">// 块内的可以调用块外的</span><br>    &#125;<br>    i += <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为i是for快内的变量,使用let定义,所以块外无法调用,会报错SynTaxError</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>ES6前,通常用一个全大写的变量来表示”这是一个常量,不要修改它的值”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>ES6后,引入<code>const</code>来定义常量,与<code>let</code>一样都具有块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 某些浏览器不报错,但无效果</span><br><span class="hljs-variable constant_">PI</span>; <span class="hljs-comment">// 依旧是3.14</span><br></code></pre></td></tr></table></figure><h2 id="const-let-var"><a href="#const-let-var" class="headerlink" title="const, let, var"></a>const, let, var</h2><p>首先<code>const</code>用来定义常量,它不可变,具有块级作用域.</p><p>需要特别区分的是<code>let</code>和<code>var</code></p><table><thead><tr><th>区别点</th><th>let</th><th>var</th></tr></thead><tbody><tr><td>作用域</td><td>块级</td><td>函数</td></tr><tr><td>变量提升</td><td><strong>不会</strong>提升(先申明再使用)</td><td>提升申明</td></tr><tr><td>全局对象属性</td><td><strong>不会</strong>加到<code>window</code>的属性</td><td>会加到<code>window</code>的属性</td></tr><tr><td>重复声明</td><td><strong>不允许</strong>,会报错</td><td>允许,值可变</td></tr></tbody></table><p>总结:</p><p>现在JS开发中,推荐使用<code>let</code>和<code>const</code>来替代<code>var</code>.这样可以避免一些常见的作用域相关问题,使代码更可预测和更容易维护.</p><p>某些特殊情况需要用到<code>var</code>:</p><ol><li>老旧浏览器兼容性问题</li><li>特殊的跨作用域访问场景</li><li>特定的闭包使用场景</li></ol><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>一次过赋值多个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, y, z] = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;ES6&#x27;</span>];<br></code></pre></td></tr></table></figure><p>嵌套的话注意位置保持一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, [y, z]] = [<span class="hljs-string">&#x27;hello&#x27;</span>, [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;ES6&#x27;</span>]];<br>x; <span class="hljs-comment">// &#x27;hello&#x27;</span><br>y; <span class="hljs-comment">// &#x27;JavaScript&#x27;</span><br>z; <span class="hljs-comment">// &#x27;ES6&#x27;</span><br></code></pre></td></tr></table></figure><p>忽略元素赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [, , z] = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;ES6&#x27;</span>]; <span class="hljs-comment">// 忽略前两个元素，只对z赋值第三个元素</span><br>z; <span class="hljs-comment">// &#x27;ES6&#x27;</span><br></code></pre></td></tr></table></figure><p>从一个对象中提取多个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-attr">passport</span>: <span class="hljs-string">&#x27;G-12345678&#x27;</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;No.4 middle school&#x27;</span><br>&#125;;<br><span class="hljs-keyword">let</span> &#123;name, age, passport&#125; = person<br></code></pre></td></tr></table></figure><p>同样,对于嵌套的对象属性也可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-attr">passport</span>: <span class="hljs-string">&#x27;G-12345678&#x27;</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;No.4 middle school&#x27;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>        <span class="hljs-attr">street</span>: <span class="hljs-string">&#x27;No.1 Road&#x27;</span>,<br>        <span class="hljs-attr">zipcode</span>: <span class="hljs-string">&#x27;100001&#x27;</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;name, <span class="hljs-attr">address</span>: &#123;city, zip&#125;&#125; = person;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>解构赋值可以大大简化代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 交换两个变量的值,不需要临时变量</span><br><span class="hljs-keyword">let</span> x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>;<br>[x, y] = [y, x];<br><span class="hljs-comment">// 快速获取当前页面的域名和路径</span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">hostname</span>:domain, <span class="hljs-attr">pathname</span>:path&#125; = location; <span class="hljs-comment">// location是浏览器提供的全局对象之一</span><br><br><span class="hljs-comment">// 传一个对象给函数,通过解构,将对象属性直接赋值给参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printUserInfo</span>(<span class="hljs-params">&#123; name, age &#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> is <span class="hljs-subst">$&#123;age&#125;</span> years old`</span>);<br>&#125;<br><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span><br>&#125;;<br><span class="hljs-title function_">printUserInfo</span>(user); <span class="hljs-comment">// &quot;Tom is 20 years old&quot;</span><br></code></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在一个<code>对象</code>中绑定一个<code>函数</code>,该函数即为该对象的<code>方法</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span><br>    &#125;<br>&#125;<br><br>xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// 返回函数自身 f () &#123;...&#125;</span><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 今年调用是25,明年调用就变成26了</span><br></code></pre></td></tr></table></figure><p><code>this</code>类似python的<code>self</code>,是一个特殊变量,始终指向当前对象,也就是<code>xiaoming</code>.然而<code>this</code>有一些地方需要注意:</p><ul><li><p>只有通过<code>obj.function()</code>方式调用,<code>this</code>才能正确指向对象</p></li><li><p>其他调用会直接指向全局对象<code>window</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: getAge<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 25, 正常结果</span><br><span class="hljs-title function_">getAge</span>(); <span class="hljs-comment">// 直接调用,this指向window,自然没有birth这个属性,返回NaN</span><br><br><span class="hljs-comment">// 这样写也是不行的</span><br><span class="hljs-keyword">let</span> fn = xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// 先拿到xiaoming的age函数</span><br><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure></li><li><p><code>strict</code>模式下,错误的调用会让<code>this</code>指向<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> fn = xiaoming.<span class="hljs-property">age</span>;<br><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span><br></code></pre></td></tr></table></figure></li><li><p>内嵌函数内的调用也会指向全局对象,可以先用<code>that</code>关键字捕获</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 在方法内部一开始就捕获this</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAgeFromBirth</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>            <span class="hljs-keyword">return</span> y - that.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 用that而不是this</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAgeFromBirth</span>();<br>    &#125;<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>在独立函数调用中的<code>this</code>:</p><ul><li>使用<code>strict</code>,<code>this</code>指向<code>undefined</code></li><li>不用<code>strict</code>,<code>this</code>指向<code>window</code>的属性</li></ul><p>如果要控制<code>this</code>的指向,规定它指向哪个对象,可以使用函数本身的<code>apply</code>方法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: getAge<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 正常调用</span><br>getAge.<span class="hljs-title function_">apply</span>(xiaoming, []); <span class="hljs-comment">// 第一个参数是需要绑定的this对象,第二个参数array,表示需要传给函数的参数</span><br></code></pre></td></tr></table></figure><p>另一个与<code>apply()</code>类似的方法是<code>call()</code>,区别在于:</p><ul><li><code>apply()</code>把参数打包成<code>Array</code>再传入</li><li><code>call()</code>把参数按顺序传入</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><blockquote><p>对于普通函数的调用,我们通常把<code>this</code>绑定到<code>null</code>.</p><p><code>普通函数</code>是指不依赖任何对象上下文的函数,特别像<code>Math.max()</code>这样的工具函数.与之相对的就是<code>对象的方法</code>.</p><p><code>普通函数</code>根本不会使用<code>this</code>,传入null只是一种约定俗成的做法,表明我们不关心<code>this</code>的值.</p></blockquote><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldParseInt = <span class="hljs-built_in">parseInt</span>; <span class="hljs-comment">// parseInt是JS的一个全局函数,用于将字符串转换为整数,这里先把它保存起来</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">parseInt</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    count += <span class="hljs-number">1</span>; <span class="hljs-comment">// 添加计数器</span><br>	<span class="hljs-keyword">return</span> oldParseInt.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 调用原始函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实这里就相当于<code>重写parseInt</code>,添加计数器功能,然后通过<code>apply</code>,保留原函数的功能.这样每次调用该函数时都会自动计数.</p><p>这就是JS典型的<code>装饰器(Decorator)模式</code>.</p><p>这种模式一般用于:</p><ul><li>函数调用统计</li><li>性能监控</li><li>日志记录</li><li>调试</li></ul><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p><code>higher-order function</code>: 一个函数以另一个函数作为参数,就称为<code>高阶函数</code>.</p><blockquote><p>JS 的函数都指向某个变量,变量可以指向函数,函数的参数可以接收变量,所以函数可以作为另一个函数的参数.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单的高阶函数例子</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y, f</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(x) + <span class="hljs-title function_">f</span>(y);<br>&#125;<br><br><span class="hljs-title function_">add</span>(-<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">abs</span>)<br></code></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>比如我们有一个函数<code>f(x)=x*x</code>,要对一个数组上的所有元素都使用这个函数,此时就可以使用<code>map</code></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">            f(x) = x * x<br><br>                  │<br>                  │<br>  ┌───┬───┬───┬───┼───┬───┬───┬───┐<br>  │   │   │   │   │   │   │   │   │<br>  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼<br><br>[<span class="hljs-number"> 1 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span> <span class="hljs-number"> 6 </span> <span class="hljs-number"> 7 </span> <span class="hljs-number"> 8 </span> <span class="hljs-number"> 9 </span>]<br><br>  │   │   │   │   │   │   │   │   │<br>  │   │   │   │   │   │   │   │   │<br>  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼<br><br>[<span class="hljs-number"> 1 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 9 </span><span class="hljs-number"> 16 </span><span class="hljs-number"> 25 </span><span class="hljs-number"> 36 </span><span class="hljs-number"> 49 </span><span class="hljs-number"> 64 </span><span class="hljs-number"> 81 </span>]<br></code></pre></td></tr></table></figure><p>JS的<code>map()</code>定义在<code>Array</code>中,所以我们调用<code>Array</code>的<code>map()</code>,传入自己的函数,就得到一个新得<code>Array</code>返回.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br><span class="hljs-keyword">let</span> results = arr.<span class="hljs-title function_">map</span>(pow);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br></code></pre></td></tr></table></figure><p>当然,我们也可以写个循环实现上面的目的.但是<code>map()</code>作为高阶函数,事实上它把运算规则抽象了,所以我们可以根据传入的函数,实现各种复杂的操作,代码还能保持简单明了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如把Array所有数字转为字符串,只需一行代码</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-title class_">String</span>); <span class="hljs-comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce</code>同样也是作用在<code>array</code>的每个元素上,但是它是<code>累积</code>的.</p><p>比如通过<code>reduce</code>把函数<code>f(x)</code>作用在<code>[x1, x2, x3, x4]</code>上,其效果就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[x1, x2, x3, x4].<span class="hljs-title function_">reduce</span>(f) = <span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(x1, x2), x3), x4)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;); <span class="hljs-comment">//25</span><br></code></pre></td></tr></table></figure><p>如果数组元素只有一个,就要提供一个<code>额外的初始参数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">123</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;, <span class="hljs-number">0</span>); <span class="hljs-comment">// 额外的初始参数0</span><br></code></pre></td></tr></table></figure><p>把<code>[1, 3, 5, 7, 9]</code>变成一个整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y;<br>&#125;);<br></code></pre></td></tr></table></figure><p>不使用<code>parseInt()</code>,利用<code>map</code>和<code>reduce</code>,把<code>&#39;13579&#39;</code>转为<code>数字</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">string2int</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">//空字符串作为分隔符,逐一字符提取成array</span><br>    <span class="hljs-keyword">let</span> a = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-keyword">return</span> x - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// - &#x27;0&#x27;是JS的一个常用技巧,当&#x27;0&#x27;参与运算,JS会自动把它转为Number,包括最后结果的值也会是Number</span><br>        <span class="hljs-comment">// return + x; 这叫一元加号运算符,也是可以把字符串转为数字的一个技巧</span><br>    &#125;); <br>    <span class="hljs-keyword">let</span> result = a.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 13579</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code>用于把<code>array</code>的某些元素过滤掉,返回剩下的.</p><p><code>filter</code>把传入的<code>函数</code>依次作用到<code>array</code>每个元素,根据返回值<code>true/false</code>来决定保留还是丢弃.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例如踢出偶数</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>;<br>&#125;);<br>r; <span class="hljs-comment">// [1, 5, 9, 15]</span><br><br><span class="hljs-comment">// 删除空字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;   &#x27;</span>];<br><span class="hljs-keyword">let</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s &amp;&amp; s.<span class="hljs-title function_">trim</span>();<br>&#125;);<br>r; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><blockquote><p><code>callback function</code>是一个编程概念.作为参数传递给另一个函数的函数,则称为<code>回调函数</code>.当某个事件发生或特定条件满足时,这个被传递的函数就会被”调用回来”执行.</p></blockquote><p><code>filter</code>接收的回调函数其实可以由多个参数:</p><ol><li>第一个: 表示<code>array</code>的某个元素</li><li>第二个: 表示元素的位置</li><li>第三个: 数组本身</li></ol><p>类似的还有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a>和<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">let</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, self</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element); <span class="hljs-comment">// 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 依次打印0, 1, 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self); <span class="hljs-comment">// self就是变量arr</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>用<code>filter</code>去除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <br>	r,<br>    arr = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;strawberry&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;strawberry&#x27;</span>];<br><br>r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, self</span>) &#123;<br>    <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">indexOf</span>(element) === index; <span class="hljs-comment">// indexOf返回array中element的第一次出现的索引,如果当前索引index不等于indexOf返回的,说明该元素不是第一次出现,需要过滤掉</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><blockquote><p>排序的核心是比较两个元素的大小,但是如果元素是字符串,在数学上则无法比较.因此比较的过程必须抽象出来.通常规定:</p><ul><li><code>x&lt;y</code>返回<code>-1</code></li><li><code>x=y</code>返回0</li><li><code>x&gt;y</code>返回1</li></ul><p>排序算法不关心具体的比较过程,只根据结果排序.</p></blockquote><p>JS 的<code>array</code>有个<code>sort()</code>方法,然而有点坑爹.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 看上去正常的结果:</span><br>[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [&#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;];</span><br><br><span class="hljs-comment">// apple排在了最后:</span><br>[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [&#x27;Google&#x27;, &#x27;Microsoft&quot;, &#x27;apple&#x27;]</span><br><br><span class="hljs-comment">// 无法理解的结果:</span><br>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [1, 10, 2, 20]</span><br></code></pre></td></tr></table></figure><p>第二个排序<code>apple</code>排在最后,那时因为小写字母<code>a</code>的ASCII码在大写字母之后.</p><p>第三个则是因为,<code>sort()</code>默认把所有元素先转换成<code>String</code>再排序,结果<code>&#39;10&#39;</code>排在<code>&#39;2&#39;</code>前面,因为<code>&#39;1&#39;</code>的ASCII码比<code>&#39;2&#39;</code>小.</p><p>还好的是<code>sort()</code>是一个高阶函数,我们可以自己实现比较函数传进去比较.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 10, 20]</span><br></code></pre></td></tr></table></figure><p>如果要实现倒序排序,可以这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> y - x;<br>&#125;); <span class="hljs-comment">// [20, 10, 2, 1]</span><br></code></pre></td></tr></table></figure><blockquote><p><code>y-x</code>:</p><ul><li>如果<code>x&lt;y</code>,则返回正数</li><li>如果<code>x&gt;y</code>,则返回负数</li><li>如果<code>x=y</code>,则返回0</li></ul><p>天才</p></blockquote><p>默认情况下对字符串排序是通过比较ASCII码来实现,那如果想忽略大小写来排序呢?也不难,把元素全部转为大写&#x2F;小写再比较就行了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>) &#123;<br>    x1 = s1.<span class="hljs-title function_">toUpperCase</span>();<br>    x2 = s2.<span class="hljs-title function_">toUpperCase</span>();<br>    <span class="hljs-keyword">if</span> (x1 &lt; x2) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x1 &gt; x2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后从上面不难看出,<code>sort()</code>是会<code>直接修改原array</code>的.这个要注意一下.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">let</span> a2 = a1.<span class="hljs-title function_">sort</span>();<br>a1; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br>a2; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br>a1 === a2; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="array的其他高阶函数"><a href="#array的其他高阶函数" class="headerlink" title="array的其他高阶函数"></a>array的其他高阶函数</h2><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>用于判断数组的<code>所有元素</code>是否满足测试条件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;<br>&#125;)); <span class="hljs-comment">// true, 因为所有元素都满足s.length &gt; 0</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// false,因为不是每个元素都是小写</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于查找符合条件的<code>第一个</code>元素,找到就返回该元素,否则就返回<code>undefined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// &#x27;pear&#x27;, 因为pear全是小写</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toUpperCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// 返回undefined,因为没有全是大写的元素</span><br></code></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p>与<code>find</code>类似,也是找符合条件的<code>第一个</code>元素,但是它返回的是index,没有找到则返回<code>-1</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// 1, 因为&#x27;pear&#x27;的索引是1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toUpperCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>这个跟<code>map()</code>类似,也是把每个元素依次作用与传入的函数,但不会返回新数组.</p><p><code>forEach</code>常用于遍历数组,传入的函数不需要返回值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)); <span class="hljs-comment">// 依次打印每个元素</span><br></code></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p><code>高阶函数</code>除了可以接收函数作为参数,还可以<code>返回函数</code>.</p><p>比如我们要实现一个对<code>array</code>的求和函数,但是我们不需要立即求和,而是在后面的代码中根据需要再计算:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy_sum</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum; <span class="hljs-comment">// 返回函数</span><br>&#125;<br><br><span class="hljs-keyword">let</span> f = <span class="hljs-title function_">lazy_sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// 这里返回的就是一个函数</span><br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// 15</span><br><span class="hljs-keyword">let</span> f2 = <span class="hljs-title function_">lazy_sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br>f === f2; <span class="hljs-comment">// false; 每次返回都会是一个全新的函数</span><br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p><code>闭包</code>是JS的一个重要特性,指的是函数能够记住并访问它的词法作用域,即使当这个函数在其原始作用域之外执行时也能正常工作.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 私有变量</span><br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 返回一个函数填充的array</span><br>        <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;,<br>        <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面的例子说明,即使变量是定义在<code>函数内部</code>的,但是通过<code>return</code>返回的函数依旧可以<code>正常访问/修改</code>私有变量.因为返回函数形成了<code>闭包</code>.</p><p>但有一点要注意,<code>返回的函数</code>并<code>不会在返回时执行</code>,而是在<code>实际调用的才会执行</code>.</p><h3 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// var是函数作用域申明,所有推入数组得函数都会引用同一个i</span><br>        arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> i * i;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">count</span>();<br><span class="hljs-keyword">let</span> [f1, f2, f3] = result;<br><span class="hljs-comment">// 再加上闭包,函数在被调用时才会执行,所以当执行返回的函数时,i已经变成4</span><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>要避免这种陷阱,你可以:</p><ol><li><p>使用<code>let</code>代替<code>var</code>,<code>let</code>作用域决定了每次循环都会绑定新的<code>i</code>.(recommend)</p></li><li><p>创建<code>立即执行函数</code>,这是JS的一个语法,用于<code>创建一个匿名函数并立刻执行</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br>        arr.<span class="hljs-title function_">push</span>((<span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> n * n;<br>            &#125;<br>        &#125;)(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">let</span> [f1, f2, f3] = <span class="hljs-title function_">count</span>();<br><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><p>这里再创建了一个函数,用该函数的参数绑定循环变量的当前值,无论该循环后续如何更改,已绑定到函数参数的值不变.</p><p>可以看出,里面嵌套很复杂,最好还是不要用这种,这里更多是为了引出<code>创建一个匿名函数并立刻执行</code>的语法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 理论上讲,创建一个匿名函数并立刻执行可以这么写</span><br><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> x * x&#125; (<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 但是JS语法解析的问题,需要用括号把函数括起来,不然会报SyntaxError</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> x * x&#125;) (<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 通常会把它拆开写,好看点</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;) (<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p>不要在返回函数中引用循环变量.(recommend)</p></li></ol><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>JS的闭包除了返回一个函数,延迟执行外,还有一个最强大的功能,就是在<code>对象内部封装一个私有变量</code>.</p><p>想java和c++,可以用<code>private</code>,但JS没有<code>class</code>只有函数,需要借助闭包,封装私有变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create_counter</span>(<span class="hljs-params">initial</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = initial || <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果initial有值就使用initial,否则为0, 一种设置默认值的简写方式</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">inc</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            x += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//用起来是这样的</span><br><span class="hljs-keyword">let</span> c1 = <span class="hljs-title function_">create_counter</span>();<br>c1.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 1</span><br>c1.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 2</span><br>c1.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">let</span> c2 = <span class="hljs-title function_">create_counter</span>(<span class="hljs-number">10</span>);<br>c2.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 11</span><br>c2.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 12</span><br>c2.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>在返回的对象中,实现了一个闭包,闭包携带了局部变量<code>x</code>,并且这个<code>x</code>无法被访问.换句话说,闭包就是携带状态的函数,并且它的状态可以完全对外隐藏起来.</p><h3 id="创建新函数"><a href="#创建新函数" class="headerlink" title="创建新函数"></a>创建新函数</h3><p>举个例子: 闭包还可以把多参数的函数变成单参数的函数.比如要计算<code>x^y</code>可以用<code>Math.pow(x, y)</code>函数,不过考虑到经常计算x^2或x^3,可以利用闭包创建新的函数<code>pow2</code>或<code>pow3</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">make_pow</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x, n)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 创建两个新函数</span><br><span class="hljs-keyword">let</span> pow2 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> pow3 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow2</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow3</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 343</span><br></code></pre></td></tr></table></figure><p>这种做法也被称为<code>函数工厂</code>,这种函数也被称为<code>工厂函数</code>.</p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6新增一种新的函数: <code>箭头函数</code>,因为它的定义就是一个箭头<code>=&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; x * x<br><span class="hljs-comment">// 上面的箭头函数相当于</span><br><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数相当于<code>匿名函数</code>,并且简化了函数定义.它有两种定义格式:</p><ol><li><p>像上面的,只包含一个表达式,<code>&#123;...&#125;</code>和<code>return</code>都省略</p></li><li><p>包含多种语句的,不能省略<code>&#123;...&#125;</code>和<code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x * x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> - x * x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果参数不是只有一个,就要用<code>()</code>括起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 两个参数</span><br>(x, y) =&gt; x * x + y* y;<br><span class="hljs-comment">// 没有参数</span><br><span class="hljs-function">() =&gt;</span> <span class="hljs-number">3.14</span>;<br><span class="hljs-comment">// 可变参数</span><br><span class="hljs-function">(<span class="hljs-params">x, y, ...rest</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> i, sum = x + y;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;rest.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += resy[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果返回一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; &#123;<span class="hljs-attr">foo</span>: x&#125; <span class="hljs-comment">// 这样写是错误的SynctaxError,因为和函数体&#123;...&#125;有语法冲突</span><br>x =&gt; (&#123;<span class="hljs-attr">foo</span>: x&#125;) <span class="hljs-comment">// 加个括号就可以了</span><br></code></pre></td></tr></table></figure><h3 id="this修复"><a href="#this修复" class="headerlink" title="this修复"></a>this修复</h3><p><strong>箭头函数没有自己的 <code>this</code> 绑定</strong>。箭头函数会捕获其被定义时的上下文的 <code>this</code> 值，而且这个绑定是永久的，不能被改变。</p><blockquote><p><code>词法作用域</code>(Lexical scope):</p><p>是指变量的作用域在代码编写时(词法分析时)就已经确定,而不是在运行时确定.简单来说,就是变量的访问权限由变量定义的位置决定.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">bitrh</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>        <span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// this指向window或undefined</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">bitrh</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 使用了箭头函数,this指向外部域,也就是getAge函数的域</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来两个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例子一</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-attr">sayHiNormal</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;,<br>    <span class="hljs-comment">// 箭头函数没有自己的this,只能捕获定义时所在上下文的this值</span><br>    <span class="hljs-attr">sayHiArrow</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayHiNormal</span>(); <span class="hljs-comment">// Hi, 张三</span><br>obj.<span class="hljs-title function_">sayHiArrow</span>(); <span class="hljs-comment">// Hi, undefined (因为箭头函数的this指向外部作用域)</span><br><br><span class="hljs-comment">// 例子二</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;  <span class="hljs-comment">// 这里的 this 指向 obj</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <br>        <span class="hljs-comment">// 箭头函数在 getAge 函数内部定义</span><br>        <span class="hljs-comment">// 所以它继承了 getAge 的 this，即 obj</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个例子的箭头函数直接在<code>对象字面量</code>中定义,所以继承了<code>全局作用域的this</code></p><blockquote><p>对象字面量: 直接使用<code>&#123;&#125;</code>创建对象的语法</p></blockquote><p>第二个例子的箭头函数在普通函数<code>getAge</code>内定义,继承外部作用域,也就是<code>getAge</code>的<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 再来一个例子</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">year</span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 1990</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">y</span>) =&gt; y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 由于箭头函数的this是上下文决定的,所以这里的this和getAge函数保持一致,都是被调用时的对象.</span><br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">birth</span>:<span class="hljs-number">2000</span>&#125;, year); <span class="hljs-comment">// 此时用call去调用fn,第一个参数要传入一个调用对象,但是由于箭头函数的this不可改变,所以依旧是obj</span><br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">getAge</span>(<span class="hljs-number">2015</span>); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h1 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h1><p>对于<code>模板字符串</code>,除了方便引用变量构造字符串外,还有一个更强大的功能,就是使用<code>标签函数</code>(tag function)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模板字符串</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> s = <span class="hljs-string">`你好, <span class="hljs-subst">$&#123;name&#125;</span>, 你今年<span class="hljs-subst">$&#123;age&#125;</span>岁了!`</span>;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> email = <span class="hljs-string">&#x27;test@example.com&#x27;</span>;<br><span class="hljs-keyword">const</span> password = <span class="hljs-string">&#x27;hello123&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sql</span>(<span class="hljs-params">string, ...exps</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SQL: <span class="hljs-subst">$&#123;string.join(<span class="hljs-string">&#x27;?&#x27;</span>)&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SQL paramenters: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(exps)&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = sql<span class="hljs-string">`SELECT * FROM users WHERE email=<span class="hljs-subst">$&#123;email&#125;</span> AND password=<span class="hljs-subst">$&#123;password&#125;</span>`</span>; <span class="hljs-comment">// 标签函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result));<br></code></pre></td></tr></table></figure><p>模板字符串以特定标签函数名开头,就是标签函数的调用方式.</p><p>上面就是调用标签函数<code>sql()</code>.</p><p>标签函数接收两个参数:</p><ul><li><p>将模板字符串的<code>字符串部分,转换成数组</code>,赋值给第一个参数<code>string</code>,上面的例子就是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&quot;SELECT * FROM users WHERE email=&quot;</span>, <span class="hljs-string">&quot; AND password=&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>将模板字符串的<code>变量部分,转换成数组</code>,解析后传给不定参数<code>...exps</code>,也就是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&quot;test@example.com&quot;</span>, <span class="hljs-string">&quot;hello123&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>先在内部把<code>strings</code>转换成SQL字符串,然后把<code>...exps</code>作为参数,就可以实现一个安全的SQL查询.例如这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sql = strings.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;?&#x27;</span>);<br>    <span class="hljs-comment">// 执行数据库更新</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br><br><span class="hljs-comment">// 调用非常简洁</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">21</span>;<br><span class="hljs-keyword">let</span> score = <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>update<span class="hljs-string">`UPDATE users SET age=<span class="hljs-subst">$&#123;age&#125;</span>, score=<span class="hljs-subst">$&#123;score&#125;</span> WHERE id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>ES6引入的新数据类型,一个生成器看上去像一个函数,但可以<code>返回多次</code>.定义JS生成器标准的哥们借鉴了python生成器的概念和语法.</p><p>函数在执行过程中如果没有遇到<code>return</code>,控制权无法交回被调用的代码.(函数如果没有显式声明<code>return</code>,默认都会有一个<code>return undefined</code>).生成器与函数类似,定义如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>function*</code>,定义时比函数多一个<code>*</code></li><li>除了<code>return</code>,还可以用<code>yield</code>返回多次</li></ul><p>举个例子, 斐波那契数列:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">0 1 1 2 3 5 8 13 21 34 ...<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数方式生成,返回array</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">max</span>) &#123;<br>    <span class="hljs-keyword">let</span><br>    	t,<br>        a = <span class="hljs-number">0</span>,<br>        b = <span class="hljs-number">1</span>,<br>        arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-property">length</span> &lt; max) &#123;<br>        [a, b] = [b, a + b];<br>        arr.<span class="hljs-title function_">push</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-title function_">fib</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// [0, 1, 1, 2, 3]</span><br><span class="hljs-title function_">fib</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span><br></code></pre></td></tr></table></figure><p>那么跟python类似的,当数据量无限增大,这个函数在内存的占用也会无限增大,所以使用<code>生成器</code>是个更好的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 生成器</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fib</span>(<span class="hljs-params">max</span>) &#123;<br>    <span class="hljs-keyword">let</span><br>    	t,<br>        a = <span class="hljs-number">0</span>,<br>        b = <span class="hljs-number">1</span>,<br>        n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &lt; max) &#123;<br>        <span class="hljs-keyword">yield</span> a;<br>        [a, b] = [b, a + b];<br>        n ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用生成器一: 使用next()</span><br><span class="hljs-title function_">fib</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;</span><br>f = <span class="hljs-title function_">fib</span>(<span class="hljs-number">5</span>);<br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 0, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 3, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br><span class="hljs-comment">// 方法二: for...of,不需要自己判断done</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">fib</span>(<span class="hljs-number">10</span>)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 依次输出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>生成器可以看成一个<code>可以记住执行状态的函数</code>.</p><p>需要注意的是生成器执行到<code>yeild</code>就会结束,要让它保持生成多个元素,一般都需要加个<code>循环</code>包裹.</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/JavaScript/" class="print-no-link">#JavaScript</a></div></div><div class="license-box my-3"><div class="license-title"><div>JavaScript-函数</div><div>http://example.com/2024/11/06/js-function/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年11月6日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/11/js-standar-object/" title="JavaScript-标准对象"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">JavaScript-标准对象</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/11/04/js-begining/" title="JavaScript-入门"><span class="hidden-mobile">JavaScript-入门</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>