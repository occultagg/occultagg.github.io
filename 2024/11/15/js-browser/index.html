<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="浏览器对象windowwindow对象不但充当全局作用域,而且表示浏览器窗口 1console.log(&#x27;window inner size: &#x27; + window.innerWidth + &#x27; x &#x27; + window.innerHeight)   innerWidth&#x2F;innerHeight:浏览器窗口的内部宽度和高度 内部宽高是指,去掉菜单栏"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript-浏览器"><meta property="og:url" content="http://example.com/2024/11/15/js-browser/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="浏览器对象windowwindow对象不但充当全局作用域,而且表示浏览器窗口 1console.log(&#x27;window inner size: &#x27; + window.innerWidth + &#x27; x &#x27; + window.innerHeight)   innerWidth&#x2F;innerHeight:浏览器窗口的内部宽度和高度 内部宽高是指,去掉菜单栏"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png"><meta property="article:published_time" content="2024-11-15T02:28:29.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.055Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="JavaScript"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>JavaScript-浏览器 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">JavaScript-浏览器</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-11-15 10:28" pubdate>2024年11月15日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 78 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">JavaScript-浏览器</h1><div class="markdown-body"><h1 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h1><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p><code>window</code>对象不但充当全局作用域,而且表示<code>浏览器窗口</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;window inner size: &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> + <span class="hljs-string">&#x27; x &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>)<br></code></pre></td></tr></table></figure><ul><li><code>innerWidth</code>&#x2F;<code>innerHeight</code>:浏览器窗口的内部宽度和高度</li><li>内部宽高是指,去掉菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高.</li><li>对应的有<code>outerWidth</code>&#x2F;<code>outerHeight</code>,是浏览器整个窗口的宽高</li></ul><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p><code>navigator</code>对象表示浏览器信息,常用属性包括:</p><ul><li><code>navigator.appName</code>: 浏览器名称</li><li><code>navigator.appVersion</code>: 版本</li><li><code>navigator.language</code>: 语言</li><li><code>navigator.platform</code>: 操作系统类型</li><li><code>navigator.userAgent</code>: 浏览器设定的<code>User-Agent</code>字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;appName = &#x27;</span> + navigator.<span class="hljs-property">appName</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;appVersion = &#x27;</span> + navigator.<span class="hljs-property">appVersion</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;language = &#x27;</span> + navigator.<span class="hljs-property">language</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;platform = &#x27;</span> + navigator.<span class="hljs-property">platform</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;userAgent = &#x27;</span> + navigator.<span class="hljs-property">userAgent</span>);<br><br><span class="hljs-comment">// 输出</span><br>appName = <span class="hljs-title class_">Netscape</span><br>appVersion = <span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">130.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span><br>language = zh-<span class="hljs-variable constant_">CN</span><br>platform = <span class="hljs-title class_">Win32</span><br>userAgent = <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">130.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>:<code>navigator</code>的值很容易被用户修改,所以JS读取出来的值不一定正确.另外很多初学者喜欢针对不同的浏览器写不同的代码,喜欢用<code>if</code>判断浏览器版本:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> width;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIEVersion</span>(navigator.<span class="hljs-property">userAgent</span>) &lt; <span class="hljs-number">9</span>) &#123;<br>    width =  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做既不能保证数据准确,也难以维护.<code>正确</code>的做法是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用JS对不存在属性返回undefined的特性,使用短路运算符||</span><br><span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span><br></code></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>表示屏幕的信息</p><ul><li><code>screen.width</code></li><li><code>screen.height</code></li><li><code>screen.colorDepth</code>: 颜色位数,比如8,16,24</li></ul><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>表示当前页面的URL信息,获取URL的个个部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例如一个完整的URL</span><br><span class="hljs-comment">// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span><br>location.<span class="hljs-property">href</span>; <span class="hljs-comment">// 获取整个URL</span><br>location.<span class="hljs-property">protocol</span>; <span class="hljs-comment">// &#x27;http&#x27;</span><br>location.<span class="hljs-property">host</span>; <span class="hljs-comment">// &#x27;www.example.com&#x27;</span><br>location.<span class="hljs-property">port</span>; <span class="hljs-comment">// &#x27;8080&#x27;</span><br>location.<span class="hljs-property">pathname</span>; <span class="hljs-comment">// &#x27;/path/index.html&#x27;</span><br>location.<span class="hljs-property">search</span>; <span class="hljs-comment">// &#x27;?a=1&amp;b=2&#x27;</span><br>location.<span class="hljs-property">hash</span>; <span class="hljs-comment">// &#x27;TOP&#x27;</span><br></code></pre></td></tr></table></figure><p>还有两个常用方法</p><p><code>location.reload()</code>: 重新加载当前页面</p><p><code>localtion.assign()</code>:加载一个新页面(当前页跳转)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;重新加载当前页&#x27;</span> + location.<span class="hljs-property">href</span> + <span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>    location.<span class="hljs-title function_">reload</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    location.<span class="hljs-title function_">assign</span>(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 设置一个新的URL地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>这个对象表示当前页面.</p><p>由于HTML在浏览器中以<code>DOM</code>形式表示为树状结构,<code>document</code>对象就是整个DOM树的<code>根节点</code>.</p><blockquote><p><code>DOM</code>(document object model 文档对象模型)</p><p>DOM是一个编程接口,它将HTML或XML文档表示为一个树形结构,其中每个节点代表文档的一部分.</p><p>这样可以让开发者通过编程方式来访问和修改文档的内容,结构和样式.</p><p>比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在DOM中就会表示为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">document<br>  └── html<br>      ├── head<br>      │   └── title<br>      │       └── &quot;我的页面&quot;<br>      └── body<br>          ├── h1<br>          │   └── &quot;欢迎&quot;<br>          └── p<br>              └── &quot;这是一个段落&quot;<br></code></pre></td></tr></table></figure></blockquote><p>比如<code>document</code>的<code>title</code>属性是从HTML的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的,但是可以动态改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;好好学习,天天向上!&#x27;</span>;<br></code></pre></td></tr></table></figure><p>要查找DOM树的某个节点,需要从<code>document</code>对象开始查找,最常用的查找的是根据<code>ID</code>和<code>Tag Name</code>.比如有如下html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drink-menu&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>摩卡<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>热摩卡咖啡<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>酸奶<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京老酸奶<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>果汁<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>鲜榨苹果汁<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> menu = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drink-menu&#x27;</span>);<br><span class="hljs-keyword">let</span> drinks = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;dt&#x27;</span>);<br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;提供的饮料有:&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;drinks.<span class="hljs-property">length</span>; i++) &#123;<br>    s = s + drinks[i].<span class="hljs-property">innerHTML</span> + <span class="hljs-string">&#x27;,&#x27;</span>; <span class="hljs-comment">// innerHTML是一个DOM属性,用于获取/设置DOM对象的HTML内容,类似的还有innerText,只获取文本内容</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br></code></pre></td></tr></table></figure><p><code>document.cookie</code>该属性可以获取当前页面的<code>cookie</code>.cookie是由服务器发送的K-V标识符.因为HTTP是无状态的,但是服务器要区分是哪个用户发过来的请求,就可以用cookie.当一个用户成功登录后,服务器发送一个cookie给浏览器,例如<code>user=asfdf(加密的字符串)</code>,此后浏览器访问该网站时就会在请求头附上这个cookie,服务器根据cookie区别用户.另外cookie还可用于存储网站一些设置,比如语言等.</p><blockquote><p><code>cookie</code> 和 <code>session</code></p><table><thead><tr><th></th><th>cookie</th><th>session</th></tr></thead><tbody><tr><td>存储位置</td><td>存储在客户端(浏览器)</td><td>存储在服务端</td></tr><tr><td>安全性</td><td>容易被窃取和篡改</td><td>比较安全,因为数据在服务器上</td></tr><tr><td>存储容量</td><td>通常限制4kb</td><td>取决于服务端配置,一般可以存储更多数据</td></tr><tr><td>生命周期</td><td>客户端可以设置过期时间</td><td>以下情况会过期:<br>- 用户关闭浏览器<br>- 服务器端设置的过期时间到达<br>- 用户主动退出登录</td></tr></tbody></table><p>一般</p><ul><li>敏感数据用Session</li><li>用户偏好设置用Cookie</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>; <span class="hljs-comment">// &#x27;v=123; remember=true; prefer=zh&#x27;</span><br></code></pre></td></tr></table></figure><p>由于JavaScript可以获取到cookie,而用户的登录信息通常也会存在cookie,这会产生安全隐患.因为HTML页面可以引入第三方JS,也就是第三方可以通过JS获取用户的cookie.为了避免这种情况,服务器端应该将cookie设置为<code>httpOnly</code>.这样JS便不能获取cookie.</p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>这个对象保存了浏览器的<code>历史记录</code>,通过它的<code>back()</code>和<code>fowward()</code>方法,相当于用户点击”后退”或”前进”.</p><p>新手喜欢在登录页登录成功后调用<code>history.back()</code>返回登录前页面,这是一个<code>错误</code>的做法.</p><p>对使用AJAX动态加载的页面,如果希望页面更新时同时更新<code>history</code>对象,应当使用<code>history.pushState()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// when AJAX is done:</span><br><span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;any-data&#x27;</span>;<br><span class="hljs-keyword">let</span> newUrl = <span class="hljs-string">&#x27;/ajax.html#singin&#x27;</span>;<br>history.<span class="hljs-title function_">pushState</span>(state, <span class="hljs-string">&#x27;&#x27;</span>, newUrl);<br></code></pre></td></tr></table></figure><h1 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h1><ul><li>更新: 更新DOM节点的内容,相当于更新了DOM节点所表示HTML的内容</li><li>遍历: 遍历该DOM节点下的子节点,以便进一步操作</li><li>添加: 在该DOM节点下新增一个子节点,相当于动态增加了一个HTML节点</li><li>删除: 将该节点从HTML删除,包括它的子节点也一并删除</li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol><li><code>document.getElementById()</code>: 由于ID在HTML文档中是<code>唯一</code>的,所以此方法可以定位唯一的DOM节点</li><li><code>document.getElementByTagName()</code>&#x2F;<code>document.getElementByClassName()</code>总是返回<code>一组</code>DOM节点,可以先定位父节点,再慢慢定位</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 返回ID为&#x27;test&#x27;的节点：</span><br><span class="hljs-keyword">let</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br><br><span class="hljs-comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span><br><span class="hljs-keyword">let</span> trs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-table&#x27;</span>).<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;tr&#x27;</span>);<br><br><span class="hljs-comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span><br><span class="hljs-keyword">let</span> reds = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-div&#x27;</span>).<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br><br><span class="hljs-comment">// 获取节点test下的所有直属子节点:</span><br><span class="hljs-keyword">let</span> cs = test.<span class="hljs-property">children</span>;<br><br><span class="hljs-comment">// 获取节点test下第一个、最后一个子节点：</span><br><span class="hljs-keyword">let</span> first = test.<span class="hljs-property">firstElementChild</span>;<br><span class="hljs-keyword">let</span> last = test.<span class="hljs-property">lastElementChild</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>querySelector()</code>&#x2F;<code>querySelectorAll()</code>: 需要了解selector语法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过querySelector获取ID为q1的节点：</span><br><span class="hljs-keyword">let</span> q1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#q1&#x27;</span>);<br><br><span class="hljs-comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span><br><span class="hljs-keyword">let</span> ps = q1.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div.highlighted &gt; p&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>实际上DOM的节点有多种类型:</p><ul><li>Element: 最常见的节点类型,代表html的各种标签</li><li>Comment: 就是注释</li><li>CDATA_SECTION: 主要用于XML,用于存储包含特殊字符的文本无需转义</li><li>Document: 就是整个HTML文档,也是DOM树的根节点</li></ul><p>DOM节点称为<code>Node</code>,而我们上面操作的都是<code>Element</code>类型的<code>Node</code></p></blockquote><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>修改DOM节点一般使用:</p><ul><li><code>innerHtml</code>: 可以设置HTML标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-comment">// 设置文本为abc:</span><br>p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;ABC&#x27;</span>; <span class="hljs-comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span><br><span class="hljs-comment">// 设置HTML:</span><br>p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;<br><span class="hljs-comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span><br></code></pre></td></tr></table></figure><ul><li><code>innerText</code>&#x2F;<code>textContent</code>: 会对字符串自动编码,从而无法设置任何HTML标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-comment">// 设置文本:</span><br>p.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;<br><span class="hljs-comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span><br><span class="hljs-comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><p>两者区别在于读取属性时,<code>innerText</code>不返回隐藏元素的文本,而<code>textContent</code>返回所有文本.</p><ul><li><code>style</code>: 对应所有CSS,可以通过这个属性获取或设置CSS</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-comment">// 设置CSS:</span><br>p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;#ff0000&#x27;</span>;<br>p.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span>; <span class="hljs-comment">// CSS中的命名是font-size,JS不允许这样的命名,所以改为驼峰命名法</span><br>p.<span class="hljs-property">style</span>.<span class="hljs-property">paddingTop</span> = <span class="hljs-string">&#x27;2em&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>如果获取到的DOM节点是空的,比如<code>&lt;div&gt;&lt;/div&gt;</code>,直接使用<code>innerHtml = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>,就相当于插入了一个新的DOM节点.</p><p>但如果节点本身不为空,有两个办法插入:</p><ol><li><p><code>appendChild</code>,把一个节点添加到父节点的最后一个子节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 有这么一段html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <br>	js = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;js&#x27;</span>),<br>    list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>)<br>list.<span class="hljs-title function_">appendChild</span>(js);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML 会变成这样 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果要插入的节点<code>已经存在</code>当前的文档中,这个节点会从原来的位置<code>删除</code>,再插入.(<code>id唯一</code>)</p><p>从零创建再插入:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>	list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>),<br>	haskell = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">// 创建element类型的dom</span><br>haskell.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;haskell&#x27;</span>;  <span class="hljs-comment">// 给dom添加id</span><br>haskell.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;Haskell&#x27;</span>; <span class="hljs-comment">// 给dom添加文本</span><br>list.<span class="hljs-title function_">appendChild</span>(haskell); <span class="hljs-comment">// 插入</span><br></code></pre></td></tr></table></figure><p>动态添加DOM节点可以实现很多功能,比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> d = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;style&#x27;</span>);<br>d.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/css&#x27;</span>);<br>d.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;p &#123; color: red &#125;&#x27;</span>; <span class="hljs-comment">// 构建一个新的CSS元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTag</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(d) <span class="hljs-comment">// 插入</span><br></code></pre></td></tr></table></figure><p>上面动态创建了一个<code>&lt;style&gt;</code>节点,然后把它添加到<code>&lt;head&gt;</code>节点末尾,动态给document添加了新的CSS.</p></li><li><p><code>inserBefore</code>: 把子节点插入到指定位置,<code>parentElemnet.insertBefore(newElement, referenceElement)</code>,新的子节点会插入到<code>referenceElement</code>之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>	list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>),<br>    ref = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;python&#x27;</span>),<br>    haskell = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>haskell.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;haskell&#x27;</span>;<br>haskell.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;Haskell&#x27;</span>;<br>list.<span class="hljs-title function_">insertBefore</span>(haskell, ref);<br></code></pre></td></tr></table></figure><p>所以使用<code>inserBefore</code>的关键在于拿到准确的参考节点,很多时候需要循环一个父节点的所有子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>	i, c,<br>    list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;list.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    c = list.<span class="hljs-property">children</span>[i]; <span class="hljs-comment">// 拿到第i个子节点</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个例子</p><p>有如下的html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Ruby<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Haskell<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要把它们按字符串重新排序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-list&#x27;</span>);<br><span class="hljs-keyword">let</span> lis = list.<span class="hljs-property">children</span>;<br><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e=<span class="hljs-number">0</span>; e&lt;lis.<span class="hljs-property">length</span>; e++) &#123;<br>    arr.<span class="hljs-title function_">push</span>(lis[e].<span class="hljs-property">innerText</span>);<br>    m.<span class="hljs-title function_">set</span>(lis[e].<span class="hljs-property">innerText</span>, lis[e]);<br>&#125;<br>arr.<span class="hljs-title function_">sort</span>()<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> arr) &#123;<br>    list.<span class="hljs-title function_">appendChild</span>(m.<span class="hljs-title function_">get</span>(a)); <span class="hljs-comment">// 如果该element已存在,则删除原有的再插入</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>首先获取该<code>节点本身</code>以及它的<code>父节点</code>,然后调用父节点的<code>removeChild</code>把自己删掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 拿到待删除节点</span><br><span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;to-be-removed&#x27;</span>);<br><span class="hljs-comment">// 拿到它的父节点</span><br><span class="hljs-keyword">let</span> parent = self.<span class="hljs-property">parentElement</span>;<br><span class="hljs-comment">// 删除自身</span><br><span class="hljs-keyword">let</span> removed = parent.<span class="hljs-title function_">removeChild</span>(self);<br>removed === self; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong><code>chidlren</code>是一个<code>只读属性</code>,并且在它子节点变化时会<code>实时更新</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 例如有这样的html结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;parent&#x27;</span>);<br>parent.<span class="hljs-title function_">removeChild</span>(parent.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]);<br>parent.<span class="hljs-title function_">removeChild</span>(parent.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>第二次remove报错是因为第一次remove后,<code>children</code>实时变化,索引[1]已经不存在</p><h1 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h1><p>表单本身也是DOM树.</p><p>表单的输入框,下拉框可以接收用户输入,所以JS可以获得用户输入的内容,或者对一个输入框设置新的内容.</p><p>HTML表单的输入控件主要有以下几种:</p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>对于<code>text</code>,<code>input</code>,<code>password</code>,<code>hidden</code>以及<code>select</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span><br><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;email&#x27;</span>);<br>input.<span class="hljs-property">value</span>; <span class="hljs-comment">// &#x27;用户输入的值&#x27;</span><br></code></pre></td></tr></table></figure><p>但对于单选和复选,<code>value</code>返回的是HTML的预设值,也就是所有可选择项.要用<code>checked</code>判断是否用户已选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;</span><br><span class="hljs-comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;</span><br><span class="hljs-keyword">let</span> mon = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;monday&#x27;</span>);<br><span class="hljs-keyword">let</span> tue = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;tuesday&#x27;</span>);<br>mon.<span class="hljs-property">value</span>; <span class="hljs-comment">// &#x27;1&#x27;</span><br>tue.<span class="hljs-property">value</span>; <span class="hljs-comment">// &#x27;2&#x27;</span><br>mon.<span class="hljs-property">checked</span>; <span class="hljs-comment">// true或者false</span><br>tue.<span class="hljs-property">checked</span>; <span class="hljs-comment">// true或者false</span><br></code></pre></td></tr></table></figure><h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p><code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以</p><p>单选或复选就把<code>checked</code>设置为<code>true</code>或<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span><br><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;email&#x27;</span>);<br>input.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;test@example.com&#x27;</span>; <span class="hljs-comment">// 文本框的内容已更新</span><br></code></pre></td></tr></table></figure><h2 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h2><p>HTML5新增大量标准控件,常用的如<code>date</code>,<code>datetime</code>,<code>datetime-local</code>,<code>color</code>等,它们都是用<code>&lt;input&gt;</code>标签</p><p>不支持HTML5的浏览器无法识别新的控件,会把他们当作<code>type=&#39;text&#39;</code>来显示.支持的将获得<code>格式化的字符串</code>.例如,<code>type=&#39;date&#39;</code>类型的<code>input</code>的<code>value</code>将保证一个有效的<code>YYYY-MM-DD</code>格式的日期,或者空字符串.</p><h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><p>JS可以以两种方式处理表单的提交.</p><ol><li><p>通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单,例如响应一个<code>&lt;button&gt;</code>的<code>click</code>事件,在js代码中提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt; form id=&quot;test-form&quot;&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;doSumbmitForm()&quot;</span>&gt;</span><br>        Submit<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSubmitForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 这里可以修改form的input</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 提交form</span></span><br><span class="language-javascript">    form.<span class="hljs-title function_">submit</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式的缺点是扰乱了浏览器对form的正常提交.正常来说浏览器默认点击<code>&lt;button type=&#39;submit&#39;&gt;</code>时提交表单,或者用户在最后一个输入框按回车键.因此就有了第二种方法</p></li><li><p>响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-form&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 可以在此修改form的input...</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回true来告诉浏览器继续提交,如果返回false,浏览器将不会继续提交,可用于检查用户输入出错的场景</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p><code>&lt;input type=&quot;hidden&quot;&gt;</code>的妙用:</p><p>很多时候用户输入用户名和口令时,出于安全考虑不会传递明文,会把它转为MD5再传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 把用户输入的明文变为MD5:</span></span><br><span class="language-javascript">    pwd.<span class="hljs-property">value</span> = <span class="hljs-title function_">toMD5</span>(pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个做法本身没什么问题,但是当用户输入了密码提交时,密码框会突然从几个<code>*</code>变成32个<code>*</code>(MD5有32个字符)</p><p>如果不想有这个效果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input-password&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用于给用户输入的password 没有name属性, 没有name属性的input不会被提交--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;md5-password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> input_pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input-password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> md5_pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;md5-password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 把用户输入的明文变为MD5:</span></span><br><span class="language-javascript">    md5_pwd.<span class="hljs-property">value</span> = <span class="hljs-title function_">toMD5</span>(input_pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>HTML表单中,可以上传文件的唯一控件就是<code>&lt;input type=&#39;file&#39;&gt;</code></p><p>**注意:**当一个表单包含<code>&lt;input type=&#39;file&#39;&gt;</code>时:</p><ul><li><code>enctype</code>必须为<code>multipart/form-data</code></li><li><code>method</code>必须为<code>post</code></li><li>这样浏览器才能正确编码以<code>multipart/form-data</code>格式发送表单数据</li></ul><p>出于安全考虑,浏览器只允许用户点击<code>&lt;input type=&#39;file&#39;&gt;</code>来选择本地文件,用JS给<code>&lt;input type=&#39;file&#39;&gt;</code>de <code>value</code>赋值是没有任何效果的.当用户上传了某个文件后,JS也无法获得文件的真实路径.</p><p>通常上传的文件都是由后台服务器处理.JS可以在提交表单时对文件扩展名做检查,凡是用户上传无效的格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> f = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-file-upload&#x27;</span>);<br><span class="hljs-keyword">let</span> filename = f.<span class="hljs-property">value</span>;<br><span class="hljs-keyword">if</span> (!filename || !(filename.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.jpg&#x27;</span>) || filename.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.pbg&#x27;</span>) || filename.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.gif&#x27;</span>))) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Can only upload image file.&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>由于JS对用户上传的文件操作非常优先,尤其无法读取文件内容,使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现.</p><p>随着HTML5的普及,新增的File API允许JS读取文件内容,获得更多信息.</p><p>HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象,可以获得文件信息并读取文件.</p><p>下面的例子演示如何读取用户上传的图片并在一个div中显示.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>    fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-file&#x27;</span>),<br>    info = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-file-info&#x27;</span>),<br>    preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-preview&#x27;</span>);<br><span class="hljs-comment">// 监听change事件:</span><br>fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 清除背景图片:</span><br>    preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-comment">// 检查文件是否选择:</span><br>    <span class="hljs-keyword">if</span> (!fileInput.<span class="hljs-property">value</span>) &#123;<br>        info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;没有选择文件&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取File引用:</span><br>    <span class="hljs-keyword">let</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取File信息:</span><br>    info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;文件: &#x27;</span> + file.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;大小: &#x27;</span> + file.<span class="hljs-property">size</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;修改: &#x27;</span> + file.<span class="hljs-property">lastModified</span>;<br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/png&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/gif&#x27;</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;不是有效的图片文件!&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取文件:</span><br>    <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(); <span class="hljs-comment">// 通过FileReader对象读取文件内容</span><br>    reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-keyword">let</span><br>            data = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span><br>        preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&#x27;</span> + data + <span class="hljs-string">&#x27;)&#x27;</span>; <span class="hljs-comment">// 把读取的图片内容放入预览框</span><br>    &#125;;<br>    <span class="hljs-comment">// 以DataURL的形式读取文件:</span><br>    reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以<code>DataURL</code>形式读取到的文件是一个字符串,类似<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>,常用于设置图像.如果需要服务端处理,把字符串<code>base64,</code>后面的字符发送给服务端,并用base64解码就可以得到原始文件的二进制内容.</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>上面的代码还演示了JS的一个重要特性就是<code>单线程执行模式</code>.</p><p>浏览器的JS执行引擎在执行JS代码时,总是单线程模式执行.任何时候JS都不可能同时有多于一个线程执行.</p><p>JS中的多任务是通过<code>异步</code>来实现的,比如上面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br></code></pre></td></tr></table></figure><p>就会发起一个异步操作来读取文件内容.因为是<code>异步操作</code>,所以我们在JS中就不知道什么时候操作结束,因此需要先设置一个回调函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// reader.onload表示文件读取完成的事件</span><br>reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 当文件读取完成,自动调用此函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX是一个缩写: Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求.</p><blockquote><p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：<code>一次HTTP请求对应一个页面</code>。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p><p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过<code>回调函数</code>获得响应。</p></blockquote><p>现在浏览器写AJAX主要依靠<code>XMLHttpRequest</code>对象,另外还提供了原生支持的Fetch API以<code>Promise</code>(下面会说到)方式提供.使用Fetch API发送HTTP请求代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">text</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 发送异步请求</span><br><span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;./content.html&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fetch-response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = data;<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用Fetch API 配合async写法,代码更简单.</p><p>Fetch API详细用法可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">MDN文档</a></p><h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><p>上面的代码使用<code>./content.html</code>相对路径.如果你把它改为<code>https://baidu.com</code>,在运行就会报错.在chrome的浏览器控制台还可以看到错误信息.</p><p>这就是浏览器的<code>同源策略</code>:</p><p>默认情况下,JS发送AJAX请求时,URL域名必须和<code>当前页面</code>完全一致.</p><blockquote><p>完全一致的意思是:</p><ul><li>域名:<code>www.example.com</code>和<code>example.com</code>是两个域名</li><li>协议: <code>http</code>和<code>https</code>是不同协议</li><li>端口号也要相同</li></ul></blockquote><p>那如果想通过JS去请求<code>外域</code>可以怎么做呢?</p><ol><li><p>通过Flash插件发送HTTP请求,这种方式可以绕过安全限制,但是Flash已经淘汰了.</p></li><li><p>通过同源域名下假设代理服务器转发,JS把请求发送到代理服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;/proxy?url=https://www.sina.com.cn&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>称为<code>JSONP</code>,有个限制,只能用<code>GET</code>请求,且要求返回JS.因为浏览器允许跨域引用JS资源.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://example.com/abc.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JSNOP通常以函数形式返回,例如但会一个foo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;data&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这样一来,我们如果在页面先准备好<code>foo()</code>函数,然后给页面动态加一个<code>&lt;script&gt;</code>节点,相当于动态读取外域JS资源,然后就等着接收回调.</p></li></ol><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>支持HTML5的现代浏览器有新的跨域策略可以使用: <code>CORS</code></p><p>全称<code>Cross-Origin Resource Sharing</code>，是HTML5规范定义的如何跨域访问资源</p><blockquote><p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lasso">         GET /res/abc.<span class="hljs-built_in">data</span><br>         Host: sina.com<br>┌──────┐ Origin: http:<span class="hljs-comment">//my.com                      ┌────────┐</span><br>│my.com│───────────────────────────────────────────▶│sina.com│<br>│      │◀───────────────────────────────────────────│        │<br>└──────┘ HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK                            └────────┘<br>         Access<span class="hljs-params">-Control</span><span class="hljs-params">-Allow</span><span class="hljs-params">-Origin</span>: http:<span class="hljs-comment">//my.com</span><br>         Content<span class="hljs-params">-Type</span>: text/<span class="hljs-built_in">xml</span><br><br>         &lt;<span class="hljs-built_in">xml</span> <span class="hljs-built_in">data</span><span class="hljs-params">...</span>&gt;<br></code></pre></td></tr></table></figure><p>只要返回的响应头里的<code>Access-Control-Allow-Origin</code>包含本域<code>http://my.com</code>或者<code>*</code>,本次请求就能成功.</p><p>也就是说决定权在对方手上,就看它愿不愿意返回一个正确的<code>Access-Control-Allow-Origin</code>.</p><p>目前新的浏览器都支持CORS,也就是除了JS和CSS外,所有外域资源都要验证CORS.比如你引用某个第三方CDN字体文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;FontAwesome&#x27;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这些跨域请求,称为<code>简单请求</code>,包括:</p><ul><li>GET</li><li>HEAD</li><li>POST: content-type类型限制为<ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li><li>并且不能出现任何<code>自定义头</code></li></ul></li></ul><p>而对于<code>PUT</code>和其他类型如<code>application/json</code>的<code>POST</code>请求,在发送AJAX之前,浏览器会先发送一个<code>OPTIONS</code>请求(称为<code>preflighted请求</code>)到这个URL上,询问目标服务器是否接收</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">OPTIONS /path/to/resource HTTP/1.1<br>Host: bar.com<br>Origin: http://my.com<br>Access-Control-Request-Method: POST<br></code></pre></td></tr></table></figure><p>服务器必须响应并明确指出明确的允许的Methods</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">HTTP/1.1 200 OK<br>Access-Control-Allow-Origin: http://my.com<br>Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS<br>Access-Control-Max-Age: 86400<br></code></pre></td></tr></table></figure><p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p><p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理<code>POST</code>和<code>PUT</code>请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p><p>关于CROS更多可详阅<a target="_blank" rel="noopener" href="https://developer.mozilla.org/docs/Web/HTTP/CORS">MDN文档</a>和<a target="_blank" rel="noopener" href="https://fetch.spec.whatwg.org/">W3C文档</a></p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>JS中,所有代码都是但线程执行,着导致JS的所有网络操作,浏览器事件,都必须是异步执行.异步执行可以用<code>回调函数</code>实现.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Done&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;before setTimeout()&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(callback, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 1秒后调用callback函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;after setTimeout()&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>setTimeout()</code>做了两件事:</p><ul><li>注册了一个定时器</li><li>告诉JS引擎在1000毫秒后把callback函数放入任务队列</li></ul><p>这也称为<code>定时器回调</code>,类似的还有<code>事件回调</code>比如上面的读文件和提交表单</p></blockquote><p>浏览器console输入如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">before setTimeout()<br>after setTimeout()<br>(等待1秒后)<br>Done<br></code></pre></td></tr></table></figure><p>AJAX异步操作: 传统<code>XMLHttpRequest</code>方式定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(requenst.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 4表示请求完成</span><br>        <span class="hljs-keyword">if</span>(request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(request.<span class="hljs-property">responseText</span>); <span class="hljs-comment">// 调用成功回调</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(request.<span class="hljs-property">status</span>); <span class="hljs-comment">// 调用失败回调</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里,这种方式已经很少使用.不好看也不利于代码复用.</p><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><ul><li>同步: 代码按顺序一行一行执行,上一行代码执行完毕才能执行下一行</li><li>异步: 代码的执行不需要等待上一个任务的完成.例如网络请求,定时器等.异步操作不会阻塞主线程执行.</li></ul><p>JS是单线程语言,意味着它一次只能执行一个任务.为了处理耗时的异步操作而不阻塞主线程,JS使用事件循环和回调函数机制.Promise是建立在这个机制之上的更高级的异步处理方案.</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Promise有三种状态:</p><ul><li>Pending: 初始状态,异步操作正在进行中</li><li>fulfilled: 异步操作成功完成</li><li>rejected: 异步操作失败</li></ul><p>Promise对象提供<code>then()</code>和<code>catch()</code>方法来处理异步操作的结果或错误.</p><blockquote><p>then() 和 catch() 是 Promise 对象上用于处理异步操作结果的关键方法。它们允许你指定回调函数，分别在 Promise <code>完成（fulfilled）</code>或<code>拒绝（rejected）</code>时执行</p><p><code>then()</code>接收一个或两个参数:</p><ul><li>第一个参数(<code>onFulfilled</code>): 一个回调函数,当promise完成(fulfilled)时调用.这个回调函数会接收Promise的完成值作为参数</li><li>第二个参数(<code>onRejected</code>)(可选): 一个回调函数,当Promise拒绝(rejected)时调用.这个回调函数会接收Promise的拒绝原因(通常是一个Error对象)作为参数</li></ul><p>catch() 方法是<code>then(null, onRejected)</code> 的简写形式，它专门用于处理 Promise 的拒绝（rejected）状态。它接受一个回调函数作为参数，当 Promise 拒绝时调用。</p><hr><p><code>resolve()</code>和<code>rejected()</code>是JS Promise API提供的一个内部函数.当你使用<code>new Promise()</code>构造函数创建一个Promise,Promise会将<code>resolve</code>和<code>reject</code>两个函数作为参数传递给你的执行器函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <br>  <span class="hljs-comment">// ...你的异步操作代码...</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>resolve()</code>: 一个函数,用于将Promise状态从pending改为fulfilled(已完成).你需要在异步成功完成后调用<code>resolve()</code>,并将操作的结果作为参数传递给它.例如<code>resolve(&#39;操作成功&#39;)</code>或<code>resolve(&#123;data: someData&#125;)</code></li><li><code>reject()</code>: 一个函数,用于将Promise的状态从pending改为rejected(已拒绝).你需要在异步操作失败时调用<code>reject()</code>,并将错误原因(一般是一个<code>Error</code>对象)作为参数传递给它.例如:<code>reject(new Error(&quot;操作失败&quot;))</code>.</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单的Promise例子</span><br><span class="hljs-comment">// 创建一个promise对象,传入两个函数,一个是成功时执行,一个失败时执行</span><br><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// setTimeout(callback, delay) 延时执行callback函数,用来模拟一个异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> success = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (success) &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作成功!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;操作失败!&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 使用then()处理成功的结果</span><br>promise.<span class="hljs-title function_">then</span>(<br>	<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    &#125;<br>);<br><br><span class="hljs-comment">// 使用更简洁的链式调用和catch()处理错误</span><br>promise.<span class="hljs-title function_">then</span>(<br>	<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;<br>).<span class="hljs-title function_">catch</span>(<br>	<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>因为<code>then()</code>方法返回一个新的Promise对象,因此可以实现链式调用,异步操作更加清晰和易于维护</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<br>    	<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 箭头函数的函数体只有一行时,可以省略return和&#123;&#125;,下面的箭头函数等价于: () =&gt; &#123; return resolve(&quot;操作1完成&quot;) &#125;</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作1完成&quot;</span>), <span class="hljs-number">1000</span>);<br>        &#125;<br>    );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation2</span>(<span class="hljs-params">result1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<br>    	<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(result1 + <span class="hljs-string">&#x27;, 操作2完成&#x27;</span>), <span class="hljs-number">1500</span>);<br>        &#125;<br>    );<br>&#125;<br><br><span class="hljs-title function_">asyncOperation1</span>()<br>	<span class="hljs-comment">/* </span><br><span class="hljs-comment">	   回调函数内部调用了&quot;asyncOperation2()&quot;,并将</span><br><span class="hljs-comment">	*/</span><br>	.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result1</span>) =&gt;</span> <span class="hljs-title function_">asyncOperation2</span>(result1))<br>	.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result2</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2))<br>	.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong><code>asyncOperation1()</code></strong>: 调用asyncOperation1()函数,这个函数返回一个<code>Promise</code>,这个Promise在1秒后resolve为<code>操作1完成</code>.</li><li><strong><code>.then((result1) =&gt; asyncOperation2(result1))</code>:</strong> 第一个.then()方法被调用,它的回调函数<code>(result1) =&gt; asyncOperation2(result1)</code>会在<code>asyncOperation1()</code>返回<code>Promise fulfilled</code>后执行.<ul><li><strong><code>result1</code>:</strong> <code>asyncOperation1()</code>的Promise resolve值(<code>操作1完成</code>)会被作为参数传递给第一个<code>.then()</code>的回调函数,这里的<code>result1</code>只是自定义的一个变量名,它会被自动赋值,你把它改为其他名字一样的作用.</li><li><strong><code>asyncOperation2(result1)</code>:</strong> 回调函数内部调用了<code>asyncOperation2</code>函数.并将<code>result1</code>(也就是”操作1完成”)作为参数传递给它.<code>asyncOperation2</code>也会返回一个Promise,这个Promise在1.5秒后resolve为<code>result1 + &#39;, 操作2完成&#39;</code>,也就是”操作1完成，操作2完成”</li></ul></li><li><strong><code>.then((result2) =&gt; console.log(result2))</code>:</strong> 第二个<code>.then()</code>方法被调用.它的回调函数<code>(result2) =&gt; console.log(result2)</code>会在第一个<code>.then()</code>返回新的Promise fulfilled后执行.<ul><li><strong><code>result2</code>:</strong> <code>asyncOperation2()</code>返回的Promise resolve的值(“操作1完成,操作2完成”)会被作为参数传给第二个<code>.then()</code>的回调函数,赋值给<code>result2</code>,同样,名字随意.</li><li><strong><code>console.log(result2)</code>:</strong> 打印<code>result2</code>的值</li></ul></li><li><strong><code>.catch((error) =&gt; console.error(error)))</code>:</strong> 用于捕获Promise链中任何一个Promise出现<code>rejected</code>状态的情况.</li></ul></blockquote><p><strong>总结:</strong> 理解Promise链的关键在于理解:</p><ol><li><code>.then()</code>方法会获取上一个Promise对象的resolve返回,并把它作为参数传递给<code>.then()</code>的<code>回调函数</code></li><li>如果上一个Promise内<code>reject()</code>了,那么<code>.then()</code>的第一个回调函数就不会被执行,代码跳到链上的下一个<code>.catch()</code>或者直接抛出错误(如果没有<code>.catch()</code>)</li><li><code>.then()</code> 方法不仅是处理 Promise 完成后的结果，更是构建 Promise 链、实现异步操作顺序执行的关键。 它通过接收前一个 Promise 的结果作为输入，来实现异步操作之间的依赖关系，让后续操作建立在前面的操作结果之上</li></ol><hr><p>但是其实可以看到Promise链理解起来十分复杂,写起来也一样复杂,大多数情况下,要使用<code>async/await</code>,这是针对Promise的语法糖,它使得异步代码看起来更像同步代码,从而大大简化代码的复杂度喝可读性.只有在一些非常特殊的情况下（例如，需要非常精细地控制 Promise 的执行顺序，或者与一些老旧的库进行交互），你才可能需要编写更复杂的 Promise 链。 而大多数情况下，应该尽量避免复杂的 Promise 链，而选择更清晰和易于维护的方法。</p><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p>在JS中,async关键字用于声明一个异步函数.异步函数总是返回一个Promise对象,即使函数体没有显示地返回一个Promise.</p><p>特点:</p><ul><li><strong>总是返回一个Promise:</strong> 一个 async 函数无论是否显式返回一个 Promise，都会隐式地返回一个 Promise。如果 async 函数返回一个值，这个值会被 <code>Promise.resolve()</code> 包装成一个 fulfilled 的 Promise；如果 async 函数抛出一个异常，则返回一个 rejected 的 Promise。</li><li><strong><code>await</code>关键字:</strong> <code>async</code>关键字内部可以使用<code>await</code>关键字,暂停函数的执行,知道一个Promise完成(fulfilled或rejected).这使得异步代码更容易阅读和编写,看起来更像同步代码.</li><li><strong>清晰的错误处理:</strong> 使用<code>try...catch</code>直接不过异步操作中可能发生的错误.</li><li><strong>简化异步操作:</strong> <code>async/await</code>使得处理多个异步操作变得更加简单和易于理解,避免promise链的嵌套和复杂.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">someAsyncOperation1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Operation 1 completed&quot;</span>), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">someAsyncOperation2</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(data + <span class="hljs-string">&quot; - Operation 2 completed&quot;</span>), <span class="hljs-number">1500</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation1</span>(); <span class="hljs-comment">// 等待someAsyncOperation1完成</span><br>        <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation2</span>(result1); <span class="hljs-comment">// 等待someAsyncOperation2完成</span><br>        <span class="hljs-keyword">return</span> result2; <span class="hljs-comment">// 返回一个promise,值为result2</span><br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 或者抛出错误 throw error</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myAsyncFunction</span>()<br>	.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;final result:&quot;</span>, result))<br>	.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Caught error:&quot;</span>, error));<br></code></pre></td></tr></table></figure><ul><li>myAsyncFunction 是一个 async 函数。</li><li>await 关键字用于等待 someAsyncOperation1 和 someAsyncOperation2 异步操作完成。</li><li>try…catch 块用于处理潜在的错误。</li><li>函数最终返回一个 Promise。</li></ul><blockquote><p><code>async</code>函数的本质是对Promise的语法糖.它使得异步操作得编写简洁易懂,底层仍然依赖于Promise.</p><p>所以你可以看到,使用<code>async/await</code>来编写异步代码更加便捷易懂,但是它返回的永远是一个Promise对象.所以依旧需要<code>then</code>和<code>catch</code>来处理成功的结果&#x2F;可能发生的错误</p></blockquote><h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">...<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 或者抛出错误 throw error;</span><br>        <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 这两行代码二选一</span><br>    &#125;<br>...<br></code></pre></td></tr></table></figure><p>上面的错误处理,<code>return null;</code>和<code>throw error;</code>是两种截然不同的操作.</p><ul><li><p><code>return null</code></p><p>只是简单地返回一个null,不会中断Promise链的执行,也不会触发<code>.catch()</code>,<code>return null</code>只是改变了Promise的resolve值,但Promise的状态仍然是<code>fulfilled</code></p></li><li><p><code>throw error;</code></p><p>则会将错误抛出,把promise的状态改为rejected,从而触发<code>.catch()</code>方法.这个错误也能被调用方用<code>try...catch</code>来捕获.触发了<code>throw error</code>会中断Promise链. 更准确地说，它会将 Promise 的状态设置为 rejected，并且会停止后续 .then() 方法中 <em>第一个参数（onFulfilled）</em> 回调函数的执行。 错误会沿着 Promise 链向上“冒泡”，直到遇到一个 .catch() 方法来处理它，或者最终导致程序报错（如果没有 .catch() 处理）。</p></li></ul><p>下面是一个用<code>try...catch</code>捕获<code>threw error</code>的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation1</span>();<br>    <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation2</span>(result1);<br>    <span class="hljs-keyword">return</span> result2;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error in myAsyncFunction:&quot;</span>, error);  <span class="hljs-comment">//记录错误信息</span><br>    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 将错误抛出到调用者</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myAsyncFunction</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Result:&quot;</span>, result);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught in main function:&quot;</span>, error); <span class="hljs-comment">// 在这里处理抛出的错误</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>从上面的例子也能看出,<code>async</code>定义的异步函数可以通过<code>另一个异步函数</code>(main)来调用,并使用<code>try...catch</code>来捕获错误.从而避免了<code>.then()</code>和<code>.catch()</code>的使用.这是一种更优雅更易的方式.但是要谨记,这些都只是语法糖,底层依旧是Promise对象.</p><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p>是HTML5的一个组件,提供一个可以用来绘制2D图形的位图.它本质上是一个可以被JS代码操作的画布.你可以用JS在它上面绘制各种图形,图像和文字.</p><p>主要用途:</p><ul><li>图形绘制</li><li>图像处理: 缩放,选装,裁剪,滤镜等</li><li>动画制作: 通过不停更新canvas的内容创建动画效果</li><li>游戏开发: 是很多2D游戏的开发基础</li><li>数据可视化</li></ul><p>局限性:</p><ul><li>性能: 非常复杂的图形和动画,推荐使用WebGL(一种基于canvas的3D图形库)</li><li>DOM操作: canvas本身不是DOM元素,所以不支持DOM API来操作.</li><li>矢量图: 不支持矢量图,矢量图缩放不会失真.所以Canvas绘制的图形缩放会失真.SVG是处理矢量图更好的选择.</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/JavaScript/" class="print-no-link">#JavaScript</a></div></div><div class="license-box my-3"><div class="license-title"><div>JavaScript-浏览器</div><div>http://example.com/2024/11/15/js-browser/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年11月15日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/20/js-error/" title="JavaScript-错误处理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">JavaScript-错误处理</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/11/12/js-oop/" title="JavaScript-面向对象编程"><span class="hidden-mobile">JavaScript-面向对象编程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>