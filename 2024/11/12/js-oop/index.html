<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="原型对于大多数语言,面向对象编程都是通过类和实例来实现.但是在JS中,它不区分类和实例,而是通过原型(prototype)来实现面向对象编程. 举个例子来说明一下原型: 假设我们想创建xiaoming这个具体的学生,但是我们没有Student类型可以用,不过有一个现成的对象 1234567let robot &#x3D; &#123;    name: &#x27;Robot&#x27;,    heigh"><meta property="og:type" content="article"><meta property="og:title" content="JavaScript-面向对象编程"><meta property="og:url" content="http://example.com/2024/11/12/js-oop/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="原型对于大多数语言,面向对象编程都是通过类和实例来实现.但是在JS中,它不区分类和实例,而是通过原型(prototype)来实现面向对象编程. 举个例子来说明一下原型: 假设我们想创建xiaoming这个具体的学生,但是我们没有Student类型可以用,不过有一个现成的对象 1234567let robot &#x3D; &#123;    name: &#x27;Robot&#x27;,    heigh"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png"><meta property="article:published_time" content="2024-11-12T08:50:10.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.056Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="JavaScript"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>JavaScript-面向对象编程 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">JavaScript-面向对象编程</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-11-12 16:50" pubdate>2024年11月12日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 28 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">JavaScript-面向对象编程</h1><div class="markdown-body"><h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>对于大多数语言,面向对象编程都是通过<code>类</code>和<code>实例</code>来实现.但是在JS中,它不区分类和实例,而是通过<code>原型(prototype)</code>来实现面向对象编程.</p><p>举个例子来说明一下<code>原型</code>:</p><p>假设我们想创建<code>xiaoming</code>这个具体的学生,但是我们没有<code>Student</code>类型可以用,不过有一个现成的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> robot = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.6</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个<code>robot</code>对象有名字,有身高还会跑,有点像<code>xiaoming</code>,于是就是用它来<code>创建</code>xiaoming吧.直接把它改名为<code>Student</code>,然后创建出<code>xiaoming</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Student</span> = &#123;<br>	<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.2</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span><br>&#125;;<br><span class="hljs-comment">// 这里把xiaoming的原型指向了Student,看上去xiaoming仿佛是从Student继承下来</span><br>xiaoming.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Student</span>;<br>xiaoming.<span class="hljs-property">name</span>; <span class="hljs-comment">// &#x27;xiaoming&#x27;</span><br>xiaoming.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// xiaoming is running...</span><br></code></pre></td></tr></table></figure><p>JS的<code>原型链</code>没有<code>class</code>的概念,所有对象都是实例,所谓的<code>继承关系</code>就是一个对象的原型指向另一个对象.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411121803684.jpeg" srcset="/img/loading.gif" lazyload alt="xiaoming-prototype"></p><p>比如如果你把<code>xiaoming</code>的原型指向其他对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bird</span> = &#123;<br>    <span class="hljs-attr">fly</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is filying...&#x27;</span>);<br>    &#125;<br>&#125;;<br>xiaoming.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Bird</span>;<br><br>xiaoming.<span class="hljs-title function_">fly</span>(); <span class="hljs-comment">// 现在xiaoming已经无法run了,只能fly</span><br></code></pre></td></tr></table></figure><blockquote><p>**注意:**上面的<code>__proto__</code>只是为了演示而已,实际开发不要直接用<code>obj.__proto__</code>去改变一个对象的原型</p></blockquote><p><code>object.create()</code>可以传入一个原型对象,并创建一个基于该原型的新对象,但是新对象什么属性都没有.因此我们可以写个函数来创建<code>xiaoming</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型对象</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Student</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.2</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStudent</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-comment">// 基于Student原型创建一个新对象</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Student</span>);<br>    <span class="hljs-comment">// 初始化新对象</span><br>    s.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-title function_">createStudent</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 小明 is running...</span><br>xiaoming.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Student</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>JS对每个创建的对象都会设置一个<code>原型</code>,指向它的<code>原型对象</code>.</p><blockquote><p>当我们用<code>obj.xxx</code>访问一个对象的属性时,JS引擎会先在该对象上找对应的属性,没有找到就去它的原型对象上找,还没有找到,就一直上溯到<code>object.prototype</code>对象,都没找到,就返回<code>undefined</code></p></blockquote><p>例如一个<code>array</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>这就是它的原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">       <span class="hljs-literal">null</span><br>         ▲<br>         │<br>┌─────────────────┐<br>│<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>└─────────────────┘<br>         ▲<br>         │<br>┌─────────────────┐<br>│ <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>└─────────────────┘<br>         ▲<br>         │<br>┌─────────────────┐<br>│       arr       │<br>└─────────────────┘<br></code></pre></td></tr></table></figure><p><code>Array.prototype</code>定义了<code>indexOf()</code>,<code>shift()</code>等方法,因此你可以在所有<code>Array</code>对象上直接调用这些方法.</p><p>当我们创建一个函数,函数也是对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>        <span class="hljs-literal">null</span><br>          ▲<br>          │<br>┌───────────────────┐<br>│ <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│        foo        │<br>└───────────────────┘<br></code></pre></td></tr></table></figure><p><code>Function.prototype</code>定义了<code>apply()</code>等方法,所以所有函数都能调用这些方法.</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="object-create"><a href="#object-create" class="headerlink" title="object.create()"></a>object.create()</h2><p>如上所示.这种方法允许你创建一个新对象,并将现有对象作为其原型.这意味着新对象将继承现有对象的属性和方法.</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>最简单,最常用.就是直接使用<code>&#123;...&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObject = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: John Doe</span><br>myObject.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出: Hello John Doe</span><br></code></pre></td></tr></table></figure><h2 id="new-Object"><a href="#new-Object" class="headerlink" title="new Object()"></a>new Object()</h2><p>不太常用,主要用于创建一个空对象,然后动态地添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>myObject.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Peter&#x27;</span>;<br>myObject.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: Peter</span><br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>这种方法允许你创建多个具有相同属性和方法的对象.构造函数使用<code>this</code>引用新创建的对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Peter Pan&#x27;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;WeiJian&#x27;</span>, <span class="hljs-number">18</span>);<br>person1.<span class="hljs-title function_">greet</span>();<br>person2.<span class="hljs-title function_">greet</span>();<br></code></pre></td></tr></table></figure><ul><li><code>new</code>关键字把构造函数内的<code>this</code>绑定到对应的新对象上.</li><li>构造函数默认返回<code>this</code>,也就是不用写<code>return this</code></li></ul><p>原型链是这样的:</p><p><code>person1</code>的原型指向函数<code>Person</code>的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">              <span class="hljs-literal">null</span><br>                ▲<br>                │<br>       ┌─────────────────┐<br>       │<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>       └─────────────────┘<br>                ▲<br>                │<br>       ┌─────────────────┐<br>       │<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>       └─────────────────┘<br>         ▲      ▲      ▲<br>         │      │      │<br>┌─────────┐┌─────────┐┌─────────┐<br>│person1  ││person2  ││ ...     │<br>└─────────┘└─────────┘└─────────┘<br></code></pre></td></tr></table></figure><p>使用<code>new &lt;构造函数&gt;</code>创建的对象还会从原型上获取一个<code>constructor</code>属性,指向<code>&lt;构造函数&gt;</code>本身.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br>person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411131146988.png" srcset="/img/loading.gif" lazyload alt="image-20241113114617900"></p><ul><li>红色箭头是原型链</li><li><code>Person.prototype</code>指向的就是<code>person1</code>和<code>person2</code>的<code>原型对象</code></li><li>这个原型对象自己有个<code>constructor</code>的属性,指向<code>Person</code>构造函数本身</li><li>另外<code>person1</code>,<code>person2</code>是没有<code>prototype</code>属性的,不过可以用<code>__proto__</code>这个非标准用法来查看</li><li>此时我们就认为<code>person1</code>,<code>person2</code>“继承”自<code>Person</code></li></ul><p>另外还有一个小问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person1.<span class="hljs-property">name</span> === person2.<span class="hljs-property">name</span>; <span class="hljs-comment">// false</span><br>person1.<span class="hljs-property">greet</span> === person2.<span class="hljs-property">greet</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>新创建的对象,属性不相等是正常的,但是他们的<code>方法也是不相等的</code>.也就是说它们各自会有各自的方法,几时方法的名字和代码都一样.</p><p>但是这样子同样的方法存两份有点浪费资源了,所以我们可以在<code>共享对象上创建这个方法</code>,然后继承它的对象就会使用同一个方法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>如果一个函数被定义为用于创建对象的<code>构造函数</code>,但是调用时忘记写<code>new</code>:</p><ul><li><code>strict</code>模式下,<code>this.name = name</code>会报错,因为<code>this</code>绑定为<code>undefined</code></li><li>非<code>strict</code>模式下,<code>this.name = name</code>不会报错,因为<code>this</code>绑定为<code>window</code>,无意间创建了全局变量<code>name</code>,并返回<code>undefined</code></li></ul><p>所以调用构造函数千万不要忘记了<code>new</code>.一些语法检查工具可以帮助你检查你的语法,比如<code>jslint</code></p></blockquote><p>但其实<code>new</code>可以通过函数封装,一个常用的编程模式像这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;匿名&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 在原型对象上加函数,以后创建新对象自动继承</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 通过一个函数封装new操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(props || &#123;&#125;);<br>&#125;<br><br><span class="hljs-comment">// 调用时就不怕漏掉new,参数也灵活,传不传都可以</span><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-title function_">createStudent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h2><p>ES后引入创建对象的语法,以后会提及.</p><hr><blockquote><p>目前字面量和类语法最常用.</p><p><code>构造函数</code>的缺点是其原型链的设置方式容易出错,而且没有类语法清晰</p><p><code>Object.create()</code>主要用于精确控制原型链的场景,或者需要创建不带构造函数的对象</p></blockquote><h1 id="模拟继承"><a href="#模拟继承" class="headerlink" title="模拟继承"></a>模拟继承</h1><p>在传统基于Class的语言如Java,C++中,继承的本质是扩展一个已有的class,并生成新的Subclass.由于这类语言严格区分类和实例,继承实际上<code>类型</code>的扩展.</p><p>但是JS采用<code>原型继承</code>,所以无法直接扩展一个Class,因为根本没有Class这个概念.</p><p>那如果想要继承扩展呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设有这么一个Student的构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Unnamed&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 在Student的原型中添加一个hello的共享方法</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 创建两个新对象</span><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">let</span> xiaohong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小红&#x27;</span>);<br></code></pre></td></tr></table></figure><p>原型链如下:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411131542775.jpeg" srcset="/img/loading.gif" lazyload alt="js-proto"></p><p>此时如果想要基于<code>Student</code>扩展出<code>PrimaryStudent</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">// call 允许你调用一个函数,并指定函数内部&quot;this&quot;的值以及传递给函数的参数</span><br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，<code>Student.call(this, props)</code>做了以下事情：</p><ol><li><strong>调用 Student 函数:</strong> 它像普通函数一样调用了 <code>Student</code> 构造函数。</li><li><strong>设置 this 的值:</strong> call() 的第一个参数指定了 <code>Student</code> 函数内部 <code>this</code> 的值。 在这里，<code>this</code> 指的是正在被创建的 <code>PrimaryStudent</code> 实例。 这很重要，因为在 <code>Student</code> 构造函数内部，<code>this.name = props.name || &#39;Unnamed&#39;;</code> 这行代码会将 <code>name</code> 属性添加到 <code>this</code> 指向的对象上。 通过将 <code>this</code> 设置为 <code>PrimaryStudent</code> 的实例，我们确保 <code>name</code> 属性被添加到 <code>PrimaryStudent</code> 实例上，而不是其他地方。</li><li><strong>传递参数:</strong> <code>call()</code> 的第二个参数 <code>props</code> 将被传递给 <code>Student</code> 函数。 这使得 <code>Student</code> 构造函数可以使用 <code>props</code> 对象来初始化 <code>PrimaryStudent</code> 实例的 <code>name</code> 属性</li></ol></blockquote><p>这个做法可以理解为:</p><p>在<code>PrimaryStudent</code>构造函数内部手动调用<code>Student</code>构造函数,并将其<code>this</code>指向了<code>PrimaryStudent</code>的实例.这样模拟了<code>Student</code>构造函数被用于创建<code>PrimaryStudent</code>实例的效果,模拟”继承”.</p><p>但实际上这<strong>并不是</strong>真正意义上的<code>继承</code>.举这个例子只是为了扩展,实际中并不会这么操作.</p><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/javascript/oop/prototype/index.html">来源</a></p><p>但我看不懂他下面的解释,只摘录这个例子,后面的理解找的AI.</p><h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p>JavaScript继承的核心是<code>原型链</code>.每个对象都有一个<code>__proto__</code>属性.(现代浏览器中一般通过<code>Object.getPrototypeOf()来访问</code>),它指向创建该对象的<strong>函数</strong>的<code>prototype</code>属性.当访问对象的某个属性时,JS引擎会现在对象自身查找,如果没有找到,就会沿着原型链向上查找,知道找到该属性或到达原型链顶端(null).</p><h2 id="proto-VS-prototype"><a href="#proto-VS-prototype" class="headerlink" title="__proto__VS prototype"></a><code>__proto__</code>VS <code>prototype</code></h2><p><code>prototype</code>(原型属性)</p><ul><li><p>是一个<code>函数对象</code>才拥有的属性.它指向<code>原型对象</code>.使用该函数(构造函数)<code>new</code>出来的对象,它的<code>__proto__</code>属性会被设置为<code>prototype</code>的属性值</p></li><li><p>一般用来定义通过构造函数创建的对象的<code>共享属性</code>和<code>方法</code>.也就是说它充当新对象的模板.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><br>person1.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// Output: Hello, my name is Alice</span><br>person2.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// Output: Hello, my name is Bob</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">greet</span> === person2.<span class="hljs-property">greet</span>); <span class="hljs-comment">// true, 不同实例共享同一个方法</span><br></code></pre></td></tr></table></figure><p><code>Person.prototype</code>是<code>Person</code>构造函数的<code>原型属性</code></p></li></ul><p><code>__proto__</code>(原型链)</p><ul><li><p>是一个<code>对象</code>拥有的属性(包括函数对象).它指向创建该对象的构造函数的<code>prototype</code>属性.是JS实现原型继承的关键.</p></li><li><p>它用来构成JS的<code>原型链</code>.当访问一个对象属性的时候,JS引擎会现在对象自身找该属性,如果找不到,会沿着<code>__proto__</code>指向的原型对象继续查找,知道找到或者到尽头(null)为止.</p></li><li><p>但现在我们一般不直接调用它,他是用<code>Object.getPrototypeOf()</code>来查看; <code>Object.setPrototypeOf()</code> 来设置对象的原型.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Output: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">greet</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span>); <span class="hljs-comment">// Output: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Output: true (preferred way)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="inherits"><a href="#inherits" class="headerlink" title="inherits"></a>inherits</h2><p><code>inherits</code>函数的目标是建立两个构造函数之间的继承关系,使一个<code>构造函数的实例</code>能够继承另一个构造函数的<code>原型上的属性和方法</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 下面是一个inherits函数的模拟实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child, Parent</span>) &#123;<br>    <span class="hljs-comment">// 1. 创建一个空函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 临时构造函数,作为中介,避免直接修改Child或Parent的原型</span><br>    <br>    <span class="hljs-comment">// 2. 将F的原型设置为Parent的原型</span><br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// F与Parent共享同一个原型</span><br>    <br>    <span class="hljs-comment">// 3. 将Child的原型设置为F的一个新实例</span><br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <span class="hljs-comment">// Child继承Parent的原型,而且Child.prototype独立于Parent.prototype</span><br>    <br>    <span class="hljs-comment">// 4. 设置Child.prototype.constructor 回到Child</span><br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 恢复Child的构造函数,因为步骤3修改了它</span><br>    <br>    <span class="hljs-comment">// 可选步骤: 添加__super__属性,非标准,但常用</span><br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__super__</span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 方便在子类方法重调用父类方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141758092.png" srcset="/img/loading.gif" lazyload alt="image-20241114175822002"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141759062.png" srcset="/img/loading.gif" lazyload alt="image-20241114175911981"></p><p>此时<code>F</code>和<code>Parent</code>指向<code>同一个</code>原型对象</p><p><code>new F()</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141801806.png" srcset="/img/loading.gif" lazyload alt="image-20241114180118730"></p><p>通过<code>F()</code>构造函数创建的实例(f_instance),它的<code>__proto__</code>指向它的构造函数的<code>prototype</code>属性,也就是<code>F</code>的<code>prototype</code>属性,因为<code>F</code>和<code>Parent</code>指向<code>同一个</code>原型对象,所以f_instance的<code>__proto__</code>实际上也是指向<code>Parent.prototype</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141813263.png" srcset="/img/loading.gif" lazyload alt="image-20241114181352180"></p><p>此时把Child的<code>prototype</code>指向F构造函数创建的实例(<code>f_instance</code>),因为<code>f_instance.__proto__</code>指向<code>Parent.prototype</code>,此时Child和Parent就串起来了.</p><p>可是此时<code>Child的prototype的constructor属性</code>应该是<code>F()</code>,因为此时Child的prototype指向了f_instance,所以Child的prototype的constructor指向的是f_instance的构造函数,也就是F().</p><p>所以要修复回来,指回<code>Child</code>. <code>Child.prototype.constructor = Child;</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141825203.png" srcset="/img/loading.gif" lazyload alt="image-20241114182546123"></p><p>最终原型链大概是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141841882.png" srcset="/img/loading.gif" lazyload alt="image-20241114184137787"></p><hr><blockquote><p>真尼玛复杂….</p><p>我觉得大概理一下就行了,反正以后都是用ES6的class语法</p></blockquote><hr><p>以上复杂的动作可以用一个<code>inherits()</code>函数封装起来,隐藏<code>F</code>的定义,简化代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child, Parent</span>) &#123;<br>    <span class="hljs-keyword">let</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用这个<code>inherits()</code>函数就能简单实现原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Unnamed&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">PrimaryStudent</span>, <span class="hljs-title class_">Student</span>);<br><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property">protype</span>.<span class="hljs-property">getGrade</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>JS的对象模型基于原型实现,虽说它概念简单,没有类的概念.但是理解起来复杂,实现起来也麻烦.ES6引入了<code>class</code>这个语法糖,让类的定义更加简单.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数方式实现Student类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// class关键字实现Student类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 定义构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-comment">// 定义类中的方法</span><br>    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.<span class="hljs-title function_">hello</span>();<br></code></pre></td></tr></table></figure><h1 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h1><p>直接通过<code>extends</code>实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimaryStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, grade</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 用super调用父类的构造方法</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br>    <br>    <span class="hljs-title function_">myGrade</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;I am at grade &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code>: 定义类</li><li><code>extends</code>: 表示原型链对象来自<code>Student</code></li><li><code>constructor</code>: 定义子类的构造函数,子类需要<code>name</code>和<code>grade</code>两个参数,<code>name</code>用于<code>super(name)</code>中调用父类的构造函数,否则父类的<code>name</code>属性无法初始化</li></ul><blockquote><p>ES6引入的<code>class</code>只是一个语法糖,实际的底层原理跟上面的没有任何区别.我只能说…</p><p>舒服了….</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/JavaScript/" class="print-no-link">#JavaScript</a></div></div><div class="license-box my-3"><div class="license-title"><div>JavaScript-面向对象编程</div><div>http://example.com/2024/11/12/js-oop/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年11月12日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/15/js-browser/" title="JavaScript-浏览器"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">JavaScript-浏览器</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/11/11/js-standar-object/" title="JavaScript-标准对象"><span class="hidden-mobile">JavaScript-标准对象</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>