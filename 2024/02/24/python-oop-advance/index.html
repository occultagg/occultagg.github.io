<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="动态绑定属性和方法python是一种动态语言,而动态语言的类的属性和方法可以动态绑定 123456789101112131415161718# 比如有这么一个类class Student(object):    pass# 动态绑定属性s &#x3D; Student()s.name &#x3D; &#x27;Peter&#x27;print(s.name)# 动态绑定方法def set_age(self, age)"><meta property="og:type" content="article"><meta property="og:title" content="python-面向对象高级特性"><meta property="og:url" content="http://example.com/2024/02/24/python-oop-advance/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="动态绑定属性和方法python是一种动态语言,而动态语言的类的属性和方法可以动态绑定 123456789101112131415161718# 比如有这么一个类class Student(object):    pass# 动态绑定属性s &#x3D; Student()s.name &#x3D; &#x27;Peter&#x27;print(s.name)# 动态绑定方法def set_age(self, age)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta property="article:published_time" content="2024-02-24T08:23:04.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.058Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="python"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta name="referrer" content="no-referrer-when-downgrade"><title>python-面向对象高级特性 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">python-面向对象高级特性</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-02-24 16:23" pubdate>2024年2月24日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 34 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">python-面向对象高级特性</h1><div class="markdown-body"><h1 id="动态绑定属性和方法"><a href="#动态绑定属性和方法" class="headerlink" title="动态绑定属性和方法"></a>动态绑定属性和方法</h1><p>python是一种动态语言,而动态语言的类的属性和方法可以<code>动态绑定</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如有这么一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 动态绑定属性</span><br>s = Student()<br>s.name = <span class="hljs-string">&#x27;Peter&#x27;</span><br><span class="hljs-built_in">print</span>(s.name)<br><br><span class="hljs-comment"># 动态绑定方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>): <span class="hljs-comment"># 先定义一个函数</span><br>    <span class="hljs-variable language_">self</span>.age = age<br>    <br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br>s.set_age = MethodType(set_age, s) <span class="hljs-comment"># 给实例绑定方法</span><br>s.set_age(<span class="hljs-number">25</span>)<br>s.age<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>这种动态绑定属性和方法,可以在程序运行过程中对实例添加属性和方法,但是<code>只是对该实例生效</code>,同一个类创建的另一个实例是不生效的.</p><h1 id="solt"><a href="#solt" class="headerlink" title="__solt__"></a>__solt__</h1><blockquote><p>如果不想让别人随意动态绑定属性,可以使用<code>__solt__</code>指定可以绑定的属性名,实例只可以绑定指定的属性.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment"># 用tuple定义允许绑定的属性名称</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student() <span class="hljs-comment"># 创建新的实例</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Michael&#x27;</span> <span class="hljs-comment"># 绑定属性&#x27;name&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age = <span class="hljs-number">25</span> <span class="hljs-comment"># 绑定属性&#x27;age&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">99</span> <span class="hljs-comment"># 绑定属性&#x27;score&#x27;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;score&#x27;</span> <span class="hljs-comment"># slot没有允许score的属性绑定,因而报错AttributeError</span><br></code></pre></td></tr></table></figure><h1 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h1><p>属性装饰器,用于将<code>类的方法</code>转换为<code>属性</code>,从而实现属性的访问和设置时调用对应的方法.</p><p>主要适用场景有:</p><ul><li>实现属性的访问控制: 将方法装饰为@property控制属性的访问权限(只读,只写,读写).</li><li>简化属性的访问: 将方法转为属性,就可以直接适用属性的访问方式(点号语法)访问方法</li><li>属性计算&#x2F;验证: 在属性访问时执行特定的计算或逻辑,或实现验证</li></ul><p>getter和setter: 类的外部公共接口,用来访问和修改属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        <span class="hljs-variable language_">self</span>.radius = radius<br>        <br><span class="hljs-meta">    @property </span><span class="hljs-comment"># diameter就装饰成@property,该方法就会成为对应属性的getter方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameter</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.radius * <span class="hljs-number">2</span><br>    <br><span class="hljs-meta">    @diameter.setter </span><span class="hljs-comment"># 被属性装饰器装饰后,会自动生成对应的setter装饰器</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameter</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;diameter  must be an integer!&#x27;</span>)<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;diameter must between 0 ~ 100&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>._radius = value <span class="hljs-comment"># _开头的变量名是一个约定俗成的做法,表示这个变量是一个私有变量,应谨慎处理,但开发人员依旧可以直接访问和修改该变量</span><br>        <span class="hljs-comment"># 使用_开头是为了提醒开发者,这是一个私有变量,应该通过类的公共接口(getter,setter)来访问和修改</span><br>        <br>a = Circle(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(a.diameter) <span class="hljs-comment"># 结果是10 (getter)</span><br>a.diameter = -<span class="hljs-number">1</span> <span class="hljs-comment"># 报错 (setter)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment">#birth是一个可读写属性</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birth</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._birth <span class="hljs-comment"># 注意实例变量名不能与方法名一样,因为在调用s.birth时,首先会转回方法调用,然后在执行return时候,又视为访问self的属性,再次转为方法调用,造成无限递归,最终导致栈溢出RecursionError</span><br>    <br><span class="hljs-meta">    @birth.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birth</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>._birth = value<br>        <br>    <span class="hljs-comment"># age只定义getter不定义setter就是只读</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        retuen <span class="hljs-number">2015</span> - <span class="hljs-variable language_">self</span>._birth<br></code></pre></td></tr></table></figure><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>一个子类可以通过多重继承同时获得多个父类的所有功能.</p><p>假设要实现4种动物:</p><ul><li>Dog - 狗</li><li>Bat - 蝙蝠</li><li>Parrot - 鹦鹉</li><li>Ostrich - 鸵鸟</li></ul><p>我们可以按照哺乳动物和鸟类来归类,可以设计出这样的类的层次:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    Animal     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Mammal    │           │    Bird     │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><p>如果按<code>能跑</code>和<code>能飞</code>来划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    Animal     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │  Runnable   │           │   Flyable   │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><p>如果合并两种划分方式,就要设计更多层次:</p><ul><li>哺乳类: 能跑的哺乳类, 能飞的哺乳类</li><li>鸟类: 能跑的鸟类, 能飞的鸟类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    Animal     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Mammal    │           │    Bird     │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br>     │            │            │            │<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><p>如果还要增加”宠物类”和”非宠物类”呢?层次将会越搞越多,类的数量也会呈指数级增长.此时就应该用到多重继承.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最开始的设计,只分哺乳类和鸟类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 大类:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 各种动物:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Mammal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(<span class="hljs-title class_ inherited__">Mammal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parrot</span>(<span class="hljs-title class_ inherited__">Bird</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span>(<span class="hljs-title class_ inherited__">Bird</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 加入可跑和可飞</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Runnable</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Flying...&#x27;</span>)<br>        <br><span class="hljs-comment"># 多重继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(Mammal, Runnable):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(Mammal, Flyable):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h2><blockquote><p>一般在设计类的继承关系时,通常都是单一继承,但是如果需要<code>混入</code>额外功能时候,可以通过多重继承实现.这种设计称为MixIn.</p><p>MixIn的目的就是给一个类增加多个功能.在设计类的时候,我们优先考虑通过多重继承组合多个MixIn功能,而不是设计多层次的继承关系</p></blockquote><p>为了更好地看出继承关系,一般我们会把需要加上的类名改为<code>xxxMixIn</code>,MixIn类的定义通常不定义<code>__init__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeakMixin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;I can speak.&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EatMixin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;I can eat.&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(Animal, SpeakMixin, EatMixin):<br>    <span class="hljs-keyword">pass</span><br><br>dog = Dog()<br>dog.speak()  <span class="hljs-comment"># 输出：I can speak.</span><br>dog.eat()  <span class="hljs-comment"># 输出：I can eat.</span><br></code></pre></td></tr></table></figure><p>python自带的很多库也使用了MixIn,比如<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务,如果要同时服务多个用户就必须使用多进程或多线程模型,这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTCPServer</span>(TCPServer, ForkingMixIn):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="方法解析顺序-MRO"><a href="#方法解析顺序-MRO" class="headerlink" title="方法解析顺序(MRO)"></a>方法解析顺序(MRO)</h2><p>python中用于确定类方法调用顺序的算法.在多重继承下,当一个类实例调用一个方法时,MRO会决定应该使用哪个父类的实现.确保方法调用的确定性和一致性,避免命名冲突和歧异.</p><p>基本规则:</p><ul><li>深度优先搜索: MRO从当前类开始,一次搜索父类和祖先类,直到找到要调用的方法</li><li>从左到右: 在每个类中,MRO会从左到右搜索其基类列表</li><li>线性化: MRO会将所有继承关系转换为一个线性顺序,从而避免循环引用和无限递归</li></ul><p>具体步骤:</p><ol><li>获取当前类的MRO属性: 每个类都有一个<code>__mro__</code>属性,其中包含了该类的MRO列表</li><li>遍历MRO列表: 对于MRO列表中的每个类,检查,检查该类是否定义了要调用的方法</li><li>找到第一个定义该方法的类: 如果找到,则使用该类的实现</li><li>没有找到: raise <code>AttributeError</code>异常</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> inspect<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">B</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(C, B):<br>    <span class="hljs-keyword">pass</span><br><br>mro = inspect.getmro(D)<br><span class="hljs-built_in">print</span>(mro)  <span class="hljs-comment"># 输出：(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="hljs-built_in">print</span>(D.__mro__) <span class="hljs-comment"># 也可以执行print MRO 属性</span><br></code></pre></td></tr></table></figure><h1 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h1><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>以<code>双下划线开头和结尾</code>的特殊方法,用于扩展类的功能和行为.这些方法允许你控制类的实例化,属性访问,运算符重载,迭代等行为,从而实现更强大的类的设计.</p><p>常见的魔术方法及用途:</p><table><thead><tr><th>魔术方法</th><th>用途</th></tr></thead><tbody><tr><td><code>__init__</code></td><td>初始化方法,用于创建类的实例时设置属性</td></tr><tr><td><code>__str__</code></td><td>字符串表示方法,用于将类实例转换成字符串</td></tr><tr><td><code>__repr__</code></td><td>表示方法,用于提供更详细的类实例表示</td></tr><tr><td><code>__iter__</code></td><td>迭代器方法,用于使类实例可用于for循环</td></tr><tr><td><code>__next__</code></td><td>迭代器方法,用于返回迭代的写一个元素</td></tr><tr><td><code>__getitem__</code></td><td>索引方法,用于获取类实例的元素</td></tr><tr><td><code>__setitem__</code></td><td>索引方法,用于设置类实例的元素</td></tr><tr><td><code>__add__</code></td><td>加法运算符重载方法，用于定义自定义加法运算</td></tr><tr><td><code>__sub__</code></td><td>减法运算符重载方法，用于定义自定义减法运算</td></tr><tr><td><code>__mul__</code></td><td>乘法运算符重载方法，用于定义自定义乘法运算</td></tr><tr><td><code>__eq__</code></td><td>等价运算符重载方法，用于定义自定义相等性检查</td></tr><tr><td><code>__call__</code></td><td>调用方法,用于使类实例可想函数一样调用</td></tr></tbody></table><p>使用这些魔术方法来<code>自定义</code>类的行为,就称为定制类,下面是一些例子</p><ol><li><p><strong><code>__init__(self, ...)</code>:</strong> 初始化实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, attr1, attr2</span>):<br>        <span class="hljs-variable language_">self</span>.attr1 = attr1<br>        <span class="hljs-variable language_">self</span>.attr2 = attr2<br></code></pre></td></tr></table></figure></li><li><p><strong><code>__str__(self):</code></strong> 返回一个可读的字符串表示该类的一个实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;MyClass(<span class="hljs-subst">&#123;self.value&#125;</span>)&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>__add__(self, other):</code></strong> 实现加法操作。注意，这个方法通常用于实现类与数字之间的相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> MyClass(<span class="hljs-variable language_">self</span>.value + other)<br></code></pre></td></tr></table></figure></li><li><p><strong><code>__len__(self):</code></strong> 返回对象的长度（如字符串或列表的长度）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.value)<br></code></pre></td></tr></table></figure></li><li><p><strong><code>__eq__(self, other):</code></strong> 实现等于操作 <code>==</code>。通过实现这个方法，你定义了两个类的实例相等的标准。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.value == other.value<br></code></pre></td></tr></table></figure></li></ol><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>python中通常使用<code>大写字母</code>+<code>下划线</code>来定义常量,python中的常量没有严格的限制,没有关键字声明,它在代码中还是可变的.当常量数量变多,声明和引用可能会变得麻烦或混乱,此时可以使用<code>枚举类</code>来定义和管理这些常量.</p><blockquote><p>枚举是一种数据类型，用于定义一组固定且有意义的值。想象一下，你想要表示一个星期中的某一天，你可能会用数字 1 到 7 来表示，但这样容易让人混淆。枚举允许你用更具描述性的名字来表示这些值，例如 MONDAY, TUESDAY, WEDNESDAY 等。</p></blockquote><p>python中使用<code>enum</code>模块来实现<code>枚举类</code>.</p><p>优点:</p><ul><li><strong>代码可读性提升:</strong> 使用枚举类，代码更清晰易懂，因为每个值都有一个有意义的名字。</li><li><strong>类型安全:</strong> 枚举类定义了常量的类型，避免了使用错误的值。</li><li><strong>代码维护方便:</strong> 修改枚举值只需修改枚举类定义，无需修改使用该枚举类的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义枚举类</span><br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    MONDAY = <span class="hljs-number">1</span><br>    TUESDAY = <span class="hljs-number">2</span><br>    WEDNESDAY = <span class="hljs-number">3</span><br>    THURSDAY = <span class="hljs-number">4</span><br>    FRIDAY = <span class="hljs-number">5</span><br>    SATURDAY = <span class="hljs-number">6</span><br>    SUNDAY = <span class="hljs-number">7</span><br>    <br><span class="hljs-comment"># 访问枚举类(使用.表达式)</span><br><span class="hljs-built_in">print</span>(Weekday.MONDAY) <span class="hljs-comment"># 输出Weekday.MONDAY</span><br><span class="hljs-built_in">print</span>(Weekday.MONDAY.value) <span class="hljs-comment"># 输出1</span><br></code></pre></td></tr></table></figure><p>枚举类可以定义方法,比如定义<code>__str__</code>自定义输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrafficLight</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    RED = <span class="hljs-string">&quot;stop&quot;</span><br>    YELLOW = <span class="hljs-string">&quot;caution&quot;</span><br>    GREEN = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.value<br><br><span class="hljs-built_in">print</span>(TrafficLight.RED)<br><span class="hljs-comment"># 直接输出stop</span><br></code></pre></td></tr></table></figure><h2 id="实际使用例子"><a href="#实际使用例子" class="headerlink" title="实际使用例子"></a>实际使用例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpStatusCode</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    OK = <span class="hljs-number">200</span><br>    CREATED = <span class="hljs-number">201</span><br>    BAD_REQUEST = <span class="hljs-number">400</span><br>    NOT_FOUND = <span class="hljs-number">404</span><br>    INTERNAL_SERVER_ERROR = <span class="hljs-number">500</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_response</span>(<span class="hljs-params">status_code</span>):<br>    <span class="hljs-keyword">if</span> status_code == HttpStatusCode.OK: <span class="hljs-comment">#可以直接使用HttpStatusCode.OK来判断</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Request successful!&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.CREATED:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Resource created successfully!&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.BAD_REQUEST:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid request parameters.&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.NOT_FOUND:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Resource not found.&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.INTERNAL_SERVER_ERROR:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Server encountered an error.&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Unknown status code: <span class="hljs-subst">&#123;status_code&#125;</span>&quot;</span>)<br><br>response = requests.get(<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>)<br>response_status_code = response.status_code<br><br>handle_response(response_status_code)<br></code></pre></td></tr></table></figure><h1 id="元类与type"><a href="#元类与type" class="headerlink" title="元类与type"></a>元类与type</h1><p>在python这种动态语言中,函数和类的定义不是编译时发生的,而是在运行时动态创建的.</p><p>比如写一个<code>hello.py</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;world&#x27;</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Hello <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当python解释器载入<code>hello</code>模块,会依次执行该模块的代码,结果就是动态创建一个<code>Hello</code>的class对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> hello <span class="hljs-keyword">import</span> Hello<br><span class="hljs-meta">&gt;&gt;&gt; </span>h = Hello()<br><span class="hljs-meta">&gt;&gt;&gt; </span>h.hello()<br>Hello world<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(Hello))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(h))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;hello.Hello&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到<code>Hello</code>是一个class,类型就是<code>type</code>,<code>h</code>是一个实例,也是一个class,类型是<code>Hello</code>.</p><hr><p>先来了解几个概念:</p><ul><li>类: 面向对象编程中,类是对象的蓝图,包含了对象的属性(数据)和方法(行为).</li><li>实例: 类是模板,实例是根据模板创建的具体对象</li><li>元类: 元类是类的一种特殊类型,用于创建类,简单来说:<strong>类是用来创建对象的,元类用来创建类</strong></li></ul><p><code>type()</code>是一个内置函数,用来获取对象的类型信息,也可以用来动态创建类.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># type()创建类的语法</span><br><span class="hljs-built_in">type</span>(name, bases, attrs)<br><span class="hljs-comment"># name: 新类名称</span><br><span class="hljs-comment"># bases: 父类列表</span><br><span class="hljs-comment"># attrs: 新类的属性和方法字典</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><p>type()是动态类创建的工具或接口,而元类是这个接口背后的机制.</p></li><li><p>当我们使用type()创建动态类时,type()会调用python的元类系统.</p></li><li><p>python的默认元类就是<code>type</code>,这意味着当我们使用type()创建类时,默认会使用<code>type元类</code></p></li></ul></blockquote><p>这就解释了为什么<code>Hello</code>这个class的类型是type.因为python默认是使用type(),基于<code>type元类</code>来创建动态类的.</p><blockquote><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况到。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义元类,来自定义类创建的机制,自定义元类需要继承自`type`类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>): <span class="hljs-comment"># 按照习惯元类名总是以Meta或Metaclass结尾</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>): <span class="hljs-comment"># __new__方法是元类的关键方法,负责创建新的类</span><br>        <span class="hljs-comment"># 在这里添加自定义逻辑,例如修改类属性,添加新方法等</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br></code></pre></td></tr></table></figure><ul><li><code>__new__()</code> 方法是元类的关键方法，它负责创建新的类。</li><li><code>cls</code>: 元类自身</li><li><code>name</code>: 新类的名称</li><li><code>bases</code>: 新类的父类列表</li><li><code>attrs</code>: 新类需要包含的属性和方法字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br><span class="hljs-comment"># super(): 这个函数用于调用父类的函数或方法.这里,super()用于调用默认元类type的__new__()方法</span><br><span class="hljs-comment"># __new__(): 这是元类type的一个特殊方法,用于创建新的类对象</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">因此这行代码的的具体作用是:</span><br><span class="hljs-string">1. 调用父类type的__new__()方法: 因为我们继承自type类,需要使用父类的机制来创建新类</span><br><span class="hljs-string">2. 传递参数: 传递元类MyMeta自身(cls), 新类名称(name),新类父列表(bases)和新类属性和方法字典(attrs)到父类的__new__()方法中</span><br><span class="hljs-string">3. 返回新类对象: 父类__new__()方法最终返回一个新的类对象</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用<code>metaclass</code>参数来指定自定义元类创建类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br></code></pre></td></tr></table></figure><p><code>MyClass</code>使用<code>MyMeta</code>元类创建.<code>MyMeta</code>的<code>__new__()</code>方法将被调用,并能修改<code>MyClass</code>的属性和行为.</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>元类虽然不是最常见的编程技巧，但它在一些特定场景下能发挥强大的作用，提升代码的可维护性和可扩展性.</p><blockquote><p>比如你在开发一个大型电商平台,需要管理各种商品类型,比如衣服,书籍,电子产品等,每个都有特定的属性和行为,比如衣服需要尺寸,颜色等属性,书记需要作者,出版社等</p><ul><li><p>传统方式:</p><p>分别定义各种类,比如<code>Clothing</code>,<code>Book</code>,<code>Electronics</code></p><p>每个类都有各自的属性和方法,代码架构会变大且难以维护</p></li><li><p>使用元类</p><p>定义一个元类<code>ProductMeta</code>,用于创建商品类型的类</p><p><code>ProductMeta</code>可以接受商品类型的属性和方法作为参数,并根据这些参数动态创建类</p><p>这样,我们可以用一种通用的方式来定义商品类型,避免重复代码,并更容易添加新的商品类型</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        attrs[<span class="hljs-string">&#x27;get_product_info&#x27;</span>] = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>: <span class="hljs-string">f&quot;Product name: <span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>(metaclass=ProductMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.price = price<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clothing</span>(<span class="hljs-title class_ inherited__">Product</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price, size, color</span>):<br>        <span class="hljs-built_in">super</span>().__inti__(name, price):<br>            <span class="hljs-variable language_">self</span>.size = size<br>            <span class="hljs-variable language_">self</span>.color = color<br>            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(<span class="hljs-title class_ inherited__">Product</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price, author, publisher</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, price)<br>        <span class="hljs-variable language_">self</span>.author = author<br>        <span class="hljs-variable language_">self</span>.publisher = publisher<br>    <br><span class="hljs-comment"># 使用</span><br>clothing = Clothing(<span class="hljs-string">&quot;T-shirt&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Red&quot;</span>)<br>book = Book(<span class="hljs-string">&quot;The Hitchhiker&#x27;s Guide to the Galaxy&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;Douglas Adams&quot;</span>, <span class="hljs-string">&quot;Pan Books&quot;</span>)<br><br><span class="hljs-built_in">print</span>(clothing.get_product_info())  <span class="hljs-comment"># Output: Product name: Clothing</span><br><span class="hljs-built_in">print</span>(book.get_product_info())  <span class="hljs-comment"># Output: Product name: Book</span><br></code></pre></td></tr></table></figure><blockquote><p>这里,直接使用元类创建具体商品类也是可行的,但是中间添加一层Product中间类有以下优点:</p><ol><li>代码组织性: 将<code>Product</code>作为基类,可以将所有商品类型代码组织在一起,形成更清晰的层次结构,便于理解和维护</li><li>代码复用: <code>Product</code>类可以包含所有商品类共有的属性和方法,提高代码复用性</li><li>扩展性: 如果将来需要添加新商品,只需要继承<code>Product</code>类,并实现具体的属性和方法即可</li><li>类型安全: 所有商品类都继承<code>Product</code>保证所有商品类都拥有共同的接口,提高代码的类型安全和可维护性</li></ol></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/python/" class="print-no-link">#python</a></div></div><div class="license-box my-3"><div class="license-title"><div>python-面向对象高级特性</div><div>http://example.com/2024/02/24/python-oop-advance/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年2月24日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/03/20/AWS-SAP/" title="AWS-SAP-MustKnow"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">AWS-SAP-MustKnow</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/02/22/ansible-mustknow/" title="ansible-必知必会"><span class="hidden-mobile">ansible-必知必会</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>