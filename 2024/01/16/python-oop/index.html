<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><link rel="icon" href="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206120024516.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Peter Pan"><meta name="keywords" content=""><meta name="description" content="面向对象 面向对象这一个概念来源于自然界     自然界 编程    person person 类   身高&#x2F;年龄&#x2F;体重 类的属性   某一个人(Peter) 类的实例   人可以做什么 类的方法    面向对象的程序设计把计算机程序视为一组对象的集合,每个对象都可以接受其他对象发过来的消息,并处理这些消息. 计算机程序的执行就是一系列消息在各个对象之间传递. 在python"><meta property="og:type" content="article"><meta property="og:title" content="python笔记-面向对象编程"><meta property="og:url" content="http://example.com/2024/01/16/python-oop/index.html"><meta property="og:site_name" content="Any &amp; Nothing"><meta property="og:description" content="面向对象 面向对象这一个概念来源于自然界     自然界 编程    person person 类   身高&#x2F;年龄&#x2F;体重 类的属性   某一个人(Peter) 类的实例   人可以做什么 类的方法    面向对象的程序设计把计算机程序视为一组对象的集合,每个对象都可以接受其他对象发过来的消息,并处理这些消息. 计算机程序的执行就是一系列消息在各个对象之间传递. 在python"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta property="article:published_time" content="2024-01-16T07:54:12.000Z"><meta property="article:modified_time" content="2024-12-11T09:52:23.058Z"><meta property="article:author" content="Peter Pan"><meta property="article:tag" content="python"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cpython-for-beginners.webp"><meta name="referrer" content="no-referrer-when-downgrade"><title>python笔记-面向对象编程 - Any &amp; Nothing</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:["home"]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Any & Nothing" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Any &amp; Nothing</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">python笔记-面向对象编程</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-01-16 15:54" pubdate>2024年1月16日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 31 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">python笔记-面向对象编程</h1><div class="markdown-body"><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote><p>面向对象这一个概念来源于自然界</p></blockquote><table><thead><tr><th>自然界</th><th>编程</th></tr></thead><tbody><tr><td>person</td><td>person 类</td></tr><tr><td>身高&#x2F;年龄&#x2F;体重</td><td>类的属性</td></tr><tr><td>某一个人(Peter)</td><td>类的实例</td></tr><tr><td>人可以做什么</td><td>类的方法</td></tr></tbody></table><blockquote><p>面向对象的程序设计把计算机程序视为一组<code>对象</code>的集合,每个对象都可以接受其他对象发过来的<code>消息</code>,并处理这些<code>消息</code>.</p><p>计算机程序的执行就是<code>一系列消息在各个对象之间传递</code>.</p><p>在python中,所有数据类型都是对象.</p><p><code>自定义对象数据类型</code>就是面向对象中的<code>类(Class)</code>.</p></blockquote><h1 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h1><p>比如要展示一个学生的成绩:</p><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 学生的成绩数据可以用dict表示</span><br>std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br><span class="hljs-comment"># 处理学生成绩则通过函数实现</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;std[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>: <span class="hljs-subst">&#123;std[<span class="hljs-string">&quot;score&quot;</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h2><p>我们首先思考的不是程序执行的流程,而是<code>Student</code>这种数据类型应该被视作一个<code>对象</code>,这个对象拥有<code>name</code>和<code>score</code>这两个<code>属性(Property)</code>.</p><p>如果要打印一个学生的成绩,我们首先要创建出这个学生对应的对象,然后给对象发一个<code>print_score</code>的消息,让<code>对象自己</code>把成绩打印出来.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span>: <span class="hljs-subst">&#123;self.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面说的给对象发消息,就是调用对象对应的关联函数(<code>方法Method</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><blockquote><p>面向对象的抽象程度比函数高,一个Class既包含数据也包含操作数据的方法.</p></blockquote><h1 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h1><blockquote><p><code>类</code>是抽象的模板,<code>实例</code>是具体的对象.</p></blockquote><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>通过关键字<code>class</code>定义一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><blockquote><p><code>class</code> 后面跟类名,<code>类名</code>通常使用驼峰命名.<br><code>(object)</code>表示<code>父类(从哪个类继承下来)</code>,如果没有合适的<code>继承类</code>就使用<code>object</code>类,这是所有类最终都会继承的类.</p><p><code>(object)</code>表示继承根类,如果是继承根类,可以直接忽略不写.</p></blockquote><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>类名+<code>()</code>创建实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student()<br>bart<br><span class="hljs-comment"># 变量bart指向一个Student实例对象,后面的0x10a67a590是内存地址,每个object地址都不一样</span><br>&gt; &lt;__main__.Student <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a67a590</span>&gt;<br>Student<br><span class="hljs-comment"># Student本身则是一个类</span><br>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Student&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="给实例绑定属性"><a href="#给实例绑定属性" class="headerlink" title="给实例绑定属性"></a>给实例绑定属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bart.name = <span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="初始化属性"><a href="#初始化属性" class="headerlink" title="初始化属性"></a>初始化属性</h2><blockquote><p>由于类起到<code>模板</code>的作用,在创建类时,我们可以把一些我们认为必须<code>绑定</code>的属性强制填写进去,通过<code>__init__</code>方法.</p><p>这个特殊方法有时也叫<code>初始化属性</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span>: <span class="hljs-subst">&#123;self.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init</strong>()</h2><blockquote><p><code>__init__()</code> 方法是Python中类的特殊方法之一，用于在创建类的实例时进行初始化操作。它是一个构造方法，负责在对象被创建时设置对象的初始状态。当你创建一个类的实例时，Python会自动调用该类的 <code>__init__()</code> 方法，如果该方法在类中被定义的话。这允许你在对象创建时执行任何必要的初始化工作。<code>__init__()</code>方法在<code>实例创建时自动调用,用于执行初始化任务</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, param1, param2</span>):<br>        <span class="hljs-variable language_">self</span>.param1 = param1<br>        <span class="hljs-variable language_">self</span>.param2 = param2<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Object initialized with parameters:&quot;</span>, param1, param2)<br>        <br><span class="hljs-comment"># __init__()在创建实例时就会执行</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_object = MyClass(<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>)<br>Object initialized <span class="hljs-keyword">with</span> parameters: value1 value2<br></code></pre></td></tr></table></figure><p><code>__init__</code>方法第一个参数永远是<code>self</code>,表示创建的<code>实例本身</code>.这样在<code>__init__</code>方法内部就可以把各种属性绑定到<code>self</code>,<code>self</code>指向创建的实例本身.</p><p>有了<code>__init__</code>,在创建实例时,就<code>不能传空参数</code>,必须传入跟<code>__init__</code>匹配的参数,<code>self</code>不需要传,python解释器会自己把实例变量传进去.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.score<br><span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p>在类中定义的函数(<code>方法</code>),第一个参数永远是<code>self</code>,调用时不用传递<code>self</code>,除此以外,和普通函数没有区别.</p><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><blockquote><p>比如上面的<code>Student</code>类,每个实例都拥有<code>name</code>,<code>score</code>这些数据.</p><p><code>Student</code>实例本身就拥有这些数据,要访问这些数据,没有必要通过外部函数读取,可以直接在<code>Student</code>类的内部定义访问数据的函数.</p><p>这个就叫<code>数据封装</code>,数据和逻辑被“封装”起来了,调用很容易,但却不用知道内部实现的细节.</p><p>封装数据的函数与类本身关联起来,称作类的<code>方法</code>.</p></blockquote><h2 id="实例绑定数据"><a href="#实例绑定数据" class="headerlink" title="实例绑定数据"></a>实例绑定数据</h2><p>Python运行<code>实例</code>绑定新的数据,即使类没有定义的数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>bart.score<br>&gt; <span class="hljs-number">59</span><br>bart.age = <span class="hljs-number">8</span><br>bart.age<br>&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h1 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h1><p>上面的例子中,外部的代码可以自由地修改一个实例的<code>name</code>,<code>score</code>属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>bart.score<br>&gt; <span class="hljs-number">59</span><br>bart.score = <span class="hljs-number">99</span><br>bart.score<br>&gt; <span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>如果想让内部属性不被外部访问,在属性名前加<code>__</code>,代表<code>私有变量(private)</code>,外部就不能访问.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.__name = name<br>        <span class="hljs-variable language_">self</span>.__score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.__name, <span class="hljs-variable language_">self</span>.__score))<br>        <br><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__score<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__name&#x27;</span> <br></code></pre></td></tr></table></figure><blockquote><p>这样外部代码就不能随意修改对象内部的状态,通过访问限制的保护,代码更健壮.</p></blockquote><p>如果外部代码要获取内部属性,可以给student类增加<code>get_name</code>和<code>get_score</code>等方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__score<br></code></pre></td></tr></table></figure><p>如果又要允许外部代码修改内部属性呢?<code>Best practise</code>是额外写一个方法去修改,因为在方法中,我们可以对参数做检查,<code>避免传入无效参数</code>,代码更健壮.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_score</span>(<span class="hljs-params">self, score</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= score &lt;= <span class="hljs-number">100</span>:<br>            <span class="hljs-variable language_">self</span>.__score = score<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;bad score&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><code>__xxx__</code>双下划线开头和结尾的<code>变量</code>是特殊变量,<code>特殊变量</code>可以直接访问,不是private.</p></li><li><p><code>_xxx</code>单下划线开头的变量意思是<code>虽然我可以被外部访问，但是，请把我视为私有变量，不要随意访问</code>.</p></li><li><p><code>__xxx</code>双下划线开头的变量是私有变量,但是它实际上是通过python解释器,把<code>__xxx</code>改成了<code>__Student__xxx</code>,实际上还是可以访问的.所以Python并没有强制的访问控制手段,一切全靠自觉.</p></li></ul><p>注意:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name = <span class="hljs-string">&#x27;New Name&#x27;</span> <span class="hljs-comment"># 设置__name变量！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br><span class="hljs-string">&#x27;New Name&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><p>表面上好像是访问了<code>__name</code>并赋了新值,但实际上是创建了一个<code>__name</code>的新属性,因为原来的<code>__name</code>属性已经被python解释器改为了<code>__Student__name</code>.</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><code>Dog</code>和<code>Cat</code>继承自<code>Animal</code>,所以Animal是Dog和Cat的<code>父类</code>,后者则是前者的<code>子类</code>.</p><ul><li>子类将获得父类的所有方法</li><li>子类可以自己<code>增加或者重写</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">dog = Dog()<br>dog.run()<br>&gt; Animal <span class="hljs-keyword">is</span> running...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Eating meat...&#x27;</span>)<br>        <br>dog.run()<br>&gt; Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当子类和父类都有同样的方法时,我们说子类<code>覆盖</code>父类的方法,也叫<code>重写</code>.</p><p>继承可以一级一级地继承下去,<code>object</code>是所有类的<code>根类</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    object     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Animal    │           │    Plant    │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>首先我们需要理解:定义一个class,实际上是定义了一个新的<code>数据类型</code>,它跟python自身的list, str, dict 等数据类型一样.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>()<br>b = Animal()<br>c = Dog()<br><span class="hljs-comment"># 判断一个变量是否为某个类型用isinstance()</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">list</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Dog)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>然后你会发现,<code>c</code>也是Animal类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>所以,继承关系中,如果一个<code>实例</code>的数据类型是某个<code>子类</code>,那么它也同时属于<code>父类</code>.当然,反过来是不行的.</p><p>一个实例同时属于多个数据类,这就叫<code>多态</code>.</p><p>举个例子说明多态的好处:</p><p>定义一个<code>run_twice</code>函数,接受<code>Animal</code>类型的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">Animal</span>):<br>    Animal.run()<br>    Animal.run()<br></code></pre></td></tr></table></figure><p>此时,因为<code>Dog()</code>,<code>Cat()</code>也是属于<code>Animal</code>,所以可以直接传入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>也可以再定义一个<code>Tortoise</code>类,同样继承于<code>Animal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tortoise</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Tortoise is running slowly...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>同样可以直接传入并调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Tortoise())<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br></code></pre></td></tr></table></figure><blockquote><p>多态的好处就是每新增一个<code>子类</code>,任何依赖其<code>父类</code>作为参数的函数或方法都可以<code>不加修改地正常运行</code>.</p><p>以上面的例子来说,不管我们传入的是<code>Dog</code>,<code>Cat</code>,<code>Tortoise</code>还是别的任意<code>Animal</code>子类,<code>run_twice</code>都能不加修改地正常运行.</p><p>对于一个变量,我们只需知道它是<code>Animal</code>类型,无需确切知道它的子类,就能放心调用<code>run()</code>方法.</p><p>调用方只管调用,不管细节,这就是著名的<code>开闭原则</code>:</p><ul><li>对扩展开放: 允许新增<code>Animal</code>子类</li><li>对修改封闭: 不需要修改依赖<code>Animal</code>类型的<code>run_twice</code>函数</li></ul></blockquote><h1 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h1><p>有别于<code>静态语言</code>(Java),对于<code>动态语言</code>(python)来说,它其实并不要求严格的<code>继承关系</code>, 一个对象只要<code>开起来像鸭子,走起路来像鸭子</code>,就可以被看作鸭子.</p><p>这就是动态语言的<code>鸭子类型</code>:</p><blockquote><p>如果需要传入<code>Animal</code>类型.传入的对象并不一定要<code>Animal</code>或它的<code>子类</code>,只要传入的对象又<code>run()</code>方法就行.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_it_walk</span>(<span class="hljs-params">duck</span>):<br>    duck.walk() <span class="hljs-comment"># 只要传入的对象有walk方法,就能执行,不需要管到底传入哪个class</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This duck is walking&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This person is walking&quot;</span>)<br><br>duck = Duck()<br>person = Person()<br><br>make_it_walk(duck)   <span class="hljs-comment"># 输出: This duck is walking</span><br>make_it_walk(person) <span class="hljs-comment"># 输出: This person is walking</span><br></code></pre></td></tr></table></figure><h1 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h1><blockquote><p>当我们拿到一个对象的引用时,如何知道这个对象是什么类型?有那些方法呢?</p></blockquote><h2 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h2><p>用于判断对象类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 基本类型</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;str&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)<br>&lt;<span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>) <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;<br><span class="hljs-comment"># 函数或类</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Animal&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p><code>type()</code>函数返回对应的Class类型,可以通过<code>if</code>语句比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>判断是否为函数,可以使用<code>types</code>模块定义的常量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> types<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">type</span>(fn) == types.FunctionType<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>) == types.BuiltinFunctionType<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x) == types.LambdaType<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))) == types.GeneratorType<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h2><p>判断class的类型,和继承关系可以使用<code>isinstance()</code></p><p>还是上面的例子,如果继承关系是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">object -&gt; Animal -&gt; Dog -&gt; Husky<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先创建实例</span><br>a = Animal()<br>d = Dog()<br>h = Husky()<br><br><span class="hljs-comment"># 判断</span><br><span class="hljs-built_in">isinstance</span>(h, Husky)<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">isinstance</span>(h, Dog)<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">isinstance</span>(h, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>能用type判断的基本类型也可以用isinstance判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>还可以判断<code>是否为某些类型中的一种</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><blockquote><p>优先使用<code>isinstance</code>判断类型,可以将指定类型及其子类一网打尽</p></blockquote><h2 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h2><p>获取一个对象的所有<code>属性</code>和<code>方法</code>, 返回一个包含字符串的list.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>类似<code>__xxx__</code>的属性和方法再python中都是有特殊用途的,比如<code>__len__</code>方法返回长度.</p><p>如果你调用<code>len()</code>函数获取一个对象的函数,实际上,在<code>len()</code>函数内部是去调用该对象的<code>__len__()</code>方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如下两段代码等价</span><br><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__()<br></code></pre></td></tr></table></figure><p>如果是我们自己写的类,如果也想调用<code>len(myObj)</code>,就要自己写一个<code>__len__()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDog</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>d = MyDog()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(d)<br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>其余的都是普通的属性或方法.</p><h2 id="操作对象属性"><a href="#操作对象属性" class="headerlink" title="操作对象属性"></a>操作对象属性</h2><p><code>getattr()</code>获取对象属性</p><p><code>setattr()</code>设置对象属性</p><p><code>hasattr()</code>判断对象属性是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.x = <span class="hljs-number">9</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.x * <span class="hljs-variable language_">self</span>.x<br>    <br>obj = MyObject()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.x<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">19</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-number">19</span><br><br><span class="hljs-comment"># 获取不存在的属性会报错</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;MyObject&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;z&#x27;</span><br><span class="hljs-comment"># 也可以设定不存在时候返回的值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">404</span>)<br><span class="hljs-number">404</span><br></code></pre></td></tr></table></figure><p>也可以获取对象的方法,在python中,对象的<code>方法</code>也同样属于对象的<code>属性</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>)<br>&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10077a6a0</span>&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>fn = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fn() <span class="hljs-comment"># 等价于obj.power()</span><br><span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>一般来说,如果我们只有在不知道对象信息的时候,才会去获取, 如果可以直接写<code>obj.x</code>就不要写<code>getattr(obj, &#39;s&#39;)</code>.正确的用法例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readImage</span>(<span class="hljs-params">fp</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(fp, <span class="hljs-string">&#x27;read&#x27;</span>):<br>        <span class="hljs-keyword">return</span> readData(fp)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><blockquote><p>python是动态语言,根据鸭子类型,有<code>read()</code>方法,也不代表它就是一个文件流,但只要<code>read()</code>方法返回的是有效的图像数据,就不影响读取图像的功能.</p></blockquote><h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><p>python是动态语言,根据类创建的实例可以任意绑定属性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name <span class="hljs-comment"># 通过self变量绑定</span><br>        <br>s = Student(<span class="hljs-string">&#x27;Bob&#x27;</span>)<br>s.score = <span class="hljs-number">90</span> <span class="hljs-comment"># 通过实例变量绑定</span><br></code></pre></td></tr></table></figure><p>上面通过两种方式定义的是<code>实例属性</code></p><p>下面定义的是<code>类属性</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br></code></pre></td></tr></table></figure><p>两个属性的调用有所不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 打印实例属性, 因为实例没有name属性,所以会打印类属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 打印类属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Peter&#x27;</span> <span class="hljs-comment"># 绑定实例属性name</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 打印实例属性</span><br>Peter<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 打印类属性</span><br>Student<br></code></pre></td></tr></table></figure><blockquote><p><code>实例属性</code>优先级比<code>类属性</code>高,如果定义了相同名字的实例属性于类属性,将会优先打印实例属性.</p><p>所以千万不要用相同的名字.</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Coder/" class="category-chain-item">Coder</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/python/" class="print-no-link">#python</a></div></div><div class="license-box my-3"><div class="license-title"><div>python笔记-面向对象编程</div><div>http://example.com/2024/01/16/python-oop/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Peter Pan</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年1月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/01/30/aigc-AIpainting/" title="AIGC-AI绘画"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">AIGC-AI绘画</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/01/10/python-module/" title="python笔记-模块"><span class="hidden-mobile">python笔记-模块</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>