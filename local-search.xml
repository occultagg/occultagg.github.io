<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NodeJS</title>
    <link href="/2024/11/21/nodeJS/"/>
    <url>/2024/11/21/nodeJS/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411211719072.webp" srcset="/img/loading.gif" lazyload></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>安装运行和环境配置就不说了,因为都很简单.</p><p>与python类似,也有内置模块和第三方模块.模块主要是一个代码复用方案,而且可以避免函数名和变量名冲突.</p><p>比如写这么一个<code>hello.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s + <span class="hljs-string">&#x27;, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = greet; <span class="hljs-comment">// 这一行是模块的关键</span><br></code></pre></td></tr></table></figure><p><code>module.exports = greet;</code>: 把<code>greet()</code>函数作为模块的输出暴露出去,这样子,其他模块就能使用<code>greet()</code>了.</p><p>在<code>main.js</code>中调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">const</span> greet = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./hello&#x27;</span>);<span class="hljs-comment">// node提供的require函数</span><br><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Michael&#x27;</span>;<br><br><span class="hljs-title function_">greet</span>(s); <span class="hljs-comment">// Hello, Michael!</span><br></code></pre></td></tr></table></figure><p><code>const greet = require(&#39;./hello&#39;);</code>: 引入的模块作为变量保存在<code>greet</code>中,其实变量<code>greet</code>就是在<code>hello.js</code>中用<code>module.exports = greet;</code>导出的<code>greet函数</code>.</p><p>引入模块时候,注意模块的相对路径,如果只写模块名,node会依次在内置模块,全局模块和当前模块下查找.如果找不多会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">module.js<br>    throw err;<br>          ^<br>Error: Cannot find module &#x27;hello&#x27;<br>    at Module._resolveFilename<br>    ...<br></code></pre></td></tr></table></figure><h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>上面的这种模块加载机制称为CommonJS规范,在这种规范下,每个<code>.js</code>文件都是一个模块,不同模块内部的变量名和函数名都不冲突.</p><p>一个模块想要对外暴露变量(函数也是变量),用<code>module.exports = variable</code></p><p>想要引用其他模块暴露的变量,用<code>var ref = require(&#39;module_name&#39;)</code></p><h2 id="模块原理"><a href="#模块原理" class="headerlink" title="模块原理"></a>模块原理</h2><p>当我们编写JS代码时,可以申明全局变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;global&#x27;</span>;<br></code></pre></td></tr></table></figure><p>但是,大量定义全局变量肯定不好,容易造成冲突.在ESM之前,<code>a.js</code>和<code>b.js</code>中如果定义了相同的全局变量,是会造成冲突的.</p><p>为了避免这个冲突,node.js利用了JS的闭包.如果我们把一段JS代码用一个函数包装起来,这段代码的所有<code>全局</code>变量就会变成函数内部的<code>局部</code>变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如我们编写的hello.js是这样的</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;world&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s + <span class="hljs-string">&#x27; &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br><br><span class="hljs-comment">// node.js加载后会把它变成这样</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 读取的hello.js代码:</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;world&#x27;</span>;<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s + <span class="hljs-string">&#x27; &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    <span class="hljs-comment">// hello.js代码结束</span><br>&#125;)(); <span class="hljs-comment">// 立即调用函数表达式(IIFE)&quot;(function() &#123; ... &#125;)&quot;定义一个匿名函数,最后的&quot;()&quot;会立即调用这个函数</span><br></code></pre></td></tr></table></figure><p>这样子就实现了变量的隔离.</p><p>模块的输出<code>module.exports</code>实现靠的是一个对象<code>module</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 准备module对象:</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span> = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>    <span class="hljs-attr">exports</span>: &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">let</span> load = <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) &#123;<br>    <span class="hljs-comment">// 读取的hello.js代码:</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + name + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>    <br>    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = greet;<br>    <span class="hljs-comment">// hello.js代码结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;<br>&#125;;<br><span class="hljs-keyword">let</span> exported = <span class="hljs-title function_">load</span>(<span class="hljs-variable language_">module</span>);<br><span class="hljs-comment">// 保存module:</span><br><span class="hljs-title function_">save</span>(<span class="hljs-variable language_">module</span>, exported);<br></code></pre></td></tr></table></figure><p>变量<code>module</code>是node在加载js文件前准备的一个变量,并将其传入加载函数.所以我们在<code>hello.js</code>中可以直接使用变量<code>module</code>.因为它实际上是函数的一个参数.</p><p><code>load()</code>函数把<code>module</code>变量传递给了node执行环境,node把它保存在某个地方.</p><p>由于Node保存了所有导入的<code>module</code>,当我们用<code>require()</code>获取module时,Node找到对应的module,把这个<code>module</code>的<code>exports</code>变量返回,这样另一个模块就能拿到模块的输出.</p><p>不过这个,看看就行了,现代JS开发中都是用ESM.</p><h1 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h1><p>Node.js一开始就支持模块,但那并不是JS原生的功能,只能算是一种<code>模拟</code>.</p><p>ES6后,原生JS终于有了原生内置的模块支持,称为ECMAScript Modules(ESM),不仅可以直接在浏览器中使用模块,也可以在Node.js中使用ESM模块.</p><p>另外ES6后使用模块,会自动使用严格模式,所以并不需要显示写<code>use strict;</code></p><h2 id="普通导入导出"><a href="#普通导入导出" class="headerlink" title="普通导入导出"></a>普通导入导出</h2><p><code>export</code>关键字标识需要导出的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-comment">// out 是模块内部函数,模块外部不可见</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">out</span>(<span class="hljs-params">prompt, name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;prompt&#125;</span>, <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>&#125;<br><span class="hljs-comment">// greet是导出函数,可被外部调用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-title function_">out</span>(s, name);<br>&#125;<br><span class="hljs-comment">// hi也是导出函数,可被外部调用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">hi</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-title function_">out</span>(<span class="hljs-string">&#x27;Hi&#x27;</span>, name);<br>&#125;<br></code></pre></td></tr></table></figure><p>将该文件保存为<code>hello.mjs</code>,<strong>注意</strong>后缀是<code>.mjs</code>,不过这个不是强制的.</p><blockquote><p>在node.js中有三种方式使用ESM:</p><ol><li><p>使用<code>.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// math.mjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-comment">// main.mjs</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.mjs&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>在<code>package.json</code>中设置<code>&quot;type&quot;: &quot;module&quot;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// package.json</span><br>&#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;module&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 然后就可以使用 .js 结尾</span><br><span class="hljs-comment">// math.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>如果在<code>package.json</code>中没有设置<code>type</code>,就要使用<code>.mjs</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为package.json中默认&quot;type&quot;: &quot;commonjs&quot;</span><br><span class="hljs-comment">// 此时需要使用.mjs</span><br><span class="hljs-comment">// math.mjs</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) =&gt; a + b;<br></code></pre></td></tr></table></figure></li></ol></blockquote><p>再写一个<code>main.mjs</code>来调用<code>hello</code>模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; greet, hi &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.mjs&#x27;</span>; <span class="hljs-comment">// 导入</span><br><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Bob&#x27;</span>;<br><span class="hljs-title function_">greet</span>(name); <span class="hljs-comment">// 直接调用</span><br><span class="hljs-title function_">hi</span>(name); <br></code></pre></td></tr></table></figure><h2 id="默认导入导出"><a href="#默认导入导出" class="headerlink" title="默认导入导出"></a>默认导入导出</h2><p>当一个模块主要提供一个功能时,使用默认导入导出更方便</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用export default关键字</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">neme</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用时就不用&#123;&#125;</span><br><span class="hljs-keyword">import</span> greet <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./hello.js&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="重命名导入"><a href="#重命名导入" class="headerlink" title="重命名导入"></a>重命名导入</h2><p>为了避免模块命名冲突,可以用<code>as</code>重命名(别名)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; add <span class="hljs-keyword">as</span> sum, subtract <span class="hljs-keyword">as</span> minus &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math.js&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));    <span class="hljs-comment">// 使用 sum 代替 add</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">minus</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));  <span class="hljs-comment">// 使用 minus 代替 subtract</span><br></code></pre></td></tr></table></figure><h2 id="浏览器加载ESM"><a href="#浏览器加载ESM" class="headerlink" title="浏览器加载ESM"></a>浏览器加载ESM</h2><p>浏览器也可以直接使用ESM</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./example.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> /<span class="hljs-comment">&lt;!-- 加载是需要写上`type=&quot;module&quot;` --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml">  <span class="hljs-comment">&lt;!-- 调用 --&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars">        greet(&#x27;Bob&#x27;);</span></span><br><span class="language-xml"><span class="language-handlebars">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">import</span> &#123; greet &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.js&#x27;</span>; <span class="hljs-comment">// 直接import和调用</span></span><br><span class="language-javascript">        <span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h2><p>列一下node.js常用基本模块</p><ul><li><code>fs</code>: 文件系统模块,负责文件读写,同时提供了同步和异步的方法</li><li><code>stream</code>: 提供流式数据的支持</li><li><code>http</code>: 用JS编写web服务器程序</li><li><code>crypto</code>: 提供通用的加密和哈希算法.这些功能如果用JS实现会非常慢,所以node.js用c&#x2F;c++实现后,通过crypto这个模块暴露为JS接口,方便使用.</li></ul><h1 id="node-js项目"><a href="#node-js项目" class="headerlink" title="node.js项目"></a>node.js项目</h1><p>整理一下node项目常用命令和文件</p><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化项目, 创建package.json</span><br>npm init # 交互式创建<br>npm init -y # 使用默认配置快速创建<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置npm配置</span><br>npm config set registry https://registry.npmmirror.com  # 设置淘宝镜像<br>npm config get registry # 查看当前镜像<br></code></pre></td></tr></table></figure><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>npm install     # 安装 package.json 中所有依赖<br>npm i           # npm install 的简写<br><br>npm i package-name  # 安装指定包<br>npm i package-name@version  # 安装指定版本<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖并保存到不同依赖类型</span><br>npm i package-name --save        # 生产依赖 (-S 简写)<br>npm i package-name --save-dev    # 开发依赖 (-D 简写)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">全局安装</span><br>npm i package-name -g   # 全局安装某个包<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除依赖</span><br>npm uninstall package-name  # 删除指定包<br>npm uninstall -g package-name  # 删除全局包<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新依赖</span><br>npm update package-name  # 更新指定包<br>npm update              # 更新所有包<br></code></pre></td></tr></table></figure><h2 id="项目运行相关"><a href="#项目运行相关" class="headerlink" title="项目运行相关"></a>项目运行相关</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">运行 package.json 中定义的脚本</span><br>npm run script-name  # 运行指定脚本<br>npm start           # 运行 start 脚本的简写<br>npm test            # 运行 test 脚本的简写<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br>npm ls              # 查看安装的依赖树<br>npm ls package-name # 查看指定包的依赖关系<br>npm outdated        # 检查过时的包<br></code></pre></td></tr></table></figure><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;my-project&quot;</span><span class="hljs-punctuation">,</span>       <span class="hljs-comment">// 项目名</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 版本号</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>         <span class="hljs-comment">// 项目描述</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 入口文件</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>               <span class="hljs-comment">// 可运行的脚本</span><br>    <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vite build&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jest&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;lint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;eslint .&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>          <span class="hljs-comment">// 生产依赖</span><br>    <span class="hljs-attr">&quot;react&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^18.2.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// ^ 表示兼容补丁和小版本更新</span><br>    <span class="hljs-attr">&quot;react-dom&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;~18.2.0&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// ~ 表示只兼容补丁更新</span><br>    <span class="hljs-attr">&quot;package3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.2.3&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      <span class="hljs-comment">// 开发依赖</span><br>    <span class="hljs-attr">&quot;vite&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;jest&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^29.0.0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="重要文件和路径"><a href="#重要文件和路径" class="headerlink" title="重要文件和路径"></a>重要文件和路径</h2><ol><li><code>package-lock.json</code> - 依赖锁定文件</li></ol><ul><li>锁定依赖的具体版本</li><li>应该提交到代码仓库</li><li>保证团队所有成员使用相同版本的依赖</li></ul><ol start="2"><li><code>node_modules/</code> - 依赖包安装目录</li></ol><ul><li>不需要提交到代码仓库</li><li>可以通过 <code>npm install</code> 重新生成</li></ul><ol start="3"><li><p><code>.npmrc</code> - npm 配置文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">registry</span>=https://registry.npmmirror.com<br><span class="hljs-attr">sass_binary_site</span>=https://npmmirror.com/mirrors/node-sass/<br></code></pre></td></tr></table></figure></li></ol><h2 id="常见部署流程"><a href="#常见部署流程" class="headerlink" title="常见部署流程"></a>常见部署流程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 安装依赖</span><br>npm install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 运行测试</span><br>npm test<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. 构建项目</span><br>npm run build<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">4. 运行项目（如果是服务器端渲染）</span><br>npm start<br></code></pre></td></tr></table></figure><h2 id="一些高级用法"><a href="#一些高级用法" class="headerlink" title="一些高级用法"></a>一些高级用法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清除缓存</span><br>npm cache clean --force<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看包信息</span><br>npm info package-name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查项目依赖问题</span><br>npm audit<br>npm audit fix  # 自动修复依赖问题<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行脚本时显示详细日志</span><br>npm run script-name --verbose<br></code></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开发环境运行</span><br>NODE_ENV=development npm run dev<br><br><span class="hljs-comment"># 生产环境构建</span><br>NODE_ENV=production npm run build<br><br><span class="hljs-comment"># CI流程</span><br>CI=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><ol><li>缓存<code>node_module</code>目录以加快构建</li><li>使用<code>CI=true</code>环境变量</li><li>保存构建产物</li><li>使用<code>npm ci</code>代替<code>npm install</code>在CI环境中安装依赖</li></ol><blockquote><p><code>NODE_ENV</code></p><p><code>development</code> 模式下:</p><ul><li>开启详细的调试信息和警告</li><li>不会进行代码压缩和优化</li><li>启用热重载(Hot Reload)</li><li>包含 source map</li><li>可能包含测试数据或模拟 API</li></ul><p><code>production</code> 模式下:</p><ul><li>关闭调试信息和警告</li><li>进行代码压缩和优化</li><li>移除开发时才需要的代码</li><li>不包含 source map (除非特别配置)</li><li>使用真实 API 地址</li></ul><hr><p><code>CI=true</code></p><p>表明在持续集成环境中运行</p><p>影响:</p><ul><li>禁用交互式输出</li><li>遇到错误立即退出</li><li>更严格的错误处理</li><li>禁用进度条显示</li><li>npm 会以最大日志级别运行</li></ul><hr><p><code>npm install</code></p><ul><li><p>根据 package.json 安装依赖</p></li><li><p>如果有 package-lock.json，会尽量遵循它</p></li><li><p>可能会更新 package-lock.json</p></li><li><p>可以安装单个包</p></li><li><p>会重用现有的 node_modules</p></li></ul><p><code>npm ci</code></p><ul><li><p>严格按照 package-lock.json 安装依赖</p></li><li><p>必须有 package-lock.json，否则报错</p></li><li><p>不会修改 package.json 和 package-lock.json</p></li><li><p>不能安装单个包</p></li><li><p>总是删除现有的 node_modules 后重新安装</p></li><li><p>通常比 <code>npm install</code> 快（因为跳过了一些计算和验证）</p></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node.Js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-错误处理</title>
    <link href="/2024/11/20/js-error/"/>
    <url>/2024/11/20/js-error/</url>
    
    <content type="html"><![CDATA[<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>错误分两种:</p><ol><li><p>程序逻辑写得不对,代码执行异常</p></li><li><p>执行过程中,程序可能遇到无法预测得异常情况而报错,例如网络连接中断,读取不存在的文件,没有操作权限等</p><p>对于这种错误,我们需要处理它,并可能需要反馈给用户</p></li></ol><p>对于C这种贴合系统底层的语言,错误是通过<code>错误码</code>返回的.</p><p>但是错误码在写代码时很不方便,所以高级语言使用更抽象的错误处理逻辑.</p><h2 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> r1, r2, s = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    r1 = s.<span class="hljs-property">length</span>; <span class="hljs-comment">// 这里会产生错误</span><br>    r2 = <span class="hljs-number">100</span>; <span class="hljs-comment">// 该语句不会执行</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出错了: &#x27;</span> + e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;r1 = &#x27;</span> + r1); <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;r2 = &#x27;</span> + r2); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">出错了：TypeError: Cannot read properties of null (reading &#x27;length&#x27;)<br>finally<br>r1 = undefined<br>r2 = undefined<br></code></pre></td></tr></table></figure><p>分析下<code>try...catch...finally</code>的执行顺序:</p><ol><li>先执行<code>try&#123;...&#125;</code>的代码</li><li>如果出错<ol><li>后续语句不再执行,直接跳转到<code>catch&#123;...&#125;</code>执行里面的代码</li></ol></li><li>如果没有出错<ol><li><code>catch&#123;...&#125;</code>则不会被执行</li></ol></li><li>最后执行<code>finally&#123;...&#125;</code>代码</li></ol><p>另外<code>catch&#123;...&#125;</code>和<code>finally&#123;...&#125;</code>可以都不出现</p><h2 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h2><ul><li><code>Error</code>: JS标准的错误对象,从它派生出来的有<ul><li><code>TypeError</code></li><li><code>ReferenceError</code></li><li>…</li></ul></li></ul><p>这些错误对象都可以通过<code>catch(e)</code>捕获到<code>e</code>变量中.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>    ...<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Type error!&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(e.<span class="hljs-property">message</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Error: &#x27;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然,<code>e</code>的命名没有固定,你可以随便.</p><h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><p>程序可以主动抛出错误,让执行流程直接跳转到<code>catch</code>块,使用<code>throw</code>语句抛出.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> r, n, s;<br><span class="hljs-keyword">try</span> &#123;<br>    s = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">&#x27;请输入一个数字&#x27;</span>);<br>    n = <span class="hljs-built_in">parseInt</span>(s);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(n)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;输入错误&#x27;</span>);<br>    &#125;<br>    r = n*n;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n + <span class="hljs-string">&#x27; * &#x27;</span> + n + <span class="hljs-string">&#x27; = &#x27;</span> + r);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;出错了: &#x27;</span> + e);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上,JS允许抛出任意对象,比如数字,字符串.不过最好还是抛出一个<code>Error</code>.</p><p>最后,<code>catch</code>中一定要写错误处理语句,哪怕只是把错误打印出来,也不要什么都不干.</p><p>另外处理错误时,不要简单粗暴地用<code>alert</code>显示给用户.</p><h1 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h1><p>当一个函数内部发生了错误,它自身没有捕获,错误就被抛到外层调用函数,如果外层调用函数也没有捕获,该错误会一直沿着函数调用链向上抛出,直到被JS引擎捕获,代码终止.</p><p>所以我们不必在每一个函数内部捕获错误,只需要在合适的地方统一捕捉.</p><p>至于在哪些地方捕捉错误更适合,需要视情况而定.</p><h1 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printTime</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;It is time!&#x27;</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(printTime, <span class="hljs-number">1000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;done&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面的代码会先打印<code>done</code>,一秒后才会打印<code>It is time!</code>.</p><p>此时如果使用<code>try</code>包裹<code>setTimeout</code>,而错误发生在<code>printTime</code>函数内部,<code>try...catch</code>是<strong>无法</strong>捕获到对应的错误的.</p><p>原因在于:</p><ul><li>调用<code>setTimeout()</code>时,传入的<code>printTime</code>函数不会马上执行.</li><li>JS引擎会先执行<code>console.log(&#39;done&#39;);</code>,此时并没有错误产生</li><li>一秒钟后再调用<code>printTime()</code>,但<code>printTime()</code>内部和外部都没有捕获错误的代码.</li></ul><p>类似的,当我们处理一个事件时,在绑定事件的代码处,无法捕获处理函数的错误.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 有以下表单 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;x&quot;</span>&gt;</span> + <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;y&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;calc&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>计算<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411201454977.png" srcset="/img/loading.gif" lazyload alt="image-20241120145428902"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> bin = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#calc&#x27;</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">querySelector(): 用于选择文档中匹配指定CSS选择器的第一个元素,如果没有就返回null</span><br><span class="hljs-comment">&#x27;#calc&#x27;: 这是一个 CSS 选择器，用于选择 ID 为 &quot;calc&quot; 的元素。# 符号表示 ID 选择器。</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-comment">// 取消已绑定的事件</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这个代码的作用是清除之前可能已经绑定到该按钮上的任何点击事件处理程序,这是一种确保只绑定一个特定事件处理程序的常见做法,避免意外的重估触发或行为冲突.</span><br><span class="hljs-comment">*/</span><br><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 注意try的位置,它应该在事件处理函数内部,才能捕获</span><br>        <span class="hljs-keyword">let</span> x = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#x&#x27;</span>).<span class="hljs-property">value</span>);<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-built_in">parseFloat</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#y&#x27;</span>).<span class="hljs-property">value</span>);<br>        <span class="hljs-keyword">let</span> r;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(x) || <span class="hljs-built_in">isNaN</span>(y)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;输入有误!&#x27;</span>);<br>        &#125;<br>        r = x + y;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;计算结果: &#x27;</span> + r);<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;输入有误！&#x27;</span> + (e.<span class="hljs-property">message</span> ? <span class="hljs-string">&#x27;: &#x27;</span> + e.<span class="hljs-property">message</span> : <span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-浏览器</title>
    <link href="/2024/11/15/js-browser/"/>
    <url>/2024/11/15/js-browser/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h1><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p><code>window</code>对象不但充当全局作用域,而且表示<code>浏览器窗口</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;window inner size: &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> + <span class="hljs-string">&#x27; x &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>)<br></code></pre></td></tr></table></figure><ul><li><code>innerWidth</code>&#x2F;<code>innerHeight</code>:浏览器窗口的内部宽度和高度</li><li>内部宽高是指,去掉菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高.</li><li>对应的有<code>outerWidth</code>&#x2F;<code>outerHeight</code>,是浏览器整个窗口的宽高</li></ul><h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p><code>navigator</code>对象表示浏览器信息,常用属性包括:</p><ul><li><code>navigator.appName</code>: 浏览器名称</li><li><code>navigator.appVersion</code>: 版本</li><li><code>navigator.language</code>: 语言</li><li><code>navigator.platform</code>: 操作系统类型</li><li><code>navigator.userAgent</code>: 浏览器设定的<code>User-Agent</code>字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;appName = &#x27;</span> + navigator.<span class="hljs-property">appName</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;appVersion = &#x27;</span> + navigator.<span class="hljs-property">appVersion</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;language = &#x27;</span> + navigator.<span class="hljs-property">language</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;platform = &#x27;</span> + navigator.<span class="hljs-property">platform</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;userAgent = &#x27;</span> + navigator.<span class="hljs-property">userAgent</span>);<br><br><span class="hljs-comment">// 输出</span><br>appName = <span class="hljs-title class_">Netscape</span><br>appVersion = <span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">130.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span><br>language = zh-<span class="hljs-variable constant_">CN</span><br>platform = <span class="hljs-title class_">Win32</span><br>userAgent = <span class="hljs-title class_">Mozilla</span>/<span class="hljs-number">5.0</span> (<span class="hljs-title class_">Windows</span> <span class="hljs-variable constant_">NT</span> <span class="hljs-number">10.0</span>; <span class="hljs-title class_">Win64</span>; x64) <span class="hljs-title class_">AppleWebKit</span>/<span class="hljs-number">537.36</span> (<span class="hljs-variable constant_">KHTML</span>, like <span class="hljs-title class_">Gecko</span>) <span class="hljs-title class_">Chrome</span>/<span class="hljs-number">130.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> <span class="hljs-title class_">Safari</span>/<span class="hljs-number">537.36</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>:<code>navigator</code>的值很容易被用户修改,所以JS读取出来的值不一定正确.另外很多初学者喜欢针对不同的浏览器写不同的代码,喜欢用<code>if</code>判断浏览器版本:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> width;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIEVersion</span>(navigator.<span class="hljs-property">userAgent</span>) &lt; <span class="hljs-number">9</span>) &#123;<br>    width =  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做既不能保证数据准确,也难以维护.<code>正确</code>的做法是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 利用JS对不存在属性返回undefined的特性,使用短路运算符||</span><br><span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span><br></code></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>表示屏幕的信息</p><ul><li><code>screen.width</code></li><li><code>screen.height</code></li><li><code>screen.colorDepth</code>: 颜色位数,比如8,16,24</li></ul><h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p>表示当前页面的URL信息,获取URL的个个部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例如一个完整的URL</span><br><span class="hljs-comment">// http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</span><br>location.<span class="hljs-property">href</span>; <span class="hljs-comment">// 获取整个URL</span><br>location.<span class="hljs-property">protocol</span>; <span class="hljs-comment">// &#x27;http&#x27;</span><br>location.<span class="hljs-property">host</span>; <span class="hljs-comment">// &#x27;www.example.com&#x27;</span><br>location.<span class="hljs-property">port</span>; <span class="hljs-comment">// &#x27;8080&#x27;</span><br>location.<span class="hljs-property">pathname</span>; <span class="hljs-comment">// &#x27;/path/index.html&#x27;</span><br>location.<span class="hljs-property">search</span>; <span class="hljs-comment">// &#x27;?a=1&amp;b=2&#x27;</span><br>location.<span class="hljs-property">hash</span>; <span class="hljs-comment">// &#x27;TOP&#x27;</span><br></code></pre></td></tr></table></figure><p>还有两个常用方法</p><p><code>location.reload()</code>: 重新加载当前页面</p><p><code>localtion.assign()</code>:加载一个新页面(当前页跳转)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&#x27;重新加载当前页&#x27;</span> + location.<span class="hljs-property">href</span> + <span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>    location.<span class="hljs-title function_">reload</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    location.<span class="hljs-title function_">assign</span>(<span class="hljs-string">&#x27;/&#x27;</span>); <span class="hljs-comment">// 设置一个新的URL地址</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p>这个对象表示当前页面.</p><p>由于HTML在浏览器中以<code>DOM</code>形式表示为树状结构,<code>document</code>对象就是整个DOM树的<code>根节点</code>.</p><blockquote><p><code>DOM</code>(document object model 文档对象模型)</p><p>DOM是一个编程接口,它将HTML或XML文档表示为一个树形结构,其中每个节点代表文档的一部分.</p><p>这样可以让开发者通过编程方式来访问和修改文档的内容,结构和样式.</p><p>比如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在DOM中就会表示为:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">document<br>  └── html<br>      ├── head<br>      │   └── title<br>      │       └── &quot;我的页面&quot;<br>      └── body<br>          ├── h1<br>          │   └── &quot;欢迎&quot;<br>          └── p<br>              └── &quot;这是一个段落&quot;<br></code></pre></td></tr></table></figure></blockquote><p>比如<code>document</code>的<code>title</code>属性是从HTML的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的,但是可以动态改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;好好学习,天天向上!&#x27;</span>;<br></code></pre></td></tr></table></figure><p>要查找DOM树的某个节点,需要从<code>document</code>对象开始查找,最常用的查找的是根据<code>ID</code>和<code>Tag Name</code>.比如有如下html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;drink-menu&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:solid 1px #ccc;padding:6px;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>摩卡<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>热摩卡咖啡<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>酸奶<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>北京老酸奶<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>果汁<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>鲜榨苹果汁<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> menu = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;drink-menu&#x27;</span>);<br><span class="hljs-keyword">let</span> drinks = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;dt&#x27;</span>);<br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;提供的饮料有:&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;drinks.<span class="hljs-property">length</span>; i++) &#123;<br>    s = s + drinks[i].<span class="hljs-property">innerHTML</span> + <span class="hljs-string">&#x27;,&#x27;</span>; <span class="hljs-comment">// innerHTML是一个DOM属性,用于获取/设置DOM对象的HTML内容,类似的还有innerText,只获取文本内容</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br></code></pre></td></tr></table></figure><p><code>document.cookie</code>该属性可以获取当前页面的<code>cookie</code>.cookie是由服务器发送的K-V标识符.因为HTTP是无状态的,但是服务器要区分是哪个用户发过来的请求,就可以用cookie.当一个用户成功登录后,服务器发送一个cookie给浏览器,例如<code>user=asfdf(加密的字符串)</code>,此后浏览器访问该网站时就会在请求头附上这个cookie,服务器根据cookie区别用户.另外cookie还可用于存储网站一些设置,比如语言等.</p><blockquote><p><code>cookie</code> 和 <code>session</code></p><table><thead><tr><th></th><th>cookie</th><th>session</th></tr></thead><tbody><tr><td>存储位置</td><td>存储在客户端(浏览器)</td><td>存储在服务端</td></tr><tr><td>安全性</td><td>容易被窃取和篡改</td><td>比较安全,因为数据在服务器上</td></tr><tr><td>存储容量</td><td>通常限制4kb</td><td>取决于服务端配置,一般可以存储更多数据</td></tr><tr><td>生命周期</td><td>客户端可以设置过期时间</td><td>以下情况会过期:<br />- 用户关闭浏览器<br />- 服务器端设置的过期时间到达<br />- 用户主动退出登录</td></tr></tbody></table><p>一般</p><ul><li>敏感数据用Session</li><li>用户偏好设置用Cookie</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>; <span class="hljs-comment">// &#x27;v=123; remember=true; prefer=zh&#x27;</span><br></code></pre></td></tr></table></figure><p>由于JavaScript可以获取到cookie,而用户的登录信息通常也会存在cookie,这会产生安全隐患.因为HTML页面可以引入第三方JS,也就是第三方可以通过JS获取用户的cookie.为了避免这种情况,服务器端应该将cookie设置为<code>httpOnly</code>.这样JS便不能获取cookie.</p><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>这个对象保存了浏览器的<code>历史记录</code>,通过它的<code>back()</code>和<code>fowward()</code>方法,相当于用户点击”后退”或”前进”.</p><p>新手喜欢在登录页登录成功后调用<code>history.back()</code>返回登录前页面,这是一个<code>错误</code>的做法.</p><p>对使用AJAX动态加载的页面,如果希望页面更新时同时更新<code>history</code>对象,应当使用<code>history.pushState()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// when AJAX is done:</span><br><span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;any-data&#x27;</span>;<br><span class="hljs-keyword">let</span> newUrl = <span class="hljs-string">&#x27;/ajax.html#singin&#x27;</span>;<br>history.<span class="hljs-title function_">pushState</span>(state, <span class="hljs-string">&#x27;&#x27;</span>, newUrl);<br></code></pre></td></tr></table></figure><h1 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h1><ul><li>更新: 更新DOM节点的内容,相当于更新了DOM节点所表示HTML的内容</li><li>遍历: 遍历该DOM节点下的子节点,以便进一步操作</li><li>添加: 在该DOM节点下新增一个子节点,相当于动态增加了一个HTML节点</li><li>删除: 将该节点从HTML删除,包括它的子节点也一并删除</li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol><li><code>document.getElementById()</code>: 由于ID在HTML文档中是<code>唯一</code>的,所以此方法可以定位唯一的DOM节点</li><li><code>document.getElementByTagName()</code>&#x2F;<code>document.getElementByClassName()</code>总是返回<code>一组</code>DOM节点,可以先定位父节点,再慢慢定位</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 返回ID为&#x27;test&#x27;的节点：</span><br><span class="hljs-keyword">let</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>);<br><br><span class="hljs-comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span><br><span class="hljs-keyword">let</span> trs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-table&#x27;</span>).<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;tr&#x27;</span>);<br><br><span class="hljs-comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span><br><span class="hljs-keyword">let</span> reds = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-div&#x27;</span>).<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br><br><span class="hljs-comment">// 获取节点test下的所有直属子节点:</span><br><span class="hljs-keyword">let</span> cs = test.<span class="hljs-property">children</span>;<br><br><span class="hljs-comment">// 获取节点test下第一个、最后一个子节点：</span><br><span class="hljs-keyword">let</span> first = test.<span class="hljs-property">firstElementChild</span>;<br><span class="hljs-keyword">let</span> last = test.<span class="hljs-property">lastElementChild</span>;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>querySelector()</code>&#x2F;<code>querySelectorAll()</code>: 需要了解selector语法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过querySelector获取ID为q1的节点：</span><br><span class="hljs-keyword">let</span> q1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#q1&#x27;</span>);<br><br><span class="hljs-comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span><br><span class="hljs-keyword">let</span> ps = q1.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div.highlighted &gt; p&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>实际上DOM的节点有多种类型:</p><ul><li>Element: 最常见的节点类型,代表html的各种标签</li><li>Comment: 就是注释</li><li>CDATA_SECTION: 主要用于XML,用于存储包含特殊字符的文本无需转义</li><li>Document: 就是整个HTML文档,也是DOM树的根节点</li></ul><p>DOM节点称为<code>Node</code>,而我们上面操作的都是<code>Element</code>类型的<code>Node</code></p></blockquote><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>修改DOM节点一般使用:</p><ul><li><code>innerHtml</code>: 可以设置HTML标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-comment">// 设置文本为abc:</span><br>p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;ABC&#x27;</span>; <span class="hljs-comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span><br><span class="hljs-comment">// 设置HTML:</span><br>p.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;<br><span class="hljs-comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span><br></code></pre></td></tr></table></figure><ul><li><code>innerText</code>&#x2F;<code>textContent</code>: 会对字符串自动编码,从而无法设置任何HTML标签</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-comment">// 设置文本:</span><br>p.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;<br><span class="hljs-comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span><br><span class="hljs-comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><p>两者区别在于读取属性时,<code>innerText</code>不返回隐藏元素的文本,而<code>textContent</code>返回所有文本.</p><ul><li><code>style</code>: 对应所有CSS,可以通过这个属性获取或设置CSS</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p-id&#x27;</span>);<br><span class="hljs-comment">// 设置CSS:</span><br>p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;#ff0000&#x27;</span>;<br>p.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span>; <span class="hljs-comment">// CSS中的命名是font-size,JS不允许这样的命名,所以改为驼峰命名法</span><br>p.<span class="hljs-property">style</span>.<span class="hljs-property">paddingTop</span> = <span class="hljs-string">&#x27;2em&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>如果获取到的DOM节点是空的,比如<code>&lt;div&gt;&lt;/div&gt;</code>,直接使用<code>innerHtml = &#39;&lt;span&gt;child&lt;/span&gt;&#39;</code>,就相当于插入了一个新的DOM节点.</p><p>但如果节点本身不为空,有两个办法插入:</p><ol><li><p><code>appendChild</code>,把一个节点添加到父节点的最后一个子节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 有这么一段html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <br>js = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;js&#x27;</span>),<br>    list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>)<br>list.<span class="hljs-title function_">appendChild</span>(js);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML 会变成这样 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;java&quot;</span>&gt;</span>Java<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;python&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果要插入的节点<code>已经存在</code>当前的文档中,这个节点会从原来的位置<code>删除</code>,再插入.(<code>id唯一</code>)</p><p>从零创建再插入:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>),<br>haskell = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>); <span class="hljs-comment">// 创建element类型的dom</span><br>haskell.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;haskell&#x27;</span>;  <span class="hljs-comment">// 给dom添加id</span><br>haskell.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;Haskell&#x27;</span>; <span class="hljs-comment">// 给dom添加文本</span><br>list.<span class="hljs-title function_">appendChild</span>(haskell); <span class="hljs-comment">// 插入</span><br></code></pre></td></tr></table></figure><p>动态添加DOM节点可以实现很多功能,比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> d = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;style&#x27;</span>);<br>d.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;text/css&#x27;</span>);<br>d.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;p &#123; color: red &#125;&#x27;</span>; <span class="hljs-comment">// 构建一个新的CSS元素</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTag</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(d) <span class="hljs-comment">// 插入</span><br></code></pre></td></tr></table></figure><p>上面动态创建了一个<code>&lt;style&gt;</code>节点,然后把它添加到<code>&lt;head&gt;</code>节点末尾,动态给document添加了新的CSS.</p></li><li><p><code>inserBefore</code>: 把子节点插入到指定位置,<code>parentElemnet.insertBefore(newElement, referenceElement)</code>,新的子节点会插入到<code>referenceElement</code>之前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>),<br>    ref = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;python&#x27;</span>),<br>    haskell = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>haskell.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;haskell&#x27;</span>;<br>haskell.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;Haskell&#x27;</span>;<br>list.<span class="hljs-title function_">insertBefore</span>(haskell, ref);<br></code></pre></td></tr></table></figure><p>所以使用<code>inserBefore</code>的关键在于拿到准确的参考节点,很多时候需要循环一个父节点的所有子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>i, c,<br>    list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;list.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    c = list.<span class="hljs-property">children</span>[i]; <span class="hljs-comment">// 拿到第i个子节点</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个例子</p><p>有如下的html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Scheme<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Python<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Ruby<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lang&quot;</span>&gt;</span>Haskell<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要把它们按字符串重新排序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-list&#x27;</span>);<br><span class="hljs-keyword">let</span> lis = list.<span class="hljs-property">children</span>;<br><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> e=<span class="hljs-number">0</span>; e&lt;lis.<span class="hljs-property">length</span>; e++) &#123;<br>    arr.<span class="hljs-title function_">push</span>(lis[e].<span class="hljs-property">innerText</span>);<br>    m.<span class="hljs-title function_">set</span>(lis[e].<span class="hljs-property">innerText</span>, lis[e]);<br>&#125;<br>arr.<span class="hljs-title function_">sort</span>()<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> a <span class="hljs-keyword">of</span> arr) &#123;<br>    list.<span class="hljs-title function_">appendChild</span>(m.<span class="hljs-title function_">get</span>(a)); <span class="hljs-comment">// 如果该element已存在,则删除原有的再插入</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>首先获取该<code>节点本身</code>以及它的<code>父节点</code>,然后调用父节点的<code>removeChild</code>把自己删掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 拿到待删除节点</span><br><span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;to-be-removed&#x27;</span>);<br><span class="hljs-comment">// 拿到它的父节点</span><br><span class="hljs-keyword">let</span> parent = self.<span class="hljs-property">parentElement</span>;<br><span class="hljs-comment">// 删除自身</span><br><span class="hljs-keyword">let</span> removed = parent.<span class="hljs-title function_">removeChild</span>(self);<br>removed === self; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong><code>chidlren</code>是一个<code>只读属性</code>,并且在它子节点变化时会<code>实时更新</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 例如有这样的html结构 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>First<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Second<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;parent&#x27;</span>);<br>parent.<span class="hljs-title function_">removeChild</span>(parent.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>]);<br>parent.<span class="hljs-title function_">removeChild</span>(parent.<span class="hljs-property">children</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>第二次remove报错是因为第一次remove后,<code>children</code>实时变化,索引[1]已经不存在</p><h1 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h1><p>表单本身也是DOM树.</p><p>表单的输入框,下拉框可以接收用户输入,所以JS可以获得用户输入的内容,或者对一个输入框设置新的内容.</p><p>HTML表单的输入控件主要有以下几种:</p><ul><li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li><li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li><li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li><li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li><li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li><li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>对于<code>text</code>,<code>input</code>,<code>password</code>,<code>hidden</code>以及<code>select</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span><br><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;email&#x27;</span>);<br>input.<span class="hljs-property">value</span>; <span class="hljs-comment">// &#x27;用户输入的值&#x27;</span><br></code></pre></td></tr></table></figure><p>但对于单选和复选,<code>value</code>返回的是HTML的预设值,也就是所有可选择项.要用<code>checked</code>判断是否用户已选择</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;</span><br><span class="hljs-comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;</span><br><span class="hljs-keyword">let</span> mon = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;monday&#x27;</span>);<br><span class="hljs-keyword">let</span> tue = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;tuesday&#x27;</span>);<br>mon.<span class="hljs-property">value</span>; <span class="hljs-comment">// &#x27;1&#x27;</span><br>tue.<span class="hljs-property">value</span>; <span class="hljs-comment">// &#x27;2&#x27;</span><br>mon.<span class="hljs-property">checked</span>; <span class="hljs-comment">// true或者false</span><br>tue.<span class="hljs-property">checked</span>; <span class="hljs-comment">// true或者false</span><br></code></pre></td></tr></table></figure><h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p><code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以</p><p>单选或复选就把<code>checked</code>设置为<code>true</code>或<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span><br><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;email&#x27;</span>);<br>input.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;test@example.com&#x27;</span>; <span class="hljs-comment">// 文本框的内容已更新</span><br></code></pre></td></tr></table></figure><h2 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h2><p>HTML5新增大量标准控件,常用的如<code>date</code>,<code>datetime</code>,<code>datetime-local</code>,<code>color</code>等,它们都是用<code>&lt;input&gt;</code>标签</p><p>不支持HTML5的浏览器无法识别新的控件,会把他们当作<code>type=&#39;text&#39;</code>来显示.支持的将获得<code>格式化的字符串</code>.例如,<code>type=&#39;date&#39;</code>类型的<code>input</code>的<code>value</code>将保证一个有效的<code>YYYY-MM-DD</code>格式的日期,或者空字符串.</p><h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><p>JS可以以两种方式处理表单的提交.</p><ol><li><p>通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单,例如响应一个<code>&lt;button&gt;</code>的<code>click</code>事件,在js代码中提交</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt; form id=&quot;test-form&quot;&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;doSumbmitForm()&quot;</span>&gt;</span><br>        Submit<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSubmitForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 这里可以修改form的input</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 提交form</span></span><br><span class="language-javascript">    form.<span class="hljs-title function_">submit</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这种方式的缺点是扰乱了浏览器对form的正常提交.正常来说浏览器默认点击<code>&lt;button type=&#39;submit&#39;&gt;</code>时提交表单,或者用户在最后一个输入框按回车键.因此就有了第二种方法</p></li><li><p>响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test-form&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-form&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 可以在此修改form的input...</span></span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 返回true来告诉浏览器继续提交,如果返回false,浏览器将不会继续提交,可用于检查用户输入出错的场景</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p><code>&lt;input type=&quot;hidden&quot;&gt;</code>的妙用:</p><p>很多时候用户输入用户名和口令时,出于安全考虑不会传递明文,会把它转为MD5再传递</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 把用户输入的明文变为MD5:</span></span><br><span class="language-javascript">    pwd.<span class="hljs-property">value</span> = <span class="hljs-title function_">toMD5</span>(pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个做法本身没什么问题,但是当用户输入了密码提交时,密码框会突然从几个<code>*</code>变成32个<code>*</code>(MD5有32个字符)</p><p>如果不想有这个效果:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- HTML --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;login-form&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">onsubmit</span>=<span class="hljs-string">&quot;return checkForm()&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input-password&quot;</span>&gt;</span> <span class="hljs-comment">&lt;!-- 用于给用户输入的password 没有name属性, 没有name属性的input不会被提交--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;md5-password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForm</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> input_pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input-password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">let</span> md5_pwd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;md5-password&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 把用户输入的明文变为MD5:</span></span><br><span class="language-javascript">    md5_pwd.<span class="hljs-property">value</span> = <span class="hljs-title function_">toMD5</span>(input_pwd.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 继续下一步:</span></span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>HTML表单中,可以上传文件的唯一控件就是<code>&lt;input type=&#39;file&#39;&gt;</code></p><p>**注意:**当一个表单包含<code>&lt;input type=&#39;file&#39;&gt;</code>时:</p><ul><li><code>enctype</code>必须为<code>multipart/form-data</code></li><li><code>method</code>必须为<code>post</code></li><li>这样浏览器才能正确编码以<code>multipart/form-data</code>格式发送表单数据</li></ul><p>出于安全考虑,浏览器只允许用户点击<code>&lt;input type=&#39;file&#39;&gt;</code>来选择本地文件,用JS给<code>&lt;input type=&#39;file&#39;&gt;</code>de <code>value</code>赋值是没有任何效果的.当用户上传了某个文件后,JS也无法获得文件的真实路径.</p><p>通常上传的文件都是由后台服务器处理.JS可以在提交表单时对文件扩展名做检查,凡是用户上传无效的格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> f = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-file-upload&#x27;</span>);<br><span class="hljs-keyword">let</span> filename = f.<span class="hljs-property">value</span>;<br><span class="hljs-keyword">if</span> (!filename || !(filename.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.jpg&#x27;</span>) || filename.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.pbg&#x27;</span>) || filename.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;.gif&#x27;</span>))) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Can only upload image file.&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>由于JS对用户上传的文件操作非常优先,尤其无法读取文件内容,使得很多需要操作文件的网页不得不用Flash这样的第三方插件来实现.</p><p>随着HTML5的普及,新增的File API允许JS读取文件内容,获得更多信息.</p><p>HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象,可以获得文件信息并读取文件.</p><p>下面的例子演示如何读取用户上传的图片并在一个div中显示.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span><br>    fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-file&#x27;</span>),<br>    info = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-file-info&#x27;</span>),<br>    preview = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test-image-preview&#x27;</span>);<br><span class="hljs-comment">// 监听change事件:</span><br>fileInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 清除背景图片:</span><br>    preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-comment">// 检查文件是否选择:</span><br>    <span class="hljs-keyword">if</span> (!fileInput.<span class="hljs-property">value</span>) &#123;<br>        info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;没有选择文件&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取File引用:</span><br>    <span class="hljs-keyword">let</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 获取File信息:</span><br>    info.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;文件: &#x27;</span> + file.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;大小: &#x27;</span> + file.<span class="hljs-property">size</span> + <span class="hljs-string">&#x27;&lt;br&gt;&#x27;</span> +<br>                     <span class="hljs-string">&#x27;修改: &#x27;</span> + file.<span class="hljs-property">lastModified</span>;<br>    <span class="hljs-keyword">if</span> (file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/jpeg&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/png&#x27;</span> &amp;&amp; file.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;image/gif&#x27;</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;不是有效的图片文件!&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取文件:</span><br>    <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(); <span class="hljs-comment">// 通过FileReader对象读取文件内容</span><br>    reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-keyword">let</span><br>            data = e.<span class="hljs-property">target</span>.<span class="hljs-property">result</span>; <span class="hljs-comment">// &#x27;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&#x27;            </span><br>        preview.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(&#x27;</span> + data + <span class="hljs-string">&#x27;)&#x27;</span>; <span class="hljs-comment">// 把读取的图片内容放入预览框</span><br>    &#125;;<br>    <span class="hljs-comment">// 以DataURL的形式读取文件:</span><br>    reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以<code>DataURL</code>形式读取到的文件是一个字符串,类似<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>,常用于设置图像.如果需要服务端处理,把字符串<code>base64,</code>后面的字符发送给服务端,并用base64解码就可以得到原始文件的二进制内容.</p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>上面的代码还演示了JS的一个重要特性就是<code>单线程执行模式</code>.</p><p>浏览器的JS执行引擎在执行JS代码时,总是单线程模式执行.任何时候JS都不可能同时有多于一个线程执行.</p><p>JS中的多任务是通过<code>异步</code>来实现的,比如上面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">reader.<span class="hljs-title function_">readAsDataURL</span>(file);<br></code></pre></td></tr></table></figure><p>就会发起一个异步操作来读取文件内容.因为是<code>异步操作</code>,所以我们在JS中就不知道什么时候操作结束,因此需要先设置一个回调函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// reader.onload表示文件读取完成的事件</span><br>reader.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-comment">// 当文件读取完成,自动调用此函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。执行回调函数时，文件已经读取完毕，所以我们可以在回调函数内部安全地获得文件内容。</p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX是一个缩写: Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求.</p><blockquote><p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面。</p><p>这就是Web的运作原理：<code>一次HTTP请求对应一个页面</code>。</p><p>如果要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。</p><p>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。</p><p>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过<code>回调函数</code>获得响应。</p></blockquote><p>现在浏览器写AJAX主要依靠<code>XMLHttpRequest</code>对象,另外还提供了原生支持的Fetch API以<code>Promise</code>(下面会说到)方式提供.使用Fetch API发送HTTP请求代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">let</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">text</span>();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 发送异步请求</span><br><span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;./content.html&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> textarea = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fetch-response-text&#x27;</span>);<br>    textarea.<span class="hljs-property">value</span> = data;<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用Fetch API 配合async写法,代码更简单.</p><p>Fetch API详细用法可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">MDN文档</a></p><h2 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h2><p>上面的代码使用<code>./content.html</code>相对路径.如果你把它改为<code>https://baidu.com</code>,在运行就会报错.在chrome的浏览器控制台还可以看到错误信息.</p><p>这就是浏览器的<code>同源策略</code>:</p><p>默认情况下,JS发送AJAX请求时,URL域名必须和<code>当前页面</code>完全一致.</p><blockquote><p>完全一致的意思是:</p><ul><li>域名:<code>www.example.com</code>和<code>example.com</code>是两个域名</li><li>协议: <code>http</code>和<code>https</code>是不同协议</li><li>端口号也要相同</li></ul></blockquote><p>那如果想通过JS去请求<code>外域</code>可以怎么做呢?</p><ol><li><p>通过Flash插件发送HTTP请求,这种方式可以绕过安全限制,但是Flash已经淘汰了.</p></li><li><p>通过同源域名下假设代理服务器转发,JS把请求发送到代理服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;/proxy?url=https://www.sina.com.cn&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>称为<code>JSONP</code>,有个限制,只能用<code>GET</code>请求,且要求返回JS.因为浏览器允许跨域引用JS资源.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://example.com/abc.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JSNOP通常以函数形式返回,例如但会一个foo</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;data&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这样一来,我们如果在页面先准备好<code>foo()</code>函数,然后给页面动态加一个<code>&lt;script&gt;</code>节点,相当于动态读取外域JS资源,然后就等着接收回调.</p></li></ol><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>支持HTML5的现代浏览器有新的跨域策略可以使用: <code>CORS</code></p><p>全称<code>Cross-Origin Resource Sharing</code>，是HTML5规范定义的如何跨域访问资源</p><blockquote><p>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查<code>Access-Control-Allow-Origin</code>是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lasso">         GET /res/abc.<span class="hljs-built_in">data</span><br>         Host: sina.com<br>┌──────┐ Origin: http:<span class="hljs-comment">//my.com                      ┌────────┐</span><br>│my.com│───────────────────────────────────────────▶│sina.com│<br>│      │◀───────────────────────────────────────────│        │<br>└──────┘ HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK                            └────────┘<br>         Access<span class="hljs-params">-Control</span><span class="hljs-params">-Allow</span><span class="hljs-params">-Origin</span>: http:<span class="hljs-comment">//my.com</span><br>         Content<span class="hljs-params">-Type</span>: text/<span class="hljs-built_in">xml</span><br><br>         &lt;<span class="hljs-built_in">xml</span> <span class="hljs-built_in">data</span><span class="hljs-params">...</span>&gt;<br></code></pre></td></tr></table></figure><p>只要返回的响应头里的<code>Access-Control-Allow-Origin</code>包含本域<code>http://my.com</code>或者<code>*</code>,本次请求就能成功.</p><p>也就是说决定权在对方手上,就看它愿不愿意返回一个正确的<code>Access-Control-Allow-Origin</code>.</p><p>目前新的浏览器都支持CORS,也就是除了JS和CSS外,所有外域资源都要验证CORS.比如你引用某个第三方CDN字体文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;FontAwesome&#x27;</span>;<br>    <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;http://cdn.com/fonts/fontawesome.ttf&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这些跨域请求,称为<code>简单请求</code>,包括:</p><ul><li>GET</li><li>HEAD</li><li>POST: content-type类型限制为<ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li><li>并且不能出现任何<code>自定义头</code></li></ul></li></ul><p>而对于<code>PUT</code>和其他类型如<code>application/json</code>的<code>POST</code>请求,在发送AJAX之前,浏览器会先发送一个<code>OPTIONS</code>请求(称为<code>preflighted请求</code>)到这个URL上,询问目标服务器是否接收</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">OPTIONS /path/to/resource HTTP/1.1<br>Host: bar.com<br>Origin: http://my.com<br>Access-Control-Request-Method: POST<br></code></pre></td></tr></table></figure><p>服务器必须响应并明确指出明确的允许的Methods</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">HTTP/1.1 200 OK<br>Access-Control-Allow-Origin: http://my.com<br>Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS<br>Access-Control-Max-Age: 86400<br></code></pre></td></tr></table></figure><p>浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p><p>由于以<code>POST</code>、<code>PUT</code>方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理<code>POST</code>和<code>PUT</code>请求，服务器端必须正确响应<code>OPTIONS</code>请求。</p><p>关于CROS更多可详阅<a href="https://developer.mozilla.org/docs/Web/HTTP/CORS">MDN文档</a>和<a href="https://fetch.spec.whatwg.org/">W3C文档</a></p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>JS中,所有代码都是但线程执行,着导致JS的所有网络操作,浏览器事件,都必须是异步执行.异步执行可以用<code>回调函数</code>实现.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Done&#x27;</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;before setTimeout()&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(callback, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 1秒后调用callback函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;after setTimeout()&#x27;</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>setTimeout()</code>做了两件事:</p><ul><li>注册了一个定时器</li><li>告诉JS引擎在1000毫秒后把callback函数放入任务队列</li></ul><p>这也称为<code>定时器回调</code>,类似的还有<code>事件回调</code>比如上面的读文件和提交表单</p></blockquote><p>浏览器console输入如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">before setTimeout()<br>after setTimeout()<br>(等待1秒后)<br>Done<br></code></pre></td></tr></table></figure><p>AJAX异步操作:  传统<code>XMLHttpRequest</code>方式定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(requenst.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 4表示请求完成</span><br>        <span class="hljs-keyword">if</span>(request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(request.<span class="hljs-property">responseText</span>); <span class="hljs-comment">// 调用成功回调</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">fail</span>(request.<span class="hljs-property">status</span>); <span class="hljs-comment">// 调用失败回调</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把回调函数<code>success(request.responseText)</code>和<code>fail(request.status)</code>写到一个AJAX操作里,这种方式已经很少使用.不好看也不利于代码复用.</p><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><ul><li>同步: 代码按顺序一行一行执行,上一行代码执行完毕才能执行下一行</li><li>异步: 代码的执行不需要等待上一个任务的完成.例如网络请求,定时器等.异步操作不会阻塞主线程执行.</li></ul><p>JS是单线程语言,意味着它一次只能执行一个任务.为了处理耗时的异步操作而不阻塞主线程,JS使用事件循环和回调函数机制.Promise是建立在这个机制之上的更高级的异步处理方案.</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Promise有三种状态:</p><ul><li>Pending: 初始状态,异步操作正在进行中</li><li>fulfilled: 异步操作成功完成</li><li>rejected: 异步操作失败</li></ul><p>Promise对象提供<code>then()</code>和<code>catch()</code>方法来处理异步操作的结果或错误.</p><blockquote><p>then() 和 catch() 是 Promise 对象上用于处理异步操作结果的关键方法。它们允许你指定回调函数，分别在 Promise <code>完成（fulfilled）</code>或<code>拒绝（rejected）</code>时执行</p><p><code>then()</code>接收一个或两个参数:</p><ul><li>第一个参数(<code>onFulfilled</code>): 一个回调函数,当promise完成(fulfilled)时调用.这个回调函数会接收Promise的完成值作为参数</li><li>第二个参数(<code>onRejected</code>)(可选): 一个回调函数,当Promise拒绝(rejected)时调用.这个回调函数会接收Promise的拒绝原因(通常是一个Error对象)作为参数</li></ul><p>catch() 方法是<code>then(null, onRejected)</code> 的简写形式，它专门用于处理 Promise 的拒绝（rejected）状态。它接受一个回调函数作为参数，当 Promise 拒绝时调用。</p><hr><p><code>resolve()</code>和<code>rejected()</code>是JS Promise API提供的一个内部函数.当你使用<code>new Promise()</code>构造函数创建一个Promise,Promise会将<code>resolve</code>和<code>reject</code>两个函数作为参数传递给你的执行器函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123; <br>  <span class="hljs-comment">// ...你的异步操作代码...</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>resolve()</code>: 一个函数,用于将Promise状态从pending改为fulfilled(已完成).你需要在异步成功完成后调用<code>resolve()</code>,并将操作的结果作为参数传递给它.例如<code>resolve(&#39;操作成功&#39;)</code>或<code>resolve(&#123;data: someData&#125;)</code></li><li><code>reject()</code>: 一个函数,用于将Promise的状态从pending改为rejected(已拒绝).你需要在异步操作失败时调用<code>reject()</code>,并将错误原因(一般是一个<code>Error</code>对象)作为参数传递给它.例如:<code>reject(new Error(&quot;操作失败&quot;))</code>.</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单的Promise例子</span><br><span class="hljs-comment">// 创建一个promise对象,传入两个函数,一个是成功时执行,一个失败时执行</span><br><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// setTimeout(callback, delay) 延时执行callback函数,用来模拟一个异步操作</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> success = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (success) &#123;<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作成功!&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;操作失败!&quot;</span>);<br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 使用then()处理成功的结果</span><br>promise.<span class="hljs-title function_">then</span>(<br><span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>    &#125;<br>);<br><br><span class="hljs-comment">// 使用更简洁的链式调用和catch()处理错误</span><br>promise.<span class="hljs-title function_">then</span>(<br><span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br>    &#125;<br>).<span class="hljs-title function_">catch</span>(<br><span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>因为<code>then()</code>方法返回一个新的Promise对象,因此可以实现链式调用,异步操作更加清晰和易于维护</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 箭头函数的函数体只有一行时,可以省略return和&#123;&#125;,下面的箭头函数等价于: () =&gt; &#123; return resolve(&quot;操作1完成&quot;) &#125;</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;操作1完成&quot;</span>), <span class="hljs-number">1000</span>);<br>        &#125;<br>    );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation2</span>(<span class="hljs-params">result1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<br>    <span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(result1 + <span class="hljs-string">&#x27;, 操作2完成&#x27;</span>), <span class="hljs-number">1500</span>);<br>        &#125;<br>    );<br>&#125;<br><br><span class="hljs-title function_">asyncOperation1</span>()<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">   回调函数内部调用了&quot;asyncOperation2()&quot;,并将</span><br><span class="hljs-comment">*/</span><br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result1</span>) =&gt;</span> <span class="hljs-title function_">asyncOperation2</span>(result1))<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result2</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result2))<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong><code>asyncOperation1()</code></strong>: 调用asyncOperation1()函数,这个函数返回一个<code>Promise</code>,这个Promise在1秒后resolve为<code>操作1完成</code>.</li><li><strong><code>.then((result1) =&gt; asyncOperation2(result1))</code>:</strong> 第一个.then()方法被调用,它的回调函数<code>(result1) =&gt; asyncOperation2(result1)</code>会在<code>asyncOperation1()</code>返回<code>Promise fulfilled</code>后执行.<ul><li><strong><code>result1</code>:</strong> <code>asyncOperation1()</code>的Promise resolve值(<code>操作1完成</code>)会被作为参数传递给第一个<code>.then()</code>的回调函数,这里的<code>result1</code>只是自定义的一个变量名,它会被自动赋值,你把它改为其他名字一样的作用.</li><li><strong><code>asyncOperation2(result1)</code>:</strong> 回调函数内部调用了<code>asyncOperation2</code>函数.并将<code>result1</code>(也就是”操作1完成”)作为参数传递给它.<code>asyncOperation2</code>也会返回一个Promise,这个Promise在1.5秒后resolve为<code>result1 + &#39;, 操作2完成&#39;</code>,也就是”操作1完成，操作2完成”</li></ul></li><li><strong><code>.then((result2) =&gt; console.log(result2))</code>:</strong> 第二个<code>.then()</code>方法被调用.它的回调函数<code>(result2) =&gt; console.log(result2)</code>会在第一个<code>.then()</code>返回新的Promise fulfilled后执行.<ul><li><strong><code>result2</code>:</strong> <code>asyncOperation2()</code>返回的Promise resolve的值(“操作1完成,操作2完成”)会被作为参数传给第二个<code>.then()</code>的回调函数,赋值给<code>result2</code>,同样,名字随意.</li><li><strong><code>console.log(result2)</code>:</strong> 打印<code>result2</code>的值</li></ul></li><li><strong><code>.catch((error) =&gt; console.error(error)))</code>:</strong> 用于捕获Promise链中任何一个Promise出现<code>rejected</code>状态的情况.</li></ul></blockquote><p><strong>总结:</strong> 理解Promise链的关键在于理解:</p><ol><li><code>.then()</code>方法会获取上一个Promise对象的resolve返回,并把它作为参数传递给<code>.then()</code>的<code>回调函数</code></li><li>如果上一个Promise内<code>reject()</code>了,那么<code>.then()</code>的第一个回调函数就不会被执行,代码跳到链上的下一个<code>.catch()</code>或者直接抛出错误(如果没有<code>.catch()</code>)</li><li><code>.then()</code> 方法不仅是处理 Promise 完成后的结果，更是构建 Promise 链、实现异步操作顺序执行的关键。 它通过接收前一个 Promise 的结果作为输入，来实现异步操作之间的依赖关系，让后续操作建立在前面的操作结果之上</li></ol><hr><p>但是其实可以看到Promise链理解起来十分复杂,写起来也一样复杂,大多数情况下,要使用<code>async/await</code>,这是针对Promise的语法糖,它使得异步代码看起来更像同步代码,从而大大简化代码的复杂度喝可读性.只有在一些非常特殊的情况下（例如，需要非常精细地控制 Promise 的执行顺序，或者与一些老旧的库进行交互），你才可能需要编写更复杂的 Promise 链。 而大多数情况下，应该尽量避免复杂的 Promise 链，而选择更清晰和易于维护的方法。</p><h1 id="async"><a href="#async" class="headerlink" title="async"></a>async</h1><p>在JS中,async关键字用于声明一个异步函数.异步函数总是返回一个Promise对象,即使函数体没有显示地返回一个Promise.</p><p>特点:</p><ul><li><strong>总是返回一个Promise:</strong> 一个 async 函数无论是否显式返回一个 Promise，都会隐式地返回一个 Promise。如果 async 函数返回一个值，这个值会被 <code>Promise.resolve()</code> 包装成一个 fulfilled 的 Promise；如果 async 函数抛出一个异常，则返回一个 rejected 的 Promise。</li><li><strong><code>await</code>关键字:</strong> <code>async</code>关键字内部可以使用<code>await</code>关键字,暂停函数的执行,知道一个Promise完成(fulfilled或rejected).这使得异步代码更容易阅读和编写,看起来更像同步代码.</li><li><strong>清晰的错误处理:</strong> 使用<code>try...catch</code>直接不过异步操作中可能发生的错误.</li><li><strong>简化异步操作:</strong> <code>async/await</code>使得处理多个异步操作变得更加简单和易于理解,避免promise链的嵌套和复杂.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">someAsyncOperation1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;Operation 1 completed&quot;</span>), <span class="hljs-number">1000</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">someAsyncOperation2</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(data + <span class="hljs-string">&quot; - Operation 2 completed&quot;</span>), <span class="hljs-number">1500</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation1</span>(); <span class="hljs-comment">// 等待someAsyncOperation1完成</span><br>        <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation2</span>(result1); <span class="hljs-comment">// 等待someAsyncOperation2完成</span><br>        <span class="hljs-keyword">return</span> result2; <span class="hljs-comment">// 返回一个promise,值为result2</span><br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 或者抛出错误 throw error</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">myAsyncFunction</span>()<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;final result:&quot;</span>, result))<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Caught error:&quot;</span>, error));<br></code></pre></td></tr></table></figure><ul><li>myAsyncFunction 是一个 async 函数。</li><li>await 关键字用于等待 someAsyncOperation1 和 someAsyncOperation2 异步操作完成。</li><li>try…catch 块用于处理潜在的错误。</li><li>函数最终返回一个 Promise。</li></ul><blockquote><p><code>async</code>函数的本质是对Promise的语法糖.它使得异步操作得编写简洁易懂,底层仍然依赖于Promise.</p><p>所以你可以看到,使用<code>async/await</code>来编写异步代码更加便捷易懂,但是它返回的永远是一个Promise对象.所以依旧需要<code>then</code>和<code>catch</code>来处理成功的结果&#x2F;可能发生的错误</p></blockquote><h2 id="错误返回"><a href="#错误返回" class="headerlink" title="错误返回"></a>错误返回</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">...<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 或者抛出错误 throw error;</span><br>        <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 这两行代码二选一</span><br>    &#125;<br>...<br></code></pre></td></tr></table></figure><p>上面的错误处理,<code>return null;</code>和<code>throw error;</code>是两种截然不同的操作.</p><ul><li><p><code>return null</code></p><p>只是简单地返回一个null,不会中断Promise链的执行,也不会触发<code>.catch()</code>,<code>return null</code>只是改变了Promise的resolve值,但Promise的状态仍然是<code>fulfilled</code></p></li><li><p><code>throw error;</code></p><p>则会将错误抛出,把promise的状态改为rejected,从而触发<code>.catch()</code>方法.这个错误也能被调用方用<code>try...catch</code>来捕获.触发了<code>throw error</code>会中断Promise链. 更准确地说，它会将 Promise 的状态设置为 rejected，并且会停止后续 .then() 方法中 <em>第一个参数（onFulfilled）</em> 回调函数的执行。 错误会沿着 Promise 链向上“冒泡”，直到遇到一个 .catch() 方法来处理它，或者最终导致程序报错（如果没有 .catch() 处理）。</p></li></ul><p>下面是一个用<code>try...catch</code>捕获<code>threw error</code>的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> result1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation1</span>();<br>    <span class="hljs-keyword">const</span> result2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">someAsyncOperation2</span>(result1);<br>    <span class="hljs-keyword">return</span> result2;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error in myAsyncFunction:&quot;</span>, error);  <span class="hljs-comment">//记录错误信息</span><br>    <span class="hljs-keyword">throw</span> error; <span class="hljs-comment">// 将错误抛出到调用者</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">myAsyncFunction</span>();<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Result:&quot;</span>, result);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error caught in main function:&quot;</span>, error); <span class="hljs-comment">// 在这里处理抛出的错误</span><br>    &#125;<br>&#125;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure><p>从上面的例子也能看出,<code>async</code>定义的异步函数可以通过<code>另一个异步函数</code>(main)来调用,并使用<code>try...catch</code>来捕获错误.从而避免了<code>.then()</code>和<code>.catch()</code>的使用.这是一种更优雅更易的方式.但是要谨记,这些都只是语法糖,底层依旧是Promise对象.</p><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p>是HTML5的一个组件,提供一个可以用来绘制2D图形的位图.它本质上是一个可以被JS代码操作的画布.你可以用JS在它上面绘制各种图形,图像和文字.</p><p>主要用途:</p><ul><li>图形绘制</li><li>图像处理: 缩放,选装,裁剪,滤镜等</li><li>动画制作: 通过不停更新canvas的内容创建动画效果</li><li>游戏开发: 是很多2D游戏的开发基础</li><li>数据可视化</li></ul><p>局限性:</p><ul><li>性能: 非常复杂的图形和动画,推荐使用WebGL(一种基于canvas的3D图形库)</li><li>DOM操作: canvas本身不是DOM元素,所以不支持DOM API来操作.</li><li>矢量图: 不支持矢量图,矢量图缩放不会失真.所以Canvas绘制的图形缩放会失真.SVG是处理矢量图更好的选择.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-面向对象编程</title>
    <link href="/2024/11/12/js-oop/"/>
    <url>/2024/11/12/js-oop/</url>
    
    <content type="html"><![CDATA[<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>对于大多数语言,面向对象编程都是通过<code>类</code>和<code>实例</code>来实现.但是在JS中,它不区分类和实例,而是通过<code>原型(prototype)</code>来实现面向对象编程.</p><p>举个例子来说明一下<code>原型</code>:</p><p>假设我们想创建<code>xiaoming</code>这个具体的学生,但是我们没有<code>Student</code>类型可以用,不过有一个现成的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> robot = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.6</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个<code>robot</code>对象有名字,有身高还会跑,有点像<code>xiaoming</code>,于是就是用它来<code>创建</code>xiaoming吧.直接把它改名为<code>Student</code>,然后创建出<code>xiaoming</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Student</span> = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.2</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;xiaoming&#x27;</span><br>&#125;;<br><span class="hljs-comment">// 这里把xiaoming的原型指向了Student,看上去xiaoming仿佛是从Student继承下来</span><br>xiaoming.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Student</span>;<br>xiaoming.<span class="hljs-property">name</span>; <span class="hljs-comment">// &#x27;xiaoming&#x27;</span><br>xiaoming.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// xiaoming is running...</span><br></code></pre></td></tr></table></figure><p>JS的<code>原型链</code>没有<code>class</code>的概念,所有对象都是实例,所谓的<code>继承关系</code>就是一个对象的原型指向另一个对象.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411121803684.jpeg" srcset="/img/loading.gif" lazyload alt="xiaoming-prototype"></p><p>比如如果你把<code>xiaoming</code>的原型指向其他对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bird</span> = &#123;<br>    <span class="hljs-attr">fly</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is filying...&#x27;</span>);<br>    &#125;<br>&#125;;<br>xiaoming.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Bird</span>;<br><br>xiaoming.<span class="hljs-title function_">fly</span>(); <span class="hljs-comment">// 现在xiaoming已经无法run了,只能fly</span><br></code></pre></td></tr></table></figure><blockquote><p>**注意:**上面的<code>__proto__</code>只是为了演示而已,实际开发不要直接用<code>obj.__proto__</code>去改变一个对象的原型</p></blockquote><p><code>object.create()</code>可以传入一个原型对象,并创建一个基于该原型的新对象,但是新对象什么属性都没有.因此我们可以写个函数来创建<code>xiaoming</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型对象</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Student</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robot&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.2</span>,<br>    <span class="hljs-attr">run</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27; is running...&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStudent</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-comment">// 基于Student原型创建一个新对象</span><br>    <span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Student</span>);<br>    <span class="hljs-comment">// 初始化新对象</span><br>    s.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-title function_">createStudent</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.<span class="hljs-title function_">run</span>(); <span class="hljs-comment">// 小明 is running...</span><br>xiaoming.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Student</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>JS对每个创建的对象都会设置一个<code>原型</code>,指向它的<code>原型对象</code>.</p><blockquote><p>当我们用<code>obj.xxx</code>访问一个对象的属性时,JS引擎会先在该对象上找对应的属性,没有找到就去它的原型对象上找,还没有找到,就一直上溯到<code>object.prototype</code>对象,都没找到,就返回<code>undefined</code></p></blockquote><p>例如一个<code>array</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p>这就是它的原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">       <span class="hljs-literal">null</span><br>         ▲<br>         │<br>┌─────────────────┐<br>│<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>└─────────────────┘<br>         ▲<br>         │<br>┌─────────────────┐<br>│ <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>└─────────────────┘<br>         ▲<br>         │<br>┌─────────────────┐<br>│       arr       │<br>└─────────────────┘<br></code></pre></td></tr></table></figure><p><code>Array.prototype </code>定义了<code>indexOf()</code>,<code>shift()</code>等方法,因此你可以在所有<code>Array</code>对象上直接调用这些方法.</p><p>当我们创建一个函数,函数也是对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>        <span class="hljs-literal">null</span><br>          ▲<br>          │<br>┌───────────────────┐<br>│ <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>  │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│        foo        │<br>└───────────────────┘<br></code></pre></td></tr></table></figure><p><code>Function.prototype </code>定义了<code>apply()</code>等方法,所以所有函数都能调用这些方法.</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="object-create"><a href="#object-create" class="headerlink" title="object.create()"></a>object.create()</h2><p>如上所示.这种方法允许你创建一个新对象,并将现有对象作为其原型.这意味着新对象将继承现有对象的属性和方法.</p><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>最简单,最常用.就是直接使用<code>&#123;...&#125;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObject = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: John Doe</span><br>myObject.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出: Hello John Doe</span><br></code></pre></td></tr></table></figure><h2 id="new-Object"><a href="#new-Object" class="headerlink" title="new Object()"></a>new Object()</h2><p>不太常用,主要用于创建一个空对象,然后动态地添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>myObject.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Peter&#x27;</span>;<br>myObject.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myObject.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: Peter</span><br></code></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>这种方法允许你创建多个具有相同属性和方法的对象.构造函数使用<code>this</code>引用新创建的对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Peter Pan&#x27;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;WeiJian&#x27;</span>, <span class="hljs-number">18</span>);<br>person1.<span class="hljs-title function_">greet</span>();<br>person2.<span class="hljs-title function_">greet</span>();<br></code></pre></td></tr></table></figure><ul><li><code>new</code>关键字把构造函数内的<code>this</code>绑定到对应的新对象上.</li><li>构造函数默认返回<code>this</code>,也就是不用写<code>return this</code></li></ul><p>原型链是这样的:</p><p><code>person1</code>的原型指向函数<code>Person</code>的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">              <span class="hljs-literal">null</span><br>                ▲<br>                │<br>       ┌─────────────────┐<br>       │<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>       └─────────────────┘<br>                ▲<br>                │<br>       ┌─────────────────┐<br>       │<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> │<br>       └─────────────────┘<br>         ▲      ▲      ▲<br>         │      │      │<br>┌─────────┐┌─────────┐┌─────────┐<br>│person1  ││person2  ││ ...     │<br>└─────────┘└─────────┘└─────────┘<br></code></pre></td></tr></table></figure><p>使用<code>new &lt;构造函数&gt;</code>创建的对象还会从原型上获取一个<code>constructor</code>属性,指向<code>&lt;构造函数&gt;</code>本身.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>; <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// true</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// true</span><br>person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411131146988.png" srcset="/img/loading.gif" lazyload alt="image-20241113114617900"></p><ul><li>红色箭头是原型链</li><li><code>Person.prototype</code>指向的就是<code>person1</code>和<code>person2</code>的<code>原型对象</code></li><li>这个原型对象自己有个<code>constructor</code>的属性,指向<code>Person</code>构造函数本身</li><li>另外<code>person1</code>,<code>person2</code>是没有<code>prototype</code>属性的,不过可以用<code>__proto__</code>这个非标准用法来查看</li><li>此时我们就认为<code>person1</code>,<code>person2</code>“继承”自<code>Person</code></li></ul><p>另外还有一个小问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">person1.<span class="hljs-property">name</span> === person2.<span class="hljs-property">name</span>; <span class="hljs-comment">// false</span><br>person1.<span class="hljs-property">greet</span> === person2.<span class="hljs-property">greet</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>新创建的对象,属性不相等是正常的,但是他们的<code>方法也是不相等的</code>.也就是说它们各自会有各自的方法,几时方法的名字和代码都一样.</p><p>但是这样子同样的方法存两份有点浪费资源了,所以我们可以在<code>共享对象上创建这个方法</code>,然后继承它的对象就会使用同一个方法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>如果一个函数被定义为用于创建对象的<code>构造函数</code>,但是调用时忘记写<code>new</code>:</p><ul><li><code>strict</code>模式下,<code>this.name = name</code>会报错,因为<code>this</code>绑定为<code>undefined</code></li><li>非<code>strict</code>模式下,<code>this.name = name</code>不会报错,因为<code>this</code>绑定为<code>window</code>,无意间创建了全局变量<code>name</code>,并返回<code>undefined</code></li></ul><p>所以调用构造函数千万不要忘记了<code>new</code>.一些语法检查工具可以帮助你检查你的语法,比如<code>jslint</code></p></blockquote><p>但其实<code>new</code>可以通过函数封装,一个常用的编程模式像这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;匿名&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 在原型对象上加函数,以后创建新对象自动继承</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 通过一个函数封装new操作</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(props || &#123;&#125;);<br>&#125;<br><br><span class="hljs-comment">// 调用时就不怕漏掉new,参数也灵活,传不传都可以</span><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-title function_">createStudent</span>(&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="类语法"><a href="#类语法" class="headerlink" title="类语法"></a>类语法</h2><p>ES后引入创建对象的语法,以后会提及.</p><hr><blockquote><p>目前字面量和类语法最常用.</p><p><code>构造函数</code>的缺点是其原型链的设置方式容易出错,而且没有类语法清晰</p><p><code>Object.create()</code>主要用于精确控制原型链的场景,或者需要创建不带构造函数的对象</p></blockquote><h1 id="模拟继承"><a href="#模拟继承" class="headerlink" title="模拟继承"></a>模拟继承</h1><p>在传统基于Class的语言如Java,C++中,继承的本质是扩展一个已有的class,并生成新的Subclass.由于这类语言严格区分类和实例,继承实际上<code>类型</code>的扩展.</p><p>但是JS采用<code>原型继承</code>,所以无法直接扩展一个Class,因为根本没有Class这个概念.</p><p>那如果想要继承扩展呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 假设有这么一个Student的构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Unnamed&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 在Student的原型中添加一个hello的共享方法</span><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 创建两个新对象</span><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br><span class="hljs-keyword">let</span> xiaohong = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小红&#x27;</span>);<br></code></pre></td></tr></table></figure><p>原型链如下:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411131542775.jpeg" srcset="/img/loading.gif" lazyload alt="js-proto"></p><p>此时如果想要基于<code>Student</code>扩展出<code>PrimaryStudent</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-comment">// call 允许你调用一个函数,并指定函数内部&quot;this&quot;的值以及传递给函数的参数</span><br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在这个例子中，<code>Student.call(this, props) </code>做了以下事情：</p><ol><li><strong>调用 Student 函数:</strong> 它像普通函数一样调用了 <code>Student</code> 构造函数。</li><li><strong>设置 this 的值:</strong> call() 的第一个参数指定了 <code>Student</code> 函数内部 <code>this</code> 的值。 在这里，<code>this</code> 指的是正在被创建的 <code>PrimaryStudent</code> 实例。 这很重要，因为在 <code>Student</code> 构造函数内部，<code>this.name = props.name || &#39;Unnamed&#39;;</code> 这行代码会将 <code>name</code> 属性添加到 <code>this</code> 指向的对象上。 通过将 <code>this</code> 设置为 <code>PrimaryStudent</code> 的实例，我们确保 <code>name</code> 属性被添加到 <code>PrimaryStudent</code> 实例上，而不是其他地方。</li><li><strong>传递参数:</strong> <code>call()</code> 的第二个参数 <code>props</code> 将被传递给 <code>Student</code> 函数。 这使得 <code>Student</code> 构造函数可以使用 <code>props</code> 对象来初始化 <code>PrimaryStudent</code> 实例的 <code>name</code> 属性</li></ol></blockquote><p>这个做法可以理解为:</p><p>在<code>PrimaryStudent</code>构造函数内部手动调用<code>Student</code>构造函数,并将其<code>this</code>指向了<code>PrimaryStudent</code>的实例.这样模拟了<code>Student</code>构造函数被用于创建<code>PrimaryStudent</code>实例的效果,模拟”继承”.</p><p>但实际上这<strong>并不是</strong>真正意义上的<code>继承</code>.举这个例子只是为了扩展,实际中并不会这么操作.</p><p><a href="https://liaoxuefeng.com/books/javascript/oop/prototype/index.html">来源</a></p><p>但我看不懂他下面的解释,只摘录这个例子,后面的理解找的AI.</p><h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p>JavaScript继承的核心是<code>原型链</code>.每个对象都有一个<code>__proto__</code>属性.(现代浏览器中一般通过<code>Object.getPrototypeOf()来访问</code>),它指向创建该对象的<strong>函数</strong>的<code>prototype</code>属性.当访问对象的某个属性时,JS引擎会现在对象自身查找,如果没有找到,就会沿着原型链向上查找,知道找到该属性或到达原型链顶端(null).</p><h2 id="proto-VS-prototype"><a href="#proto-VS-prototype" class="headerlink" title="__proto__VS prototype"></a><code>__proto__</code>VS <code>prototype</code></h2><p><code>prototype</code>(原型属性)</p><ul><li><p>是一个<code>函数对象</code>才拥有的属性.它指向<code>原型对象</code>.使用该函数(构造函数)<code>new</code>出来的对象,它的<code>__proto__</code>属性会被设置为<code>prototype</code>的属性值</p></li><li><p>一般用来定义通过构造函数创建的对象的<code>共享属性</code>和<code>方法</code>.也就是说它充当新对象的模板.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, my name is &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>);<br><br>person1.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// Output: Hello, my name is Alice</span><br>person2.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// Output: Hello, my name is Bob</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">greet</span> === person2.<span class="hljs-property">greet</span>); <span class="hljs-comment">// true, 不同实例共享同一个方法</span><br></code></pre></td></tr></table></figure><p><code>Person.prototype</code>是<code>Person</code>构造函数的<code>原型属性</code></p></li></ul><p><code>__proto__</code>(原型链)</p><ul><li><p>是一个<code>对象</code>拥有的属性(包括函数对象).它指向创建该对象的构造函数的<code>prototype</code>属性.是JS实现原型继承的关键.</p></li><li><p>它用来构成JS的<code>原型链</code>.当访问一个对象属性的时候,JS引擎会现在对象自身找该属性,如果找不到,会沿着<code>__proto__</code>指向的原型对象继续查找,知道找到或者到尽头(null)为止.</p></li><li><p>但现在我们一般不直接调用它,他是用<code>Object.getPrototypeOf()</code>来查看; <code>Object.setPrototypeOf()</code> 来设置对象的原型.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Output: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">greet</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">greet</span>); <span class="hljs-comment">// Output: true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1) === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// Output: true (preferred way)</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="inherits"><a href="#inherits" class="headerlink" title="inherits"></a>inherits</h2><p><code>inherits</code>函数的目标是建立两个构造函数之间的继承关系,使一个<code>构造函数的实例</code>能够继承另一个构造函数的<code>原型上的属性和方法</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 下面是一个inherits函数的模拟实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child, Parent</span>) &#123;<br>    <span class="hljs-comment">// 1. 创建一个空函数</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125; <span class="hljs-comment">// 临时构造函数,作为中介,避免直接修改Child或Parent的原型</span><br>    <br>    <span class="hljs-comment">// 2. 将F的原型设置为Parent的原型</span><br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// F与Parent共享同一个原型</span><br>    <br>    <span class="hljs-comment">// 3. 将Child的原型设置为F的一个新实例</span><br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>(); <span class="hljs-comment">// Child继承Parent的原型,而且Child.prototype独立于Parent.prototype</span><br>    <br>    <span class="hljs-comment">// 4. 设置Child.prototype.constructor 回到Child</span><br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>; <span class="hljs-comment">// 恢复Child的构造函数,因为步骤3修改了它</span><br>    <br>    <span class="hljs-comment">// 可选步骤: 添加__super__属性,非标准,但常用</span><br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__super__</span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// 方便在子类方法重调用父类方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141758092.png" srcset="/img/loading.gif" lazyload alt="image-20241114175822002"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141759062.png" srcset="/img/loading.gif" lazyload alt="image-20241114175911981"></p><p>此时<code>F</code>和<code>Parent</code>指向<code>同一个</code>原型对象</p><p><code>new F()</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141801806.png" srcset="/img/loading.gif" lazyload alt="image-20241114180118730"></p><p>通过<code>F()</code>构造函数创建的实例(f_instance),它的<code>__proto__</code>指向它的构造函数的<code>prototype</code>属性,也就是<code>F</code>的<code>prototype</code>属性,因为<code>F</code>和<code>Parent</code>指向<code>同一个</code>原型对象,所以f_instance的<code>__proto__</code>实际上也是指向<code>Parent.prototype</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141813263.png" srcset="/img/loading.gif" lazyload alt="image-20241114181352180"></p><p>此时把Child的<code>prototype</code>指向F构造函数创建的实例(<code>f_instance</code>),因为<code>f_instance.__proto__</code>指向<code>Parent.prototype</code>,此时Child和Parent就串起来了.</p><p>可是此时<code>Child的prototype的constructor属性</code>应该是<code>F()</code>,因为此时Child的prototype指向了f_instance,所以Child的prototype的constructor指向的是f_instance的构造函数,也就是F().</p><p>所以要修复回来,指回<code>Child</code>. <code>Child.prototype.constructor = Child;</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141825203.png" srcset="/img/loading.gif" lazyload alt="image-20241114182546123"></p><p>最终原型链大概是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411141841882.png" srcset="/img/loading.gif" lazyload alt="image-20241114184137787"></p><hr><blockquote><p>真尼玛复杂….</p><p>我觉得大概理一下就行了,反正以后都是用ES6的class语法</p></blockquote><hr><p>以上复杂的动作可以用一个<code>inherits()</code>函数封装起来,隐藏<code>F</code>的定义,简化代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">inherits</span>(<span class="hljs-params">Child, Parent</span>) &#123;<br>    <span class="hljs-keyword">let</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    <span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用这个<code>inherits()</code>函数就能简单实现原型链继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = props.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Unnamed&#x27;</span>;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PrimaryStudent</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-title class_">Student</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = props.<span class="hljs-property">grade</span> || <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-title function_">inherits</span>(<span class="hljs-title class_">PrimaryStudent</span>, <span class="hljs-title class_">Student</span>);<br><br><span class="hljs-title class_">PrimaryStudent</span>.<span class="hljs-property">protype</span>.<span class="hljs-property">getGrade</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>JS的对象模型基于原型实现,虽说它概念简单,没有类的概念.但是理解起来复杂,实现起来也麻烦.ES6引入了<code>class</code>这个语法糖,让类的定义更加简单.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数方式实现Student类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Student</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Student</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// class关键字实现Student类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">// 定义构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    &#125;<br>    <span class="hljs-comment">// 定义类中的方法</span><br>    <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;小明&#x27;</span>);<br>xiaoming.<span class="hljs-title function_">hello</span>();<br></code></pre></td></tr></table></figure><h1 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h1><p>直接通过<code>extends</code>实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrimaryStudent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Student</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, grade</span>) &#123;<br>        <span class="hljs-variable language_">super</span>(name); <span class="hljs-comment">// 用super调用父类的构造方法</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> = grade;<br>    &#125;<br>    <br>    <span class="hljs-title function_">myGrade</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;I am at grade &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>class</code>: 定义类</li><li><code>extends</code>: 表示原型链对象来自<code>Student</code></li><li><code>constructor</code>: 定义子类的构造函数,子类需要<code>name</code>和<code>grade</code>两个参数,<code>name</code>用于<code>super(name)</code>中调用父类的构造函数,否则父类的<code>name</code>属性无法初始化</li></ul><blockquote><p>ES6引入的<code>class</code>只是一个语法糖,实际的底层原理跟上面的没有任何区别.我只能说…</p><p>舒服了….</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-标准对象</title>
    <link href="/2024/11/11/js-standar-object/"/>
    <url>/2024/11/11/js-standar-object/</url>
    
    <content type="html"><![CDATA[<h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><p>JS中,<code>一切皆对象</code>.</p><p>使用<code>typeof</code>操作符可以获取对象类型.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-number">123n</span>; <span class="hljs-comment">// &#x27;bigint&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &#x27;number&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>; <span class="hljs-comment">// &#x27;string&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// &#x27;boolean&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// &#x27;undefined&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">abs</span>; <span class="hljs-comment">// &#x27;function&#x27;</span><br><span class="hljs-comment">// object</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> []; <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125;; <span class="hljs-comment">// &#x27;object&#x27;</span><br></code></pre></td></tr></table></figure><p><code>null</code>,<code>array</code>,通常意义的对象<code>&#123;&#125;</code>都是<code>object</code></p><h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p>除了上面的类型,JS还提供<code>包装对象</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>); <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>(<span class="hljs-number">123</span>) === <span class="hljs-number">123</span>; <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>) === <span class="hljs-literal">true</span>; <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">typeof</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;str&#x27;</span>); <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;str&#x27;</span>) === <span class="hljs-string">&#x27;str&#x27;</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>虽然包装对象的出来的值可以与原来的保持一致,但是对象类型一律都会变为<code>object</code>,如果与原始值用<code>===</code>比较会返回<code>false</code>.</p><p>所以<code>不要使用包装对象!尤其是针对string类型</code></p><p><code>new</code> 操作符主要用于创建一个用户定义的对象类型的实例,如果不用<code>new</code>, <code>Number()</code>,<code>Boolean()</code>,<code>String()</code>就会被当做普通函数,把任何类型的数据转换成<code>Number</code>,<code>Boolean</code>和<code>string</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n = <span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>); <span class="hljs-comment">// 123，相当于parseInt()或parseFloat()</span><br><span class="hljs-keyword">typeof</span> n; <span class="hljs-comment">// &#x27;number&#x27;</span><br><br><span class="hljs-keyword">let</span> b = <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;true&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-keyword">typeof</span> b; <span class="hljs-comment">// &#x27;boolean&#x27;</span><br><br><span class="hljs-keyword">let</span> b2 = <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;false&#x27;</span>); <span class="hljs-comment">// true! &#x27;false&#x27;字符串转换结果为true！因为它是非空字符串！</span><br><span class="hljs-keyword">let</span> b3 = <span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">String</span>(<span class="hljs-number">123.45</span>); <span class="hljs-comment">// &#x27;123.45&#x27;</span><br><span class="hljs-keyword">typeof</span> s; <span class="hljs-comment">// &#x27;string&#x27;</span><br></code></pre></td></tr></table></figure><p>总结一下:</p><ol><li><p>不要使用<code>new Number()</code>,<code>new Boolean()</code>,<code>new String()</code>创建包装对象</p></li><li><p>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code></p></li><li><p>用<code>String()</code>或来转换任意类型到<code>string</code>,或者直接调用对象的<code>toString()</code>方法</p><ol><li><p>除了<code>null</code>和<code>undefined</code>,任何对象都有<code>toString()</code>方法</p></li><li><p><code>number</code>对象直接调用<code>toString</code>方法会报错,需要用<code>两个点</code>或者<code>加括号</code>来调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">123.</span><span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// SyntaxError</span><br><span class="hljs-number">123.</span>.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// 正确</span><br>(<span class="hljs-number">123</span>).<span class="hljs-title function_">tiString</span>(); <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><blockquote><p>不要问为什么,这就是JS.</p></blockquote></li></ol></li><li><p>通常不用把任意类型转换成<code>boolean</code>再判断,可以直接写<code>if (myVar) &#123;...&#125;</code></p></li><li><p><code>typeof</code>可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code></p></li><li><p>判断<code>Array</code>是使用<code>Array.isArray(arr)</code></p></li><li><p>判断<code>null</code>请使用<code>myVar === null</code></p></li><li><p>判断某个全局变量<code>是否存在</code>使用<code>typeof window.myVar === &#39;undefined&#39;</code></p></li><li><p>函数内部判断某个变量<code>是否存在</code>用<code>typeof myVar == &#39;undefined&#39;</code></p></li></ol><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><p><code>Date</code>对象用来表示日期和时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过浏览器获取系统时间</span><br><span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>now; <span class="hljs-comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span><br>now.<span class="hljs-title function_">getFullYear</span>(); <span class="hljs-comment">// 2015, 年份</span><br>now.<span class="hljs-title function_">getMonth</span>(); <span class="hljs-comment">// 5, 月份，注意月份范围是0~11，5表示六月</span><br>now.<span class="hljs-title function_">getDate</span>(); <span class="hljs-comment">// 24, 表示24号</span><br>now.<span class="hljs-title function_">getDay</span>(); <span class="hljs-comment">// 3, 表示星期三</span><br>now.<span class="hljs-title function_">getHours</span>(); <span class="hljs-comment">// 19, 24小时制</span><br>now.<span class="hljs-title function_">getMinutes</span>(); <span class="hljs-comment">// 49, 分钟</span><br>now.<span class="hljs-title function_">getSeconds</span>(); <span class="hljs-comment">// 22, 秒</span><br>now.<span class="hljs-title function_">getMilliseconds</span>(); <span class="hljs-comment">// 875, 毫秒数</span><br>now.<span class="hljs-title function_">getTime</span>(); <span class="hljs-comment">// 1435146562875, 以number形式表示的时间戳</span><br></code></pre></td></tr></table></figure><p>新建一个指定日期时间的<code>Date</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">5</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>**注意:**是的没错,JS的月份范围是<code>0-11</code>,<code>0</code>是<code>一月份</code>.</p><p>第二种创建指定日期和时间的方法是: 解析一个符合<a href="https://www.w3.org/TR/NOTE-datetime">ISO 8601</a>格式的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> d = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;2015-06-24T19:49:22.875+08:00&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(d); <span class="hljs-comment">// 1435146562875 返回的是一个时间戳</span><br><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1435146562875</span>); <span class="hljs-comment">// 通过时间戳就能很容易转换成Date</span><br>d; <span class="hljs-comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span><br>d.<span class="hljs-title function_">getMonth</span>(); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>**注意:**是的没错,获取的月份会<code>-1</code></p><blockquote><p> 这是一个很坑爹的设计,估计当时JS设计者脑子一抽写成这样,但是现在要改回来已经是不可能了.</p></blockquote><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p><code>date</code>对象表示的时间总是按浏览器所在时区显示.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1435146562875</span>);<br>d.<span class="hljs-title function_">toLocaleString</span>(); <span class="hljs-comment">// &#x27;2015/6/24 下午7:49:22&#x27;，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关</span><br>d.<span class="hljs-title function_">toUTCString</span>(); <span class="hljs-comment">// &#x27;Wed, 24 Jun 2015 11:49:22 GMT&#x27;，UTC时间，与中国本地时间相差8小时</span><br><br><span class="hljs-comment">// 获取当前时间戳</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>());<br></code></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a href="https://www.runoob.com/regexp/regexp-tutorial.html">教程</a></p><p><a href="https://www.jyshare.com/front-end/854/">在线测试+语法参考</a></p><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>JS中使用正则有两种方式:</p><ol><li><code>/正则表达式/</code></li><li><code>new RegExp(&#39;正则表达式&#39;)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re1 = <span class="hljs-regexp">/ABC\-001/</span>;<br><span class="hljs-keyword">let</span> re2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;ABC\\-001&#x27;</span>);<br><br>re1; <span class="hljs-comment">// /ABC\-001/</span><br>re2; <span class="hljs-comment">// /ABC\-001/</span><br></code></pre></td></tr></table></figure><p>第二种写法中,字符串转义,所以是<code>\\</code></p><p>不论那种写法,都是<code>RegExp</code>对象.</p><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><p><code>test()</code>方法判断是否匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;<br>re.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;010-12345&#x27;</span>); <span class="hljs-comment">// true</span><br>re.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;010-1234x&#x27;</span>); <span class="hljs-comment">// false</span><br>re.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;010 12345&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a b   c&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\s+/</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p><code>\s</code>: 匹配空格</p><p><code>+</code>: 至少一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a,b, c  d&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[\s\,]+/</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure><p><code>[\s\,]</code>空格或者逗号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a,b;; c  d&#x27;</span>.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[\s\,\;]+/</span>); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>()</code>表示要提取的分组(Group)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;010-12345&#x27;</span>); <span class="hljs-comment">// [&#x27;010-12345&#x27;, &#x27;010&#x27;, &#x27;12345&#x27;]</span><br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;010 12345&#x27;</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>如果正则中定义了组,就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取子串.</p><p><code>exec()</code>匹配成功会返回一个Array,第一个元素就是整个字符串,后面就是匹配成功的<code>分组子串</code></p><p><code>exec()</code>匹配失败返回<code>null</code></p><p>下面看一个<code>识别合法时间</code>的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;19:05:30&#x27;</span>); <span class="hljs-comment">// [&#x27;19:05:30&#x27;, &#x27;19&#x27;, &#x27;05&#x27;, &#x27;30&#x27;]</span><br></code></pre></td></tr></table></figure><p>正则表达有时候写起来其实会很复杂,但是现在有AI.</p><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>正则默认是<code>贪婪匹配</code>模式: 匹配尽可能多的字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/^(\d+)(0*)$/</span>; <br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;102300&#x27;</span>); <span class="hljs-comment">// [&#x27;102300&#x27;, &#x27;102300&#x27;, &#x27;&#x27;]</span><br></code></pre></td></tr></table></figure><p>可以看到<code>\d+</code>采用贪婪匹配,所以把后面的<code>0</code>全匹配了,所以<code>0*</code>就什么都匹配不到.</p><p>通过在<code>量词</code>后面加<code>?</code>停止贪婪匹配(尽可能少匹配)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> re = <span class="hljs-regexp">/^(\d+?)(0*)$/</span>;<br>re.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;102300&#x27;</span>); <span class="hljs-comment">// [&#x27;102300&#x27;, &#x27;1023&#x27;, &#x27;00&#x27;]</span><br></code></pre></td></tr></table></figure><blockquote><p>非贪婪会导致更多回溯,也就是更多的性能消耗,所以尽可能用更精确的pattern而不是用非贪婪.</p></blockquote><h3 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h3><p>JS的特殊标记: <code>g</code>表示全局匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> r1 = <span class="hljs-regexp">/test/g</span>;<br><span class="hljs-comment">// 等价于:</span><br><span class="hljs-keyword">let</span> r2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>);<br></code></pre></td></tr></table></figure><p>全局匹配通过多次执行<code>exec()</code>方法来搜索匹配到的字符.另外每次执行<code>exec()</code>,都会更新<code>lastIndex</code>属性,表示本次匹配到的最后索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;</span>;<br><span class="hljs-keyword">let</span> re=<span class="hljs-regexp">/[a-zA-Z]+Script/g</span>;<br><br><span class="hljs-comment">// 使用全局匹配:</span><br>re.<span class="hljs-title function_">exec</span>(s); <span class="hljs-comment">// [&#x27;JavaScript&#x27;]</span><br>re.<span class="hljs-property">lastIndex</span>; <span class="hljs-comment">// 10</span><br><br>re.<span class="hljs-title function_">exec</span>(s); <span class="hljs-comment">// [&#x27;VBScript&#x27;]</span><br>re.<span class="hljs-property">lastIndex</span>; <span class="hljs-comment">// 20</span><br><br>re.<span class="hljs-title function_">exec</span>(s); <span class="hljs-comment">// [&#x27;JScript&#x27;]</span><br>re.<span class="hljs-property">lastIndex</span>; <span class="hljs-comment">// 29</span><br><br>re.<span class="hljs-title function_">exec</span>(s); <span class="hljs-comment">// [&#x27;ECMAScript&#x27;]</span><br>re.<span class="hljs-property">lastIndex</span>; <span class="hljs-comment">// 44</span><br><br>re.<span class="hljs-title function_">exec</span>(s); <span class="hljs-comment">// null，直到结束仍没有匹配到</span><br></code></pre></td></tr></table></figure><blockquote><p>全局匹配类似搜索,所以不能使用<code>/^...$/</code>,那样只会最多匹配一次.</p></blockquote><p>其他标志:</p><ul><li><code>i</code>标志: 忽略大小写</li><li><code>m</code>标志: 执行多行匹配</li></ul><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>全称: JavaScript Object Notation,是一种数据交换格式.</p><blockquote><p>在JSON出现之前，大家一直用XML来传递数据。因为XML是一种纯文本格式，所以它适合在网络上交换数据。XML本身不算复杂，但是，加上DTD、XSD、XPath、XSLT等一大堆复杂的规范以后，任何正常的软件开发人员碰到XML都会感觉头大了，最后大家发现，即使你努力钻研几个月，也未必搞得清楚XML的规范。</p><p>终于，在2002年的一天，道格拉斯·克罗克福特（Douglas Crockford）同学为了拯救深陷水深火热同时又被某几个巨型软件企业长期愚弄的软件工程师，发明了JSON这种超轻量级的数据交换格式.</p></blockquote><p>JSON实际上JS的一个子集.在JSON中,一共就这么几种数据类型:</p><ul><li>number：和JavaScript的<code>number</code>完全一致；</li><li>boolean：就是JavaScript的<code>true</code>或<code>false</code>；</li><li>string：就是JavaScript的<code>string</code>；</li><li>null：就是JavaScript的<code>null</code>；</li><li>array：就是JavaScript的<code>Array</code>表示方式——<code>[]</code>；</li><li>object：就是JavaScript的<code>&#123; ... &#125;</code>表示方式。</li><li>以及上面的任意组合.</li></ul><p>同时JSON定死了字符集必须是<code>UTF-8</code>,支持多语言.字符串和object的键也规定一定要使用<code>&quot;&quot;</code>,统一解析.</p><p>几乎所有语言都有解析JSON的库,在JS中,可以直接使用JSON,因为JS内置解析.</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>将编程语言的数据类型转成JSON类型,称为<code>序列化</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.65</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&#x27;middle-school&#x27;</span>: <span class="hljs-string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,<br>    <span class="hljs-attr">skills</span>: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>]<br>&#125;;<br><br><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;  &#x27;</span>); <span class="hljs-comment">// 直接使用JSON</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br></code></pre></td></tr></table></figure><p><code>第二个参数</code>可用于筛选对象键值,比如只想输出<code>name</code>和<code>skills</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;skills&#x27;</span>]. <span class="hljs-string">&#x27;  &#x27;</span>);<br></code></pre></td></tr></table></figure><p>还可以传入一个<code>函数</code>,对象的每个键值对都会被函数优先处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">convert</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">toUpperCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming, convert, <span class="hljs-string">&#x27;  &#x27;</span>) <span class="hljs-comment">// 把所有字符串的value转为大写</span><br></code></pre></td></tr></table></figure><p><code>第三个参数</code>表示缩进,上面表示<code>每层缩进</code>两个空格.</p><p>还可以通过定义一个<code>toJSON</code>的方法,精确控制JSON想要序列化的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">14</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.65</span>,<br>    <span class="hljs-attr">grade</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-string">&#x27;middle-school&#x27;</span>: <span class="hljs-string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,<br>    <span class="hljs-attr">skills</span>: [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Lisp&#x27;</span>],<br>    <span class="hljs-attr">toJSON</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 只输出name和age，并且改变了key：</span><br>            <span class="hljs-string">&#x27;Name&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>,<br>            <span class="hljs-string">&#x27;Age&#x27;</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span><br>        &#125;;<br>    &#125;<br>&#125;;<br><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xiaoming); <span class="hljs-comment">// &#x27;&#123;&quot;Name&quot;:&quot;小明&quot;,&quot;Age&quot;:14&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>将JSON转换成编程语言的对象,称为<code>反序列化</code></p><p>JS使用<code>JSON.parse()</code>实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;[1,2,3,true]&#x27;</span>); <span class="hljs-comment">// [1, 2, 3, true]</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="hljs-comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;true&#x27;</span>); <span class="hljs-comment">// true</span><br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;123.45&#x27;</span>); <span class="hljs-comment">// 123.45</span><br></code></pre></td></tr></table></figure><p>可以看出<code>JSON.parse()</code>不仅可以转化json.</p><p>它还可以接收一个函数,用来转换解析出来的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;name&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value + <span class="hljs-string">&#x27;同学&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;); <span class="hljs-comment">// 将JSON转成JS对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)) <span class="hljs-comment">// 将JS对象转成JSON字符串</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-函数</title>
    <link href="/2024/11/06/js-function/"/>
    <url>/2024/11/06/js-function/</url>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>funciton</code>: 定义函数的关键字</li><li><code>abs</code>: 函数名</li><li><code>(x)</code>: 函数参数</li><li><code>&#123;...&#125;</code>: 函数体</li></ul><p>还有一种定义方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> abs = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;; <span class="hljs-comment">// 注意这种方式末尾需要加;</span><br></code></pre></td></tr></table></figure><ul><li><code>function (x) &#123;...&#125;</code>: 是一个匿名函数</li><li><code>abs</code>: 这个匿名函数赋值给了变量abs,所以通过<code>abs</code>就能调用该函数</li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">abs</span>(-<span class="hljs-number">9</span>); <span class="hljs-comment">// 返回9</span><br><span class="hljs-comment">// JS允许传入任意数量的参数,所以不论传多了还是传少了都不影响调用</span><br><span class="hljs-title function_">abs</span>(-<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;haha&#x27;</span>, <span class="hljs-string">&#x27;hehe&#x27;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 返回9</span><br><span class="hljs-title function_">abs</span>(); <span class="hljs-comment">//返回NaN</span><br><span class="hljs-comment">// 此时abs的参数x将收到undefined,计算结果就是NaN</span><br></code></pre></td></tr></table></figure><p>为了避免收到undefined,可以对参数检查</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Not a number&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><code>arguments</code>是js的一个关键字,只能在函数内部起作用,永远指向当前函数的调用者传入的<code>所有参数</code>.类似<code>array</code>但并不是<code>array</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;x = &#x27;</span> + x); <span class="hljs-comment">// 10</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;arg &#x27;</span> + i + <span class="hljs-string">&#x27;=&#x27;</span> + <span class="hljs-variable language_">arguments</span>[i]); <span class="hljs-comment">// 10, 20, 30</span><br>    &#125;<br>&#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>利用<code>arguments</code>就可以获取传入的所有参数,所以即使不定义参数,也能获取传入的参数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">abs</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> ? x : -x; <span class="hljs-comment">// 三元运算符/条件运算符,很多语言都有类似的写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上<code>arguments</code>最常用于判断传入参数的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// foo(a[, b], c)</span><br><span class="hljs-comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 实际拿到的参数是a和b，c为undefined</span><br>        c = b; <span class="hljs-comment">// 把b赋给c</span><br>        b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// b变为默认值</span><br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h2><p>假如你的函数只定义了2个参数,但我们<code>要使用除了前两个已定义参数外的所有参数</code>,此时是使用<code>arguments</code>就会显得很麻烦.ES6后引入了<code>...rest</code>关键字来获取不定参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b, ...rest</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a = &#x27;</span> + a);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b = &#x27;</span> + b);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);<br>&#125;<br><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = 2</span><br><span class="hljs-comment">// Array [ 3, 4, 5 ]</span><br><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 结果:</span><br><span class="hljs-comment">// a = 1</span><br><span class="hljs-comment">// b = undefined</span><br><span class="hljs-comment">// Array []</span><br></code></pre></td></tr></table></figure><ul><li><code>...rest</code>只能写在最后</li><li>如果传入的参数连已定义的参数都没有填满,rest会接收一个空数组(非undefined)</li></ul><h2 id="return不要分行"><a href="#return不要分行" class="headerlink" title="return不要分行"></a>return不要分行</h2><p>因为JS引擎会自动加<code>;</code>,如果return分行写的话容易变成这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 引擎自动加上;</span><br>    &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么返回值就会出错.正确的写法是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    ...<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// &#123; 表示语句还没完结,不会自动加;</span><br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span> <br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><ul><li><p>如果一个变量在函数体内申明,该变量的作用域为整个函数体,函数体外不可引用该变量</p></li><li><p>不同函数内部的同名变量互相独立,互不影响</p></li><li><p>JS的函数可以嵌套,内部函数可以访问外部函数定义的变量,反之则不行</p></li><li><p>JS的函数在查找变量时从自身函数定义开始,如果内部函数定义了与外部函数重名的变量,则以内部变量的定义为准</p></li><li><p>JS会扫描整个函数体的语句,把所有申明的变量<code>提升</code>到函数顶部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;Hello, &#x27;</span> + y; <span class="hljs-comment">// 这里不会报错,因为JS会自动提升变量y的申明</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-comment">// 但是它只提升申明,不提升赋值,所以最终输出会是undefined</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出如下:</span><br><span class="hljs-comment">Hello, undefined.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><p>因此,我们在函数内部定义变量,必须严格遵守<code>在函数内部首先申明所有变量</code>这一原则.最常见的做法是用一个<code>var</code>申明所有用到的变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span><br>    x = <span class="hljs-number">1</span>, <span class="hljs-comment">// x初始化为1</span><br>        y = x + <span class="hljs-number">1</span>, <span class="hljs-comment">// y初始化为2</span><br>        z, i; <span class="hljs-comment">// z,i初始化为undefined</span><br>    <span class="hljs-comment">//其他语句</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ES6后,建议使用<code>let</code>代替<code>var</code>.</p></blockquote><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>不在任何函数内定义的变量就具有<code>全局作用域</code>.JS默认有一个全局对象<code>window</code>,全局作用域的变量都会被绑定成<code>window</code>的一个<code>属性</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> course = <span class="hljs-string">&#x27;Learn JavaScript&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(course);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">course</span>);<br><span class="hljs-comment">// 因此上面两个访问方式等价</span><br></code></pre></td></tr></table></figure><p>同理,函数的另一种定义方式,把匿名函数赋值给变量,这个变量实际上也是一个全局变量.因此,顶层函数的定义也被视为一个全局变量,绑定到<code>window</code>的一个属性.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>&#125;<br><br><span class="hljs-title function_">foo</span>();<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//两种调用同价</span><br></code></pre></td></tr></table></figure><p>其实不难想到,每次调用的<code>alert()</code>函数其实也是<code>window</code>的一个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;调用window.alert()&#x27;</span>);<br><span class="hljs-comment">// 把alert保存到另一个变量:</span><br><span class="hljs-keyword">let</span> old_alert = <span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span>;<br><span class="hljs-comment">// 给alert赋一个新函数:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;无法用alert()显示了!&#x27;</span>);<br><br><span class="hljs-comment">// 恢复alert:</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span> = old_alert;<br><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;又可以用alert()了!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这说明JS<code>只有一个全局作用域</code>,任何变量(函数也被视为变量),如果在当前函数作用域没有找到,就会继续往上查找,最后如果在全局作用域中也没有,就会报<code>ReferenceError</code>.</p><h2 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h2><p>所有全局变量都会绑定到<code>window</code>上,不同的JS文件如果使用了相同的全局变量,或者定义了相同名字的顶层函数,就会造成冲突,而且难以发现.一个解决办法就是,把自己的所有变量和函数全部绑定到一个全局变量中.这个全局变量也被称为<code>名字空间</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 唯一全局变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">MYAPP</span> = &#123;&#125;;<br><br><span class="hljs-comment">// 其他变量</span><br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;myapp&#x27;</span>;<br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">version</span> = <span class="hljs-string">&#x27;1.0&#x27;</span>;<br><br><span class="hljs-comment">// 其他函数</span><br><span class="hljs-variable constant_">MYAPP</span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很多著名的JS库都是这样做: JQuery, YUI, underscore等</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>JS的变量作用域实际上是函数内部,我们在<code>for</code>循环等语句块中无法定义具有局部作用域的变量.</p><p>因此,ES6引入了<code>let</code>关键字,可以用来申明一个块级作用域的变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++) &#123;<br>        sum += i; <span class="hljs-comment">// 块内的可以调用块外的</span><br>    &#125;<br>    i += <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为i是for快内的变量,使用let定义,所以块外无法调用,会报错SynTaxError</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>ES6前,通常用一个全大写的变量来表示”这是一个常量,不要修改它的值”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>ES6后,引入<code>const</code>来定义常量,与<code>let</code>一样都具有块级作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;<br><span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// 某些浏览器不报错,但无效果</span><br><span class="hljs-variable constant_">PI</span>; <span class="hljs-comment">// 依旧是3.14</span><br></code></pre></td></tr></table></figure><h2 id="const-let-var"><a href="#const-let-var" class="headerlink" title="const, let, var"></a>const, let, var</h2><p>首先<code>const</code>用来定义常量,它不可变,具有块级作用域.</p><p>需要特别区分的是<code>let</code>和<code>var</code></p><table><thead><tr><th>区别点</th><th>let</th><th>var</th></tr></thead><tbody><tr><td>作用域</td><td>块级</td><td>函数</td></tr><tr><td>变量提升</td><td><strong>不会</strong>提升(先申明再使用)</td><td>提升申明</td></tr><tr><td>全局对象属性</td><td><strong>不会</strong>加到<code>window</code>的属性</td><td>会加到<code>window</code>的属性</td></tr><tr><td>重复声明</td><td><strong>不允许</strong>,会报错</td><td>允许,值可变</td></tr></tbody></table><p>总结:</p><p>现在JS开发中,推荐使用<code>let</code>和<code>const</code>来替代<code>var</code>.这样可以避免一些常见的作用域相关问题,使代码更可预测和更容易维护.</p><p>某些特殊情况需要用到<code>var</code>:</p><ol><li>老旧浏览器兼容性问题</li><li>特殊的跨作用域访问场景</li><li>特定的闭包使用场景</li></ol><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>一次过赋值多个变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, y, z] = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;ES6&#x27;</span>];<br></code></pre></td></tr></table></figure><p>嵌套的话注意位置保持一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, [y, z]] = [<span class="hljs-string">&#x27;hello&#x27;</span>, [<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;ES6&#x27;</span>]];<br>x; <span class="hljs-comment">// &#x27;hello&#x27;</span><br>y; <span class="hljs-comment">// &#x27;JavaScript&#x27;</span><br>z; <span class="hljs-comment">// &#x27;ES6&#x27;</span><br></code></pre></td></tr></table></figure><p>忽略元素赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [, , z] = [<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;ES6&#x27;</span>]; <span class="hljs-comment">// 忽略前两个元素，只对z赋值第三个元素</span><br>z; <span class="hljs-comment">// &#x27;ES6&#x27;</span><br></code></pre></td></tr></table></figure><p>从一个对象中提取多个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-attr">passport</span>: <span class="hljs-string">&#x27;G-12345678&#x27;</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;No.4 middle school&#x27;</span><br>&#125;;<br><span class="hljs-keyword">let</span> &#123;name, age, passport&#125; = person<br></code></pre></td></tr></table></figure><p>同样,对于嵌套的对象属性也可以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;male&#x27;</span>,<br>    <span class="hljs-attr">passport</span>: <span class="hljs-string">&#x27;G-12345678&#x27;</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;No.4 middle school&#x27;</span>,<br>    <span class="hljs-attr">address</span>: &#123;<br>        <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>        <span class="hljs-attr">street</span>: <span class="hljs-string">&#x27;No.1 Road&#x27;</span>,<br>        <span class="hljs-attr">zipcode</span>: <span class="hljs-string">&#x27;100001&#x27;</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;name, <span class="hljs-attr">address</span>: &#123;city, zip&#125;&#125; = person;<br></code></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>解构赋值可以大大简化代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 交换两个变量的值,不需要临时变量</span><br><span class="hljs-keyword">let</span> x=<span class="hljs-number">1</span>, y=<span class="hljs-number">2</span>;<br>[x, y] = [y, x];<br><span class="hljs-comment">// 快速获取当前页面的域名和路径</span><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">hostname</span>:domain, <span class="hljs-attr">pathname</span>:path&#125; = location; <span class="hljs-comment">// location是浏览器提供的全局对象之一</span><br><br><span class="hljs-comment">// 传一个对象给函数,通过解构,将对象属性直接赋值给参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printUserInfo</span>(<span class="hljs-params">&#123; name, age &#125;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> is <span class="hljs-subst">$&#123;age&#125;</span> years old`</span>);<br>&#125;<br><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span><br>&#125;;<br><span class="hljs-title function_">printUserInfo</span>(user); <span class="hljs-comment">// &quot;Tom is 20 years old&quot;</span><br></code></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>在一个<code>对象</code>中绑定一个<code>函数</code>,该函数即为该对象的<code>方法</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span><br>    &#125;<br>&#125;<br><br>xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// 返回函数自身 f () &#123;...&#125;</span><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 今年调用是25,明年调用就变成26了</span><br></code></pre></td></tr></table></figure><p><code>this</code>类似python的<code>self</code>,是一个特殊变量,始终指向当前对象,也就是<code>xiaoming</code>.然而<code>this</code>有一些地方需要注意:</p><ul><li><p>只有通过<code>obj.function()</code>方式调用,<code>this</code>才能正确指向对象</p></li><li><p>其他调用会直接指向全局对象<code>window</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: getAge<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 25, 正常结果</span><br><span class="hljs-title function_">getAge</span>(); <span class="hljs-comment">// 直接调用,this指向window,自然没有birth这个属性,返回NaN</span><br><br><span class="hljs-comment">// 这样写也是不行的</span><br><span class="hljs-keyword">let</span> fn = xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// 先拿到xiaoming的age函数</span><br><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure></li><li><p><code>strict</code>模式下,错误的调用会让<code>this</code>指向<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>        <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> fn = xiaoming.<span class="hljs-property">age</span>;<br><span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// Uncaught TypeError: Cannot read property &#x27;birth&#x27; of undefined</span><br></code></pre></td></tr></table></figure></li><li><p>内嵌函数内的调用也会指向全局对象,可以先用<code>that</code>关键字捕获</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// 在方法内部一开始就捕获this</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAgeFromBirth</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>();<br>            <span class="hljs-keyword">return</span> y - that.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 用that而不是this</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAgeFromBirth</span>();<br>    &#125;<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>在独立函数调用中的<code>this</code>:</p><ul><li>使用<code>strict</code>,<code>this</code>指向<code>undefined</code></li><li>不用<code>strict</code>,<code>this</code>指向<code>window</code>的属性</li></ul><p>如果要控制<code>this</code>的指向,规定它指向哪个对象,可以使用函数本身的<code>apply</code>方法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">getFullYear</span>();<br>    <span class="hljs-keyword">return</span> y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">age</span>: getAge<br>&#125;;<br><br>xiaoming.<span class="hljs-title function_">age</span>(); <span class="hljs-comment">// 正常调用</span><br>getAge.<span class="hljs-title function_">apply</span>(xiaoming, []); <span class="hljs-comment">// 第一个参数是需要绑定的this对象,第二个参数array,表示需要传给函数的参数</span><br></code></pre></td></tr></table></figure><p>另一个与<code>apply()</code>类似的方法是<code>call()</code>,区别在于:</p><ul><li><code>apply()</code>把参数打包成<code>Array</code>再传入</li><li><code>call()</code>把参数按顺序传入</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]);<br><span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><blockquote><p>对于普通函数的调用,我们通常把<code>this</code>绑定到<code>null</code>.</p><p><code>普通函数</code>是指不依赖任何对象上下文的函数,特别像<code>Math.max()</code>这样的工具函数.与之相对的就是<code>对象的方法</code>.</p><p><code>普通函数</code>根本不会使用<code>this</code>,传入null只是一种约定俗成的做法,表明我们不关心<code>this</code>的值.</p></blockquote><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oldParseInt = <span class="hljs-built_in">parseInt</span>; <span class="hljs-comment">// parseInt是JS的一个全局函数,用于将字符串转换为整数,这里先把它保存起来</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">parseInt</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    count += <span class="hljs-number">1</span>; <span class="hljs-comment">// 添加计数器</span><br><span class="hljs-keyword">return</span> oldParseInt.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">// 调用原始函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实这里就相当于<code>重写parseInt</code>,添加计数器功能,然后通过<code>apply</code>,保留原函数的功能.这样每次调用该函数时都会自动计数.</p><p>这就是JS典型的<code>装饰器(Decorator)模式</code>.</p><p>这种模式一般用于:</p><ul><li>函数调用统计</li><li>性能监控</li><li>日志记录</li><li>调试</li></ul><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p><code>higher-order function</code>: 一个函数以另一个函数作为参数,就称为<code>高阶函数</code>.</p><blockquote><p>JS 的函数都指向某个变量,变量可以指向函数,函数的参数可以接收变量,所以函数可以作为另一个函数的参数.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单的高阶函数例子</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y, f</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(x) + <span class="hljs-title function_">f</span>(y);<br>&#125;<br><br><span class="hljs-title function_">add</span>(-<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">abs</span>)<br></code></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>比如我们有一个函数<code>f(x)=x*x</code>,要对一个数组上的所有元素都使用这个函数,此时就可以使用<code>map</code></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">            f(x) = x * x<br><br>                  │<br>                  │<br>  ┌───┬───┬───┬───┼───┬───┬───┬───┐<br>  │   │   │   │   │   │   │   │   │<br>  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼<br><br>[<span class="hljs-number"> 1 </span> <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 5 </span> <span class="hljs-number"> 6 </span> <span class="hljs-number"> 7 </span> <span class="hljs-number"> 8 </span> <span class="hljs-number"> 9 </span>]<br><br>  │   │   │   │   │   │   │   │   │<br>  │   │   │   │   │   │   │   │   │<br>  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼<br><br>[<span class="hljs-number"> 1 </span> <span class="hljs-number"> 4 </span> <span class="hljs-number"> 9 </span><span class="hljs-number"> 16 </span><span class="hljs-number"> 25 </span><span class="hljs-number"> 36 </span><span class="hljs-number"> 49 </span><span class="hljs-number"> 64 </span><span class="hljs-number"> 81 </span>]<br></code></pre></td></tr></table></figure><p>JS的<code>map()</code>定义在<code>Array</code>中,所以我们调用<code>Array</code>的<code>map()</code>,传入自己的函数,就得到一个新得<code>Array</code>返回.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pow</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br><span class="hljs-keyword">let</span> results = arr.<span class="hljs-title function_">map</span>(pow);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results)<br></code></pre></td></tr></table></figure><p>当然,我们也可以写个循环实现上面的目的.但是<code>map()</code>作为高阶函数,事实上它把运算规则抽象了,所以我们可以根据传入的函数,实现各种复杂的操作,代码还能保持简单明了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 比如把Array所有数字转为字符串,只需一行代码</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">map</span>(<span class="hljs-title class_">String</span>); <span class="hljs-comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>reduce</code>同样也是作用在<code>array</code>的每个元素上,但是它是<code>累积</code>的.</p><p>比如通过<code>reduce</code>把函数<code>f(x)</code>作用在<code>[x1, x2, x3, x4]</code>上,其效果就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[x1, x2, x3, x4].<span class="hljs-title function_">reduce</span>(f) = <span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(x1, x2), x3), x4)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;); <span class="hljs-comment">//25</span><br></code></pre></td></tr></table></figure><p>如果数组元素只有一个,就要提供一个<code>额外的初始参数</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">123</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;, <span class="hljs-number">0</span>); <span class="hljs-comment">// 额外的初始参数0</span><br></code></pre></td></tr></table></figure><p>把<code>[1, 3, 5, 7, 9]</code>变成一个整数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>];<br>arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y;<br>&#125;);<br></code></pre></td></tr></table></figure><p>不使用<code>parseInt()</code>,利用<code>map</code>和<code>reduce</code>,把<code>&#39;13579&#39;</code>转为<code>数字</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">string2int</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = s.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>); <span class="hljs-comment">//空字符串作为分隔符,逐一字符提取成array</span><br>    <span class="hljs-keyword">let</span> a = arr.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-keyword">return</span> x - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// - &#x27;0&#x27;是JS的一个常用技巧,当&#x27;0&#x27;参与运算,JS会自动把它转为Number,包括最后结果的值也会是Number</span><br>        <span class="hljs-comment">// return + x; 这叫一元加号运算符,也是可以把字符串转为数字的一个技巧</span><br>    &#125;); <br>    <span class="hljs-keyword">let</span> result = a.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 13579</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code>用于把<code>array</code>的某些元素过滤掉,返回剩下的.</p><p><code>filter</code>把传入的<code>函数</code>依次作用到<code>array</code>每个元素,根据返回值<code>true/false</code>来决定保留还是丢弃.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例如踢出偶数</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<br><span class="hljs-keyword">let</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span>;<br>&#125;);<br>r; <span class="hljs-comment">// [1, 5, 9, 15]</span><br><br><span class="hljs-comment">// 删除空字符串</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;   &#x27;</span>];<br><span class="hljs-keyword">let</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s &amp;&amp; s.<span class="hljs-title function_">trim</span>();<br>&#125;);<br>r; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><blockquote><p> <code>callback function</code>是一个编程概念.作为参数传递给另一个函数的函数,则称为<code>回调函数</code>.当某个事件发生或特定条件满足时,这个被传递的函数就会被”调用回来”执行.</p></blockquote><p><code>filter</code>接收的回调函数其实可以由多个参数:</p><ol><li>第一个: 表示<code>array</code>的某个元素</li><li>第二个: 表示元素的位置</li><li>第三个: 数组本身</li></ol><p>类似的还有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">reduce</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">map</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">let</span> r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, self</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element); <span class="hljs-comment">// 依次打印&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 依次打印0, 1, 2</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(self); <span class="hljs-comment">// self就是变量arr</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>用<code>filter</code>去除重复元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <br>r,<br>    arr = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;strawberry&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;strawberry&#x27;</span>];<br><br>r = arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, self</span>) &#123;<br>    <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">indexOf</span>(element) === index; <span class="hljs-comment">// indexOf返回array中element的第一次出现的索引,如果当前索引index不等于indexOf返回的,说明该元素不是第一次出现,需要过滤掉</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><blockquote><p>排序的核心是比较两个元素的大小,但是如果元素是字符串,在数学上则无法比较.因此比较的过程必须抽象出来.通常规定:</p><ul><li><code>x&lt;y</code>返回<code>-1</code></li><li><code>x=y</code>返回0</li><li><code>x&gt;y</code>返回1</li></ul><p>排序算法不关心具体的比较过程,只根据结果排序.</p></blockquote><p>JS 的<code>array</code>有个<code>sort()</code>方法,然而有点坑爹.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 看上去正常的结果:</span><br>[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [&#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Microsoft&#x27;];</span><br><br><span class="hljs-comment">// apple排在了最后:</span><br>[<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [&#x27;Google&#x27;, &#x27;Microsoft&quot;, &#x27;apple&#x27;]</span><br><br><span class="hljs-comment">// 无法理解的结果:</span><br>[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// [1, 10, 2, 20]</span><br></code></pre></td></tr></table></figure><p>第二个排序<code>apple</code>排在最后,那时因为小写字母<code>a</code>的ASCII码在大写字母之后.</p><p>第三个则是因为,<code>sort()</code>默认把所有元素先转换成<code>String</code>再排序,结果<code>&#39;10&#39;</code>排在<code>&#39;2&#39;</code>前面,因为<code>&#39;1&#39;</code>的ASCII码比<code>&#39;2&#39;</code>小.</p><p>还好的是<code>sort()</code>是一个高阶函数,我们可以自己实现比较函数传进去比较.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, 2, 10, 20]</span><br></code></pre></td></tr></table></figure><p>如果要实现倒序排序,可以这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>    <span class="hljs-keyword">return</span> y - x;<br>&#125;); <span class="hljs-comment">// [20, 10, 2, 1]</span><br></code></pre></td></tr></table></figure><blockquote><p><code>y-x</code>:</p><ul><li>如果<code>x&lt;y</code>,则返回正数</li><li>如果<code>x&gt;y</code>,则返回负数</li><li>如果<code>x=y</code>,则返回0</li></ul><p>天才</p></blockquote><p>默认情况下对字符串排序是通过比较ASCII码来实现,那如果想忽略大小写来排序呢?也不难,把元素全部转为大写&#x2F;小写再比较就行了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>];<br>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s1, s2</span>) &#123;<br>    x1 = s1.<span class="hljs-title function_">toUpperCase</span>();<br>    x2 = s2.<span class="hljs-title function_">toUpperCase</span>();<br>    <span class="hljs-keyword">if</span> (x1 &lt; x2) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x1 &gt; x2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后从上面不难看出,<code>sort()</code>是会<code>直接修改原array</code>的.这个要注意一下.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a1 = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">let</span> a2 = a1.<span class="hljs-title function_">sort</span>();<br>a1; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br>a2; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br>a1 === a2; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="array的其他高阶函数"><a href="#array的其他高阶函数" class="headerlink" title="array的其他高阶函数"></a>array的其他高阶函数</h2><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><p>用于判断数组的<code>所有元素</code>是否满足测试条件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;<br>&#125;)); <span class="hljs-comment">// true, 因为所有元素都满足s.length &gt; 0</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// false,因为不是每个元素都是小写</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于查找符合条件的<code>第一个</code>元素,找到就返回该元素,否则就返回<code>undefined</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// &#x27;pear&#x27;, 因为pear全是小写</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">find</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toUpperCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// 返回undefined,因为没有全是大写的元素</span><br></code></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p>与<code>find</code>类似,也是找符合条件的<code>第一个</code>元素,但是它返回的是index,没有找到则返回<code>-1</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toLowerCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// 1, 因为&#x27;pear&#x27;的索引是1</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">toUpperCase</span>() === s;<br>&#125;)); <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>这个跟<code>map()</code>类似,也是把每个元素依次作用与传入的函数,但不会返回新数组.</p><p><code>forEach</code>常用于遍历数组,传入的函数不需要返回值.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">x</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)); <span class="hljs-comment">// 依次打印每个元素</span><br></code></pre></td></tr></table></figure><h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p><code>高阶函数</code>除了可以接收函数作为参数,还可以<code>返回函数</code>.</p><p>比如我们要实现一个对<code>array</code>的求和函数,但是我们不需要立即求和,而是在后面的代码中根据需要再计算:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy_sum</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) &#123;<br>            <span class="hljs-keyword">return</span> x + y;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum; <span class="hljs-comment">// 返回函数</span><br>&#125;<br><br><span class="hljs-keyword">let</span> f = <span class="hljs-title function_">lazy_sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]); <span class="hljs-comment">// 这里返回的就是一个函数</span><br><span class="hljs-title function_">f</span>(); <span class="hljs-comment">// 15</span><br><span class="hljs-keyword">let</span> f2 = <span class="hljs-title function_">lazy_sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);<br>f === f2; <span class="hljs-comment">// false; 每次返回都会是一个全新的函数</span><br></code></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p><code>闭包</code>是JS的一个重要特性,指的是函数能够记住并访问它的词法作用域,即使当这个函数在其原始作用域之外执行时也能正常工作.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 私有变量</span><br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 返回一个函数填充的array</span><br>        <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;,<br>        <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// 0</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面的例子说明,即使变量是定义在<code>函数内部</code>的,但是通过<code>return</code>返回的函数依旧可以<code>正常访问/修改</code>私有变量.因为返回函数形成了<code>闭包</code>.</p><p>但有一点要注意,<code>返回的函数</code>并<code>不会在返回时执行</code>,而是在<code>实际调用的才会执行</code>.</p><h3 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// var是函数作用域申明,所有推入数组得函数都会引用同一个i</span><br>        arr.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> i * i;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">count</span>();<br><span class="hljs-keyword">let</span> [f1, f2, f3] = result;<br><span class="hljs-comment">// 再加上闭包,函数在被调用时才会执行,所以当执行返回的函数时,i已经变成4</span><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 16</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 16</span><br></code></pre></td></tr></table></figure><p>要避免这种陷阱,你可以:</p><ol><li><p>使用<code>let</code>代替<code>var</code>,<code>let</code>作用域决定了每次循环都会绑定新的<code>i</code>.(recommend)</p></li><li><p>创建<code>立即执行函数</code>,这是JS的一个语法,用于<code>创建一个匿名函数并立刻执行</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br>        arr.<span class="hljs-title function_">push</span>((<span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">return</span> n * n;<br>            &#125;<br>        &#125;)(i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">let</span> [f1, f2, f3] = <span class="hljs-title function_">count</span>();<br><br><span class="hljs-title function_">f1</span>(); <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">f2</span>(); <span class="hljs-comment">// 4</span><br><span class="hljs-title function_">f3</span>(); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><p>这里再创建了一个函数,用该函数的参数绑定循环变量的当前值,无论该循环后续如何更改,已绑定到函数参数的值不变.</p><p>可以看出,里面嵌套很复杂,最好还是不要用这种,这里更多是为了引出<code>创建一个匿名函数并立刻执行</code>的语法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 理论上讲,创建一个匿名函数并立刻执行可以这么写</span><br><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> x * x&#125; (<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 但是JS语法解析的问题,需要用括号把函数括起来,不然会报SyntaxError</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<span class="hljs-keyword">return</span> x * x&#125;) (<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 通常会把它拆开写,好看点</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;) (<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></li><li><p>不要在返回函数中引用循环变量.(recommend)</p></li></ol><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>JS的闭包除了返回一个函数,延迟执行外,还有一个最强大的功能,就是在<code>对象内部封装一个私有变量</code>.</p><p>想java和c++,可以用<code>private</code>,但JS没有<code>class</code>只有函数,需要借助闭包,封装私有变量.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create_counter</span>(<span class="hljs-params">initial</span>) &#123;<br>    <span class="hljs-keyword">let</span> x = initial || <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果initial有值就使用initial,否则为0, 一种设置默认值的简写方式</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">inc</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            x += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//用起来是这样的</span><br><span class="hljs-keyword">let</span> c1 = <span class="hljs-title function_">create_counter</span>();<br>c1.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 1</span><br>c1.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 2</span><br>c1.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">let</span> c2 = <span class="hljs-title function_">create_counter</span>(<span class="hljs-number">10</span>);<br>c2.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 11</span><br>c2.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 12</span><br>c2.<span class="hljs-title function_">inc</span>(); <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>在返回的对象中,实现了一个闭包,闭包携带了局部变量<code>x</code>,并且这个<code>x</code>无法被访问.换句话说,闭包就是携带状态的函数,并且它的状态可以完全对外隐藏起来.</p><h3 id="创建新函数"><a href="#创建新函数" class="headerlink" title="创建新函数"></a>创建新函数</h3><p>举个例子: 闭包还可以把多参数的函数变成单参数的函数.比如要计算<code>x^y</code>可以用<code>Math.pow(x, y)</code>函数,不过考虑到经常计算x^2或x^3,可以利用闭包创建新的函数<code>pow2</code>或<code>pow3</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">make_pow</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x, n)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 创建两个新函数</span><br><span class="hljs-keyword">let</span> pow2 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">let</span> pow3 = <span class="hljs-title function_">make_pow</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow2</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 25</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">pow3</span>(<span class="hljs-number">7</span>)); <span class="hljs-comment">// 343</span><br></code></pre></td></tr></table></figure><p>这种做法也被称为<code>函数工厂</code>,这种函数也被称为<code>工厂函数</code>.</p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6新增一种新的函数: <code>箭头函数</code>,因为它的定义就是一个箭头<code>=&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; x * x<br><span class="hljs-comment">// 上面的箭头函数相当于</span><br><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数相当于<code>匿名函数</code>,并且简化了函数定义.它有两种定义格式:</p><ol><li><p>像上面的,只包含一个表达式,<code>&#123;...&#125;</code>和<code>return</code>都省略</p></li><li><p>包含多种语句的,不能省略<code>&#123;...&#125;</code>和<code>return</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> x * x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> - x * x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>如果参数不是只有一个,就要用<code>()</code>括起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 两个参数</span><br>(x, y) =&gt; x * x + y* y;<br><span class="hljs-comment">// 没有参数</span><br><span class="hljs-function">() =&gt;</span> <span class="hljs-number">3.14</span>;<br><span class="hljs-comment">// 可变参数</span><br><span class="hljs-function">(<span class="hljs-params">x, y, ...rest</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> i, sum = x + y;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;rest.<span class="hljs-property">length</span>; i++) &#123;<br>        sum += resy[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果返回一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x =&gt; &#123;<span class="hljs-attr">foo</span>: x&#125; <span class="hljs-comment">// 这样写是错误的SynctaxError,因为和函数体&#123;...&#125;有语法冲突</span><br>x =&gt; (&#123;<span class="hljs-attr">foo</span>: x&#125;) <span class="hljs-comment">// 加个括号就可以了</span><br></code></pre></td></tr></table></figure><h3 id="this修复"><a href="#this修复" class="headerlink" title="this修复"></a>this修复</h3><p><strong>箭头函数没有自己的 <code>this</code> 绑定</strong>。箭头函数会捕获其被定义时的上下文的 <code>this</code> 值，而且这个绑定是永久的，不能被改变。</p><blockquote><p><code>词法作用域</code>(Lexical scope):</p><p>是指变量的作用域在代码编写时(词法分析时)就已经确定,而不是在运行时确定.简单来说,就是变量的访问权限由变量定义的位置决定.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">bitrh</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>        <span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// this指向window或undefined</span><br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 箭头函数</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">bitrh</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 使用了箭头函数,this指向外部域,也就是getAge函数的域</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来两个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例子一</span><br><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>    <span class="hljs-comment">// 普通函数</span><br>    <span class="hljs-attr">sayHiNormal</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;,<br>    <span class="hljs-comment">// 箭头函数没有自己的this,只能捕获定义时所在上下文的this值</span><br>    <span class="hljs-attr">sayHiArrow</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>    &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">sayHiNormal</span>(); <span class="hljs-comment">// Hi, 张三</span><br>obj.<span class="hljs-title function_">sayHiArrow</span>(); <span class="hljs-comment">// Hi, undefined (因为箭头函数的this指向外部作用域)</span><br><br><span class="hljs-comment">// 例子二</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>;  <span class="hljs-comment">// 这里的 this 指向 obj</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getFullYear</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <br>        <span class="hljs-comment">// 箭头函数在 getAge 函数内部定义</span><br>        <span class="hljs-comment">// 所以它继承了 getAge 的 this，即 obj</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>第一个例子的箭头函数直接在<code>对象字面量</code>中定义,所以继承了<code>全局作用域的this</code></p><blockquote><p>对象字面量: 直接使用<code>&#123;&#125;</code>创建对象的语法</p></blockquote><p>第二个例子的箭头函数在普通函数<code>getAge</code>内定义,继承外部作用域,也就是<code>getAge</code>的<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 再来一个例子</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">getAge</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">year</span>) &#123;<br>        <span class="hljs-keyword">let</span> b = <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 1990</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">y</span>) =&gt; y - <span class="hljs-variable language_">this</span>.<span class="hljs-property">birth</span>; <span class="hljs-comment">// 由于箭头函数的this是上下文决定的,所以这里的this和getAge函数保持一致,都是被调用时的对象.</span><br>        <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">birth</span>:<span class="hljs-number">2000</span>&#125;, year); <span class="hljs-comment">// 此时用call去调用fn,第一个参数要传入一个调用对象,但是由于箭头函数的this不可改变,所以依旧是obj</span><br>    &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">getAge</span>(<span class="hljs-number">2015</span>); <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h1 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h1><p>对于<code>模板字符串</code>,除了方便引用变量构造字符串外,还有一个更强大的功能,就是使用<code>标签函数</code>(tag function)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 模板字符串</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">let</span> s = <span class="hljs-string">`你好, <span class="hljs-subst">$&#123;name&#125;</span>, 你今年<span class="hljs-subst">$&#123;age&#125;</span>岁了!`</span>;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> email = <span class="hljs-string">&#x27;test@example.com&#x27;</span>;<br><span class="hljs-keyword">const</span> password = <span class="hljs-string">&#x27;hello123&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sql</span>(<span class="hljs-params">string, ...exps</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SQL: <span class="hljs-subst">$&#123;string.join(<span class="hljs-string">&#x27;?&#x27;</span>)&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`SQL paramenters: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(exps)&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> result = sql<span class="hljs-string">`SELECT * FROM users WHERE email=<span class="hljs-subst">$&#123;email&#125;</span> AND password=<span class="hljs-subst">$&#123;password&#125;</span>`</span>; <span class="hljs-comment">// 标签函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result));<br></code></pre></td></tr></table></figure><p>模板字符串以特定标签函数名开头,就是标签函数的调用方式.</p><p>上面就是调用标签函数<code>sql()</code>.</p><p>标签函数接收两个参数:</p><ul><li><p>将模板字符串的<code>字符串部分,转换成数组</code>,赋值给第一个参数<code>string</code>,上面的例子就是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&quot;SELECT * FROM users WHERE email=&quot;</span>, <span class="hljs-string">&quot; AND password=&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>将模板字符串的<code>变量部分,转换成数组</code>,解析后传给不定参数<code>...exps</code>,也就是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&quot;test@example.com&quot;</span>, <span class="hljs-string">&quot;hello123&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>先在内部把<code>strings</code>转换成SQL字符串,然后把<code>...exps</code>作为参数,就可以实现一个安全的SQL查询.例如这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> sql = strings.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;?&#x27;</span>);<br>    <span class="hljs-comment">// 执行数据库更新</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span><br>&#125;<br><br><span class="hljs-comment">// 调用非常简洁</span><br><span class="hljs-keyword">let</span> id = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">21</span>;<br><span class="hljs-keyword">let</span> score = <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>update<span class="hljs-string">`UPDATE users SET age=<span class="hljs-subst">$&#123;age&#125;</span>, score=<span class="hljs-subst">$&#123;score&#125;</span> WHERE id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>ES6引入的新数据类型,一个生成器看上去像一个函数,但可以<code>返回多次</code>.定义JS生成器标准的哥们借鉴了python生成器的概念和语法.</p><p>函数在执行过程中如果没有遇到<code>return</code>,控制权无法交回被调用的代码.(函数如果没有显式声明<code>return</code>,默认都会有一个<code>return undefined</code>).生成器与函数类似,定义如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) &#123;<br>    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> x + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>function*</code>,定义时比函数多一个<code>*</code></li><li>除了<code>return</code>,还可以用<code>yield</code>返回多次</li></ul><p>举个例子, 斐波那契数列:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">0 1 1 2 3 5 8 13 21 34 ...<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数方式生成,返回array</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">max</span>) &#123;<br>    <span class="hljs-keyword">let</span><br>    t,<br>        a = <span class="hljs-number">0</span>,<br>        b = <span class="hljs-number">1</span>,<br>        arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (arr.<span class="hljs-property">length</span> &lt; max) &#123;<br>        [a, b] = [b, a + b];<br>        arr.<span class="hljs-title function_">push</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-title function_">fib</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// [0, 1, 1, 2, 3]</span><br><span class="hljs-title function_">fib</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span><br></code></pre></td></tr></table></figure><p>那么跟python类似的,当数据量无限增大,这个函数在内存的占用也会无限增大,所以使用<code>生成器</code>是个更好的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 生成器</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fib</span>(<span class="hljs-params">max</span>) &#123;<br>    <span class="hljs-keyword">let</span><br>    t,<br>        a = <span class="hljs-number">0</span>,<br>        b = <span class="hljs-number">1</span>,<br>        n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &lt; max) &#123;<br>        <span class="hljs-keyword">yield</span> a;<br>        [a, b] = [b, a + b];<br>        n ++;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 调用生成器一: 使用next()</span><br><span class="hljs-title function_">fib</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// fib &#123;[[GeneratorStatus]]: &quot;suspended&quot;, [[GeneratorReceiver]]: Window&#125;</span><br>f = <span class="hljs-title function_">fib</span>(<span class="hljs-number">5</span>);<br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 0, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 1, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: 3, done: false&#125;</span><br>f.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br><br><span class="hljs-comment">// 方法二: for...of,不需要自己判断done</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> <span class="hljs-title function_">fib</span>(<span class="hljs-number">10</span>)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 依次输出</span><br>&#125;<br></code></pre></td></tr></table></figure><p>生成器可以看成一个<code>可以记住执行状态的函数</code>.</p><p>需要注意的是生成器执行到<code>yeild</code>就会结束,要让它保持生成多个元素,一般都需要加个<code>循环</code>包裹.</p>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-入门</title>
    <link href="/2024/11/04/js-begining/"/>
    <url>/2024/11/04/js-begining/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202411051006998.png" srcset="/img/loading.gif" lazyload alt="1_LyZcwuLWv2FArOumCxobpA"></p><h1 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h1><p><code>Mozilla Developer Network</code>是一个非常重要的Web技术文档平台.由Mozilla维护,包括HTML,CSS,JavaScript等各种web技术的完整文档.许多开发者都视其为Web开发的官方参考手册.</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN web doc</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol><li>JavaScript和Java除了语法上有点像以外毫无关系.但是java非常火,网景公司希望蹭热度推广JS,就改了这么个名字.</li><li>ECMAScript: 网景开发了JS,一年后微软又模仿开发了JScript.为了JS成为全球标准,几个公司联合ECMA组织定制了JS语言的标准,称为ECMAScript.所以这个标准就是为了JS而生.也称<code>ES</code>标准.其实<code>ES6</code>是一个重大更新.</li><li>JS设计到诞生只用了10天时间,所以无法避免,很多设计缺陷.</li></ol><h1 id="集成与运行"><a href="#集成与运行" class="headerlink" title="集成与运行"></a>集成与运行</h1><p>JS代码可以集成到网页的任何地方,不过一般放在<code>&lt;head&gt;</code>中,用<code>&lt;script&gt;&lt;/script&gt;</code>包起来,或者使用<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入JS文件.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 方式一 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, world&#x27;</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 方式二 推荐 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/static/js/abc.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 可以引入多个js文件, 浏览器会按顺序执行 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/static/js/def.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- type属性其实是没必要的,因为默认就是text/javascript --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>, <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/static/js/ghi.js&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用<code>chrome</code>随便打开一个网页,按<code>F12</code>–&gt; 点解<code>console</code>tab,即刻在那里执行你的js代码.</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><ul><li>每个语句以<code>;</code>结尾,虽然这不是强制的,因为浏览器中负责执行js代码的引擎会自动补上,但是<code>建议不要忽略</code>,因为有些情况下引擎会理解错误加错分号导致语义改变.</li><li>语句块用<code>&#123;...&#125;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个完整的赋值语句</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 字符串</span><br><span class="hljs-string">&#x27;hello world&#x27;</span>;<br><span class="hljs-comment">// 一个;表示一个语句,不建议一行写多个语句!</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>; <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 语句块</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>) &#123;<br>    x = <span class="hljs-number">1</span>;<br>    y = <span class="hljs-number">2</span>;<br>    z = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>        z = <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>        z = <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">缩进也不是强制的,但是建议一定要有缩进,可以帮助理解代码的层次</span><br><span class="hljs-comment">嵌套没有限制,但过多的嵌套会导致代码难以理解</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>注意: <code>JS严格区分大小写</code></p><h1 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h1><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>JS不缺分整数和浮点数,统一用Number表示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">123</span>; <span class="hljs-comment">//整数</span><br><span class="hljs-number">0.456</span>; <span class="hljs-comment">//浮点数</span><br><span class="hljs-number">1.2345e3</span>; <span class="hljs-comment">//科学计数法表示1.2345*10^3,就是1234.5</span><br>-<span class="hljs-number">99</span>; <span class="hljs-comment">//负数</span><br><span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// NaN表示Not a Number,当无法计算结果时用NaN表示</span><br><span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">//表示无限大,当数值不超过了JS的Number所能表示的最大值时,就表示为Infinity</span><br><br><span class="hljs-comment">// number可以四则运算,规则和数学一致</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 3</span><br>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">2</span>; <span class="hljs-comment">// 7.5</span><br><span class="hljs-number">2</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// Infinity</span><br><span class="hljs-number">0</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// NaN</span><br><span class="hljs-number">10</span> % <span class="hljs-number">3</span>; <span class="hljs-comment">// 1 (%求余)</span><br><span class="hljs-number">10.5</span> % <span class="hljs-number">3</span>; <span class="hljs-comment">// 1.5</span><br><br><span class="hljs-comment">//因为js不区分整数和浮点数,所以</span><br><span class="hljs-number">12.00</span> == <span class="hljs-number">12</span><br><span class="hljs-comment">// js的最大整数范围为+-2^53</span><br><span class="hljs-comment">// 计算圆面积</span><br><span class="hljs-keyword">var</span> r = <span class="hljs-number">123.456</span>;<br><span class="hljs-keyword">var</span> s = <span class="hljs-number">3.14</span> * r * r;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s);<br><span class="hljs-comment">// 打印Number能表示的最大整数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_SAFF_INTEGER</span>);<br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>使用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的任意文本</p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p><code>true</code>&#x2F;<code>false</code>, 支持布尔运算<code>与</code>&#x2F;<code>或</code>&#x2F;<code>非</code>: <code>&amp;&amp;</code>&#x2F;<code>||</code>&#x2F;<code>!</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span>; <span class="hljs-comment">// 这个&amp;&amp;语句计算结果为true</span><br><span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>; <span class="hljs-comment">// 这个||语句计算结果为true</span><br>! <span class="hljs-literal">false</span>; <span class="hljs-comment">// 结果为true</span><br>! (<span class="hljs-number">2</span> &gt; <span class="hljs-number">5</span>); <span class="hljs-comment">// 结果为true</span><br></code></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span><br><span class="hljs-number">2</span> &gt;= <span class="hljs-number">3</span>; <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure><p>js<code>允许任意数据类型</code>做对比,注意相等运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">false</span> == <span class="hljs-number">0</span>; <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> === <span class="hljs-number">0</span>; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>js有两种相等运算符: </p><p><code>==</code>: 它会自动转换数据类型,很多时候会得到奇怪的结果</p><p><code>===</code>: 表示不自动转换类型,如果类型不一致,返回<code>false</code>,如果一致再比较</p><p>这是js的一个设计缺陷,所以要<strong>注意</strong>: 始终坚持使用<code>===</code>来比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 有一个例外,NaN这个特殊的Number与所有其他值都不相等,包括它自己</span><br><span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 唯一能判断NaN的是只有</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">NaN</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注意浮点型数的比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> / <span class="hljs-number">3</span> === (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> / <span class="hljs-number">3</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>这就不是设计缺陷了,而是因为计算机无法精确表示无限循环小数.要比较两个浮点数是否相等,只能计算他们的差的绝对值,看看是否少于某个阈值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(<span class="hljs-number">1</span> / <span class="hljs-number">3</span> - (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> / <span class="hljs-number">3</span>)) &lt; <span class="hljs-number">0.0000001</span>; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>js内置的<code>BigInt</code>类型可以用来表示比2^53还要大的数,表示方法是整数后加一个<code>n</code>,或者使用<code>BigInt()</code>把字符串和Number转换成BigInt</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用BigInt:</span><br><span class="hljs-keyword">var</span> bi1 = <span class="hljs-number">9223372036854775807n</span>;<br><span class="hljs-keyword">var</span> bi2 = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">12345</span>);<br><span class="hljs-keyword">var</span> bi3 = <span class="hljs-title class_">BigInt</span>(<span class="hljs-string">&quot;0x7fffffffffffffff&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bi1 === bi2); <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bi1 === bi3); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bi1 + bi2);<br></code></pre></td></tr></table></figure><p>BigInt也可以正常加减乘除,结果依然是一个BigInt,但BigInt和Number不能放一齐运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1234567n</span> + <span class="hljs-number">3456789n</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1234567n</span> / <span class="hljs-number">789n</span>); <span class="hljs-comment">// 1564, 除法运算结果仍然是BigInt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1234567n</span> % <span class="hljs-number">789n</span>); <span class="hljs-comment">// 571, 求余</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1234567n</span> + <span class="hljs-number">3456789</span>); <span class="hljs-comment">// Uncaught TypeError: Cannot mix BigInt and other types</span><br></code></pre></td></tr></table></figure><h2 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h2><ul><li><code>null</code>表示一个空值,不同于<code>0</code>和空字符串<code>&#39;&#39;</code>,它就是表示<code>空</code>,类似python的<code>None</code>,java的<code>null</code>和swift的<code>nil</code></li><li>js的设计者希望用<code>null</code>表示空值,<code>undefined</code>表示值未定义.但事实上这并没有什么卵用.</li><li>大多数情况下,我们都用<code>null</code>,仅仅在判断函数参数是否传递的情况下使用<code>undefined</code>.</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一组按顺序排列的集合,集合的每个值称为元素.元素可以是任意数据类型.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 两种创建方式</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>]; <span class="hljs-comment">// 强烈建议使用这一种</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <br><span class="hljs-comment">// 元素使用索引(index)来访问,从0开始</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>];<br>arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 返回索引为0的元素,就是1</span><br>arr[<span class="hljs-number">6</span>]; <span class="hljs-comment">// 索引超出范围,返回undefined</span><br></code></pre></td></tr></table></figure><p>类比python的list</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>键-值对的无序集合,<code>键</code>都是<code>字符串类型</code>,<code>值</code>可以是<code>任意类型</code>.</p><p><code>键</code>又称为对象的<code>属性</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">tags</span>: [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;web&#x27;</span>, <span class="hljs-string">&#x27;mobile&#x27;</span>],<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>,<br>    <span class="hljs-attr">hasCar</span>: <span class="hljs-string">&#x27;true&#x27;</span>,<br>    <span class="hljs-attr">zipcode</span>: <span class="hljs-literal">null</span><br>&#125;<br><br><span class="hljs-comment">// 获取特定属性</span><br>person.<span class="hljs-property">name</span>;<br>person.<span class="hljs-property">zipcode</span>;<br></code></pre></td></tr></table></figure><p>类比python的字典或groovy的map</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>使用<code>var</code>关键字来声明</li><li>变量名可以是:<ul><li>大小写英文</li><li>数字</li><li><code>$</code>和<code>_</code>的组合,不能用数字开头</li><li>不能是JS的关键字</li><li>也可以用中文,但是,请不要自找麻烦</li></ul></li><li>用<code>=</code>赋值</li><li>可以反复赋值,但只能用<code>var</code>声明一次</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a; <span class="hljs-comment">// 申明了变量a，此时a的值为undefined</span><br><span class="hljs-keyword">var</span> $b = <span class="hljs-number">1</span>; <span class="hljs-comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span><br><span class="hljs-keyword">var</span> s_007 = <span class="hljs-string">&#x27;007&#x27;</span>; <span class="hljs-comment">// s_007是一个字符串</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Answer</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Answer是一个布尔值true</span><br><span class="hljs-keyword">var</span> t = <span class="hljs-literal">null</span>; <span class="hljs-comment">// t的值是null</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>; <span class="hljs-comment">// 多次赋值只能使用一次var</span><br>a = <span class="hljs-string">&#x27;ABC&#x27;</span><br></code></pre></td></tr></table></figure><p>这种变量赋值不固定的语言就是<code>动态语言</code>,比如python也是.java则是静态语言.</p><h2 id="strict模式"><a href="#strict模式" class="headerlink" title="strict模式"></a>strict模式</h2><p>JS设计之初并没有强制要求使用<code>var</code>申明变量,这导致了一个严重的后果: 如果一个变量没有通过<code>var</code>申明就被使用,该变量就自动被申明为<code>全局变量</code>:</p><p>也就是同一页面的的不同js文件中公用的一个变量,假如不同js文件都使用了同样一个变量名的变量,就会相互影响.</p><p>使用<code>var</code>声明的变量,它的范围会限制在该变量被申明的函数体内,同名变量就不会冲突.</p><p>为了弥补这个严重的设计缺陷,ECMA后续退出了<code>strict模式</code>,开启该模式后,如果未使用<code>var</code>申明变量就使用,就会导致运行错误.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在js代码的第一行上写上即刻开启</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-comment">// 这是一个字符串,不支持strict模式的浏览器会把它当作一个字符串语句执行,支持的则会开启strict模式</span><br></code></pre></td></tr></table></figure><p>建议所有js都开启<code>strict</code>模式.</p><p>还有一种申明变量的方式是<code>let</code>,这也是现代js推荐的一种方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 用let申明变量:</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s)<br></code></pre></td></tr></table></figure><blockquote><p>现代JS编程中基本不使用<code>var</code>而是使用<code>const</code>+<code>let</code>的组合来定义变量</p></blockquote><h1 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h1><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>除了常见的转义功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以以`\x##`形式用十六进制表示ASCII字符</span><br><span class="hljs-string">&#x27;\x41&#x27;</span>; <span class="hljs-comment">// 完全等同于&#x27;A&#x27;</span><br><span class="hljs-comment">// 还可以用`\u####`形式表示一个Unicode字符</span><br><span class="hljs-string">&#x27;\u4e2d\u6587&#x27;</span>; <span class="hljs-comment">// 完全等同于 &#x27;中文&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>有点特别,ES6后,js使用反引号表示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">`这是一个</span><br><span class="hljs-string">多行</span><br><span class="hljs-string">字符串`</span>;<br></code></pre></td></tr></table></figure><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>与python和groovy类似,使用<code>+</code>号连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;小明&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-string">&#x27;20&#x27;</span>;<br><span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;你好,&#x27;</span> + name + <span class="hljs-string">&#x27;,你今年&#x27;</span> + age + <span class="hljs-string">&#x27;岁了!&#x27;</span>;<br><span class="hljs-title function_">alert</span>(message)<br></code></pre></td></tr></table></figure><p>如果有很多变量,使用<code>+</code>就有点麻烦,ES6后提供一种新的模板字符串:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">`你好, <span class="hljs-subst">$&#123;name&#125;</span>, 你今年<span class="hljs-subst">$&#123;age&#125;</span>岁了!`</span>; <span class="hljs-comment">// 反引号+shell的变量引用:)</span><br></code></pre></td></tr></table></figure><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取字符串长度</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br>s.<span class="hljs-property">length</span>;<br><span class="hljs-comment">// 获取字符串某个指定位置的字符,使用下标</span><br>s[<span class="hljs-number">0</span>]; <span class="hljs-comment">// &#x27;H&#x27;</span><br>s[<span class="hljs-number">13</span>]; <span class="hljs-comment">// undefined,因为超出范围</span><br></code></pre></td></tr></table></figure><blockquote><p>字符串是不可变的,如果对字符串的某个索引赋值,不会有任何错误,也不会有任何改变</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 转回大写</span><br>s.<span class="hljs-title function_">toUpperCase</span>();<br><span class="hljs-comment">// 小写</span><br>s.<span class="hljs-title function_">toLowerCase</span>();<br><span class="hljs-comment">// 根据字符串搜索索引</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>s.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;world&#x27;</span>); <span class="hljs-comment">// 返回7</span><br><span class="hljs-comment">// 返回子字符串,类似python的字符串切片</span><br>s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 从索引0开始到索引4(不包括5)</span><br>s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">// 从索引7开始到结束</span><br></code></pre></td></tr></table></figure><h1 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h1><h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过array的属性length获取长度</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.14</span>, <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>);<br><span class="hljs-comment">// 如果直接个length属性赋值,回导致array大小变化,没有赋值的元素则是undefined</span><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">7</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// arr变为[1, 2, 3.14, &#x27;Hello&#x27;, null, true, undefined]</span><br><span class="hljs-comment">// array是可变的,可以通过索引直接修改元素</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;99&#x27;, &#x27;C&#x27;]</span><br><span class="hljs-comment">// 通过索引赋值时,如果索引超出了范围,同样会引起Array大小的变化</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br>arr[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;x&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// arr变为[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, undefined, undefined, &#x27;x&#x27;]</span><br></code></pre></td></tr></table></figure><blockquote><p>大多数语言都不允许直接改变数组的大小.但JS对此没有任何报错,所以在使用JS array时要注意不要越界</p></blockquote><h2 id="切片-复制"><a href="#切片-复制" class="headerlink" title="切片&#x2F;复制"></a>切片&#x2F;复制</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// array同样也有indexOf()</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;30&#x27;</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>];<br>arr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 元素10的索引为0</span><br><span class="hljs-comment">// slice(),类似python的切片</span><br>arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 索引0-2,不包括3</span><br>arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 索引3到结尾</span><br><span class="hljs-keyword">let</span> aCopy = arr.<span class="hljs-title function_">slice</span>(); <span class="hljs-comment">// 不传任何参数就是从头到尾,一般用于复制array</span><br>aCopy === arr; <span class="hljs-comment">// false. 类似python的深复制</span><br></code></pre></td></tr></table></figure><h2 id="添加-删除"><a href="#添加-删除" class="headerlink" title="添加&#x2F;删除"></a>添加&#x2F;删除</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>) <span class="hljs-comment">//在array末尾添加元素,返回新数组的长度:4 </span><br>arr; <span class="hljs-comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span><br>arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 从末尾提取元素,返回&#x27;B&#x27;</span><br>arr; <span class="hljs-comment">// [1, 2, &#x27;A&#x27;]</span><br><span class="hljs-keyword">let</span> arr = [];<br>arr.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 空数组pop不会报错,而是返回undefined</span><br>arr; <span class="hljs-comment">// []</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>); <span class="hljs-comment">// 在arr开头添加,返回arr的新长度: 4</span><br>arr; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span><br>arr.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// 从arr开头提取,返回&#x27;A&#x27;</span><br>arr; <span class="hljs-comment">// [&#x27;B&#x27;, 1, 2]</span><br><span class="hljs-keyword">let</span> arr = [];<br>arr.<span class="hljs-title function_">shift</span>() <span class="hljs-comment">// shift空数组不会报错,返回undefined</span><br></code></pre></td></tr></table></figure><h2 id="排序-反转"><a href="#排序-反转" class="headerlink" title="排序&#x2F;反转"></a>排序&#x2F;反转</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>];<br>arr.<span class="hljs-title function_">sort</span>(); <span class="hljs-comment">// 排序</span><br>arr; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<br>arr.<span class="hljs-title function_">reverse</span>();  <span class="hljs-comment">// 反转</span><br>arr; <span class="hljs-comment">// [&#x27;three&#x27;, &#x27;two&#x27;, &#x27;one&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="万能方法"><a href="#万能方法" class="headerlink" title="万能方法"></a>万能方法</h2><p><code>splice()</code>是修改array的万能方法.</p><p>第一个参数是array的<code>开始索引</code>,第二个参数是<code>范围</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;Microsoft&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Yahoo&#x27;</span>, <span class="hljs-string">&#x27;AOL&#x27;</span>, <span class="hljs-string">&#x27;Excite&#x27;</span>, <span class="hljs-string">&#x27;Oracle&#x27;</span>];<br><span class="hljs-comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>); <span class="hljs-comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span><br>arr; <span class="hljs-comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span><br><span class="hljs-comment">// 只删除,不添加:</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span><br>arr; <span class="hljs-comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span><br><span class="hljs-comment">// 只添加,不删除:</span><br>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Facebook&#x27;</span>); <span class="hljs-comment">// 返回[],因为没有删除任何元素</span><br>arr; <span class="hljs-comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">let</span> added = arr.<span class="hljs-title function_">concat</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>added; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 1, 2, 3]</span><br>arr; <span class="hljs-comment">// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></code></pre></td></tr></table></figure><h2 id="数组转字符串拼接"><a href="#数组转字符串拼接" class="headerlink" title="数组转字符串拼接"></a>数组转字符串拼接</h2><p>类似python的<code>join()</code>.</p><p>如果array的元素不是字符串,会自动转成字符串然后再拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;-&#x27;</span>); <span class="hljs-comment">// &#x27;A-B-C-1-2-3&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">400</span>, <span class="hljs-number">500</span>, <span class="hljs-number">600</span>], <span class="hljs-string">&#x27;-&#x27;</span>];<br><span class="hljs-keyword">let</span> x = arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 500</span><br></code></pre></td></tr></table></figure><h1 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h1><p>可以类比python的dict,groovy的map,但是它实际上也是一个对象.因为它可以继承.</p><p>JS的对象用来描述现实世界中的某个对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 描述小明</span><br><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,<br>    <span class="hljs-attr">birth</span>: <span class="hljs-number">1990</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;No.1 Middle School&#x27;</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1.70</span>,<br>    <span class="hljs-attr">weight</span>: <span class="hljs-number">65</span>,<br>    <span class="hljs-attr">score</span>: <span class="hljs-literal">null</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意: 最后一个键值对末尾不需要加<code>,</code>,如果加了,某些旧版本浏览器会报错.</p><ul><li>键值对的每个<code>键(key)</code>,称为对象的属性.</li><li>属性的访问通过<code>.</code>操作符.</li><li>如果属性名包含特殊字符,要通过<code>&#39;&#39;</code>括起来.</li><li>如果访问一个不存在的属性,返回<code>undefined</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaohong = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,<br>    <span class="hljs-string">&#x27;middle-school&#x27;</span>: <span class="hljs-string">&#x27;No.1 Middle School&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>js的对象是动态类型,可以自由地给一个对象添加或删除属性.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> xiaoming = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span><br>&#125;;<br>xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// undefined</span><br>xiaoming.<span class="hljs-property">age</span> = <span class="hljs-number">18</span>; <span class="hljs-comment">// 新增一个age属性</span><br>xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// 18</span><br><span class="hljs-keyword">delete</span> xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// 删除age属性</span><br>xiaoming.<span class="hljs-property">age</span>; <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">delete</span> xiaoming[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-comment">// 删除name属性</span><br>xiaoming.<span class="hljs-property">name</span>; <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">delete</span> xiaoming.<span class="hljs-property">school</span>; <span class="hljs-comment">// 删除一个不存在的school属性也不会报错</span><br></code></pre></td></tr></table></figure><p><code>in</code>操作符来判断对象是否拥有某一属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;name&#x27;</span> <span class="hljs-keyword">in</span> xiaoming; <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;grade&#x27;</span> <span class="hljs-keyword">in</span> xiaoming; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但有时候这个属性不一定是<code>xiaoming</code>的,也有可能是<code>xiaoming</code>继承得到的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> xiaoming; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这是有因为<code>toString</code>定义在<code>object</code>对象中,而所有对象最终都会在原型链上指向<code>object</code>,所以<code>xiaoming</code>也会有这个属性</p><p>要判断一个属性是否自身拥有,而不是继承所得,使用<code>hasOwnProperty()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">xiaoming.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;name&#x27;</span>); <span class="hljs-comment">// true</span><br>xiaoming.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;toString&#x27;</span>); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">let</span> age = <span class="hljs-number">20</span>;<br><br><span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">6</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;teenager&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (age &gt;= <span class="hljs-number">18</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;adult&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;kid&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>if &#123;&#125; else if &#123;&#125; else &#123;&#125;</code></li><li>注意<code>&#123;&#125;</code>不要省略</li><li>注意判断的顺序: js中,如果某个条件成立,后续就不会再判断,上面的例子中<code>age = 20</code>,它满足了第一个条件<code>age &gt;= 6</code>,就不会再往下判断,所以结果就是<code>teenager</code>.</li><li><code>null</code>,<code>undefined</code>,<code>0</code>,<code>NaN</code>和空字符串<code>&#39;&#39;</code>,都是<code>false</code>;其他都是<code>true</code></li></ul><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> i;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-number">10000</span>; i++) &#123; <span class="hljs-comment">// 初始条件; 结束条件; 递增条件</span><br>    x = x + i;<br>&#125;<br>x; <span class="hljs-comment">// 50005000</span><br></code></pre></td></tr></table></figure><ul><li><code>i=1;</code>是初始条件,记得先声明</li><li><code>i&lt;10000;</code>这是判断条件,满足时就继续循环,不满足就结束</li><li><code>i++</code>是递增条件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 最常见的做法:遍历数据</span><br><span class="hljs-keyword">let</span> arr =  [<span class="hljs-string">&#x27;Apple&#x27;</span>, <span class="hljs-string">&#x27;Google&#x27;</span>, <span class="hljs-string">&#x27;Microsoft&#x27;</span>]<br><span class="hljs-keyword">let</span> i, x;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;arr.<span class="hljs-property">length</span>; i++)&#123;<br>    x = arr[i];<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for</code>的3个循环条件都是可以省略的,如果没有结束条件,就要手动加<code>break</code>来跳出循环,否则就是一个死循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 死循环</span><br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) &#123; <span class="hljs-comment">// 通过if + break手动跳出</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    x ++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p>一般用来把一个对象的所有属性一次循环出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>    <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;20&#x27;</span>,<br>    <span class="hljs-attr">city</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span><br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> o) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Array</code>也是对象,它每个元素的索引将被视为对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> a) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27; 注意for..in对array循环得到的是String而不是Number</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a[i]); <span class="hljs-comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">let</span> n = <span class="hljs-number">99</span>;<br><span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>    x = x + n;<br>    n = n - <span class="hljs-number">2</span>;<br>&#125;<br>x; <span class="hljs-comment">// 2500</span><br></code></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>与<code>while</code>的区别是,不是在每次循环前判断条件,而是在每次循环后再判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span> &#123;<br>    n = n + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">while</span> (n &lt; <span class="hljs-number">100</span>);<br>n; <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><p>需要注意的是使用<code>do..while</code>的话,循环体<code>至少会执行一次</code></p><h1 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h1><p>JS的对象表现形式很类似其他语言的<code>Map</code>或<code>Dict</code>,但是JS的对象的键必须是字符串.然而实际上键是其他数据类型,比如Number,也是很合理的.所以ES6后引入了<code>Map</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-comment">// 没有报ReferenceError错,则表示浏览器支持ES6</span><br></code></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>是一个键值对结果,具有极快的查找速度,不论这个表多大,查找速度都不会变慢.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-number">95</span>], [<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">75</span>], [<span class="hljs-string">&#x27;Tracy&#x27;</span>, <span class="hljs-number">85</span>]]) <span class="hljs-comment">// 初始化需要一个二维数组</span><br><span class="hljs-keyword">let</span> m2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-comment">// 或者直接初始化一个空Map</span><br><span class="hljs-comment">// Map具有以下方法</span><br>m2.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">67</span>); <span class="hljs-comment">// 添加新的key-value</span><br>m2.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">59</span>);<br>m2.<span class="hljs-title function_">has</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// 是否存在key &#x27;Adam&#x27;: true</span><br>m2.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// 67</span><br>m2.<span class="hljs-title function_">delete</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// 删除key &#x27;Adam&#x27;</span><br>m2.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Adam&#x27;</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>一个key只能对应一个value,多次对同一个key放入不同value,后面的value会把前面的value冲掉</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>是一组<code>key的集合</code>,且不能重复.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">// 初始化需要提供一个array</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 或者初始化一个空set</span><br><span class="hljs-comment">// 重复的元素会在set中自动过滤</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);<br>s; <span class="hljs-comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br>s.<span class="hljs-title function_">add</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素,重复添加不会有效果(去重)</span><br>s; <span class="hljs-comment">// &#123;1, 2, 3, &quot;3&quot;, 4&#125;</span><br>s.<span class="hljs-title function_">delete</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除key</span><br>s; <span class="hljs-comment">// &#123;1, 2, &quot;3&quot;, 4&#125;</span><br></code></pre></td></tr></table></figure><h1 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h1><p>遍历<code>Array</code>可以使用下标循环,但是遍历<code>Map</code>和<code>Set</code>就没有下标.为了统一集合类型,ES6引入新的<code>iterable</code>类型,<code>Array</code>,<code>Map</code>和<code>Set</code>都属于这个类型.</p><p><code>iterable</code>类型的集合可以通过新的<code>for...of</code>循环来遍历.(也是ES6引入的语法)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]);<br><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;x&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;y&#x27;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;z&#x27;</span>]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> a) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>for...in</code>有一个历史问题,它遍历的实际上是对象的属性名称.一个<code>Array</code>也是一个对象,它每个元素的索引都被视为一个属性.当我们手动给<code>Array</code>对象添加额外的属性后,<code>for...in</code>会带来意想不到的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br>a.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">in</span> a) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;name&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>for...of</code>则修复了这个问题,它<code>只循环集合元素本身</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br>a.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> a) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;Hello&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>然而,更好的方式是使用ES5.1引入的<code>iterable</code>内置的<code>forEach</code>方法,它接收一个函数,每次迭代就自动回调该函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br>a.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, index, array</span>) &#123;<br>    <span class="hljs-comment">// element: 指向当前元素的值</span><br>    <span class="hljs-comment">// index: 指向当前索引</span><br>    <span class="hljs-comment">// array: 指向Array对象本身,这里就是a</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;element&#125;</span>, index = <span class="hljs-subst">$&#123;index&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>Set</code>没有索引,所以回调函数的前两个参数都是元素本身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]);<br>s.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element, sameElement, set</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>Map</code>回调函数参数依次为: <code>value</code>, <code>key</code>和 <code>map</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;x&#x27;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;y&#x27;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;z&#x27;</span>]]);<br>m.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value, key, map</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;)<br></code></pre></td></tr></table></figure><p>JS并不要求回调函数的参数完全一致,因此可以省略不感兴趣的参数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>];<br>a.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">element</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(element); <span class="hljs-comment">// 只获得array的element</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-异步IO</title>
    <link href="/2024/10/29/python-asyncio/"/>
    <url>/2024/10/29/python-asyncio/</url>
    
    <content type="html"><![CDATA[<blockquote><p>CPU速度远远快于磁盘,网络等IO.在一个线程中,cpu执行代码的速度极快,但一旦遇到IO操作,比如读写文件,发送网络数据时,就需要等待IO操作完成,才能继续进行下一步.这种情况称为<code>同步IO</code>.此时一个IO就阻塞了当前线程,导致代码无法继续,所以我们需要多线程或者多进程,为多个用户服务.每个用户分配一个线程,如果遇到IO导致线程被挂起,起码其他用户不会受影响.</p></blockquote><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">真正意义上的 异步IO 是说内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">select</span> / poll / epoll 都是同步IO的多路复用模式</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.同步和异步</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">同步和异步关注的是消息通信机制</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所谓同步，就是在发出一个*调用*时，没得到结果之前，该*调用*就不返回。但是一旦调用返回就得到返回值了，*调用者*主动等待这个*调用*的结果</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">所谓异步，就是在发出一个*调用*时，这个*调用*就直接返回了，不管返回有没有结果。当一个异步过程调用发出后，*被调用者*通过状态，通知来通知*调用者*，或者通过回调函数处理这个调用</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.阻塞和非阻塞</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阻塞和非阻塞关注的是程序在等待调用结果时的状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">网络上的例子</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">老张爱喝茶，废话不说，煮开水。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">1 老张把水壶放到火上，立等水开。（同步阻塞）；立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）；老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3 老张把响水壶放到火上，立等水开。（异步阻塞）；立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）；老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。对应的也就是消息通信机制</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；对应的也就是程序等待结果时的状态</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">看电视的老张，非阻塞。</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</span><br></code></pre></td></tr></table></figure></blockquote><h1 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h1><p>多进程&#x2F;多线程虽然可以解决并发问题,但系统不能无上限地增加线程.由于系统切换线程的开销也很大,所以一旦线程数量过多,cpu的时间就花在线程切换上,真正运行代码的时间就减少了,性能就会下降.我们要解决的核心问题是CPU和IO设备处理速度的严重不匹配.多进程&#x2F;多线程只是解决这个问题的一个办法,而另一个办法就是<code>异步IO</code>.</p><blockquote><p>异步IO:</p><p>当代码需要执行一个耗时的IO操作时,它只发出IO指令,并不等待IO结果,然后就直接执行其他代码.一段时间后,当IO返回结果时,再通知CPU进行处理.</p></blockquote><p>异步IO模型需要一个<code>消息循环</code>,在这个循环中,主线程不断地重复”读取消息-处理消息”这个过程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">loop = get_event_loop()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    event = loop.get_event()<br>    process_event(event)<br></code></pre></td></tr></table></figure><blockquote><p>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。</p><p>由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p><p>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。</p><p>在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p></blockquote><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>又称<code>微线程</code>&#x2F;<code>纤程</code>.英文名Coroutine</p><blockquote><p> <code>子程序</code>,或者称为<code>函数</code>,在所有语言中都是<code>层级调用</code>,比如A调用B,B又调用C,C执行完毕返回,B执行完毕返回,最后才是A执行完毕.</p><p>所以子程序调用是通过栈实现的,一个线程就是执行一个子程序.</p><p>子程序调用总是一个入口,一次返回,调用顺序是明确的.</p></blockquote><p>但协程与子程序不同.携程看上去也是子程序,但是在执行过程中,子程序内部可中断,然后转而执行别的子程序,在适当的时候再返回来接着执行.这一点有点类似CPU的中断.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如子程序A和B</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">A</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;3&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">B</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;z&#x27;</span>)<br>   <br><span class="hljs-comment"># 假如由携程执行,结果可能就是</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>x<br>y<br><span class="hljs-number">3</span><br>z<br></code></pre></td></tr></table></figure><p>协程的特点在于,它是<code>一个线程</code>执行,与多线程相比优势有:</p><ul><li>极高的执行效率: 子程序切换不是线程切换,而是由程序自身控制.因此没有切换的开销.与多线程相比,线程越多,协程的性能优势越明显.</li><li>不需要线程的锁机制: 因为协程只有一个线程,在协程中控制共享资源不加锁,只需要判断状态,所以执行效率比多线程高.</li></ul><blockquote><p>由于协程是一个线程执行,要充分利用多核CPU,最简单的方法就是<code>多线程+协程</code>.</p></blockquote><p>底层实现机制:</p><ol><li>python协程的本质是基于<code>生成器(generator)</code>实现的状态机</li><li>通过字节码操作来实现协程的挂起和恢复</li><li>事件循环负责调度和切换不同的协程</li></ol><p>与操作系统的关系:</p><ol><li>协程是用户态的轻量级线程</li><li>切换由程序自身控制,不需要系统介入</li><li>没有线程上下文切换的开销,无锁</li></ol><p>来看一个例子:</p><p>传统生产者-消费者模型是一个线程写消息,一个线程取消息,通过锁机制控制队列和等待,但一不小心就会死锁.</p><p>如果改用协程:</p><ol><li>生产者生产一条消息后通过<code>yield</code>让出CPU,切换到消费者</li><li>消费者开始处理消息,但生产者并不需要等待消费者处理完</li><li>消费者可以再处理过程中随时通过<code>yield</code>让出CPU,切换回生产者继续生产新消息</li><li>两者可以交替执行,互不阻塞</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">consumer</span>():<br>    r = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment"># 初始化返回值</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n = <span class="hljs-keyword">yield</span> r <span class="hljs-comment"># 核心语句: 让consumer函数变成一个生成器,接受发送过来的值,赋值给n,同时产出r</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> n: <span class="hljs-comment"># n=None,if not n--&gt; True, 表示想consumer 生成器不发送东西的话就会直接返回</span><br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[CONSUMER] Consuming %s...&#x27;</span> % n)<br>        r = <span class="hljs-string">&#x27;200 OK&#x27;</span> <span class="hljs-comment"># 设置返回值</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">produce</span>(<span class="hljs-params">c</span>):<br>    c.send(<span class="hljs-literal">None</span>) <span class="hljs-comment"># 启动生成器,发送None</span><br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>: <span class="hljs-comment"># 生产5次</span><br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[PRODUCER] Producing %s...&#x27;</span> % n)<br>        r = c.send(n) <span class="hljs-comment"># 发送生产的值,会从yield语句继续执行,yield获取新的n并返回新的r</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[PRODUCER] Consumer return: %s&#x27;</span> % r)<br>    c.close()<br><br>c = consumer()<br>produce(c)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[PRODUCER] Producing 1...<br>[CONSUMER] Consuming 1...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 2...<br>[CONSUMER] Consuming 2...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 3...<br>[CONSUMER] Consuming 3...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 4...<br>[CONSUMER] Consuming 4...<br>[PRODUCER] Consumer return: 200 OK<br>[PRODUCER] Producing 5...<br>[CONSUMER] Consuming 5...<br>[PRODUCER] Consumer return: 200 OK<br></code></pre></td></tr></table></figure><blockquote><p>这里最难理解的就是<code>n = yield r</code></p><p>这一行的执行顺序是:</p><ul><li>先返回”返回值r”给调用者</li><li>然后暂停在这里</li><li>等待下一次send()时,把send的值赋给n</li></ul><p>所以上面consumer的代码执行顺序大概这样:</p><ol><li>执行到yield行,先返回”返回值(r)”,然后暂停在这里,等待下一个send</li><li>下一个send到来,把send的值赋给n,然后继续执行下面的代码,再次执行到yield行,再一次返回返回值(r),再一次暂停</li><li>等待再下一个send继续循环</li></ol></blockquote><h1 id="理论对比"><a href="#理论对比" class="headerlink" title="理论对比"></a>理论对比</h1><p>先来理一下协程,异步IO和asyncio三者:</p><ol><li><p>协程(Coroutine)</p><ul><li><p>是一种编程概念,是实现异步编程的基础</p></li><li><p>可以理解为<code>能暂停的函数</code>: 在等待IO时可以主动让出控制权</p></li><li><p>使用async&#x2F;await语法来定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>():<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment"># 暂停,让出控制权</span><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure></li></ul></li><li><p>异步IO(Asynchronous IO)</p><ul><li><p>是一种IO操作模型</p></li><li><p>发起IO请求后不等待结果,继续执行其他任务</p></li><li><p>当IO结果就绪时再回来处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例如读文件</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_file</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        content = <span class="hljs-keyword">await</span> f.read() <span class="hljs-comment"># 不阻塞等待</span><br>    <span class="hljs-keyword">return</span> content<br></code></pre></td></tr></table></figure></li></ul></li><li><p>asyncio</p><ul><li><p>python的异步编程框架</p></li><li><p>提供运行和管理协程的完整工具集</p></li><li><p>包含时间循环,任务调度,IO操作等功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例如</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    task1 = asyncio.create_task(fetch_data())<br>    task2 = asyncio.create_task(fread_file())<br>    <span class="hljs-comment"># 并发执行多个协程 (虽然是并发,但实际上还是单线程在工作)</span><br>    results = <span class="hljs-keyword">await</span> asyncio.gather(task1, task2)<br>    <br><span class="hljs-comment"># 启动时间循环运行协程</span><br>asyncio.run(main())<br></code></pre></td></tr></table></figure></li></ul><blockquote><ul><li>asyncio 是框架</li><li>协程是核心机制</li><li>异步IO是主要应用场景</li></ul><p>优点:</p><ol><li>一个线程可以同时处理多个IO操作</li><li>IO等待时间被利用起来做其他工作</li><li>避免多线程的复杂性</li></ol></blockquote></li></ol><h1 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>asyncio</code>是python的异步编程框架,用于编写并发代码.它使用协程,事件循环和任务实现异步编程.</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>协程(Coroutine): 可以暂停执行的函数</li><li>事件循环(Event Loop): 程序调度和执行异步代码的核心</li><li>任务(Task): 协程的包装器,用于跟踪协程的执行</li><li>Future: 表示异步操作的最终结果</li><li>await: 等待一个协程完成</li></ul><h2 id="关键字和语法"><a href="#关键字和语法" class="headerlink" title="关键字和语法"></a>关键字和语法</h2><h3 id="基础关键字"><a href="#基础关键字" class="headerlink" title="基础关键字"></a>基础关键字</h3><ul><li><code>async def</code>: 定义一个协程函数</li><li><code>async with</code>: 异步上下文管理器,相当于<code>with</code>的异步版本</li><li><code>await</code>: 等待一个协程执行完成</li><li><code>asyncio.run()</code>: 运行异步程序的入口点</li><li><code>asyncio.create_task()</code>: 创建一个任务</li><li><code>asyncio.gather()</code>: 并发运行多个协程</li><li><code>asyncio.sleep(n)</code>: 当前协程暂停执行n秒,不会阻塞事件循环,其他协程正常运行.</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建事件循环</span><br>loop = asyncio.get_event_loop()<br><span class="hljs-comment"># 运行协程</span><br>asyncio.run(main())<br><span class="hljs-comment"># 创建任务</span><br>task = asyncio.create_task(coro())<br><span class="hljs-comment"># 等待多个协程完成</span><br><span class="hljs-keyword">await</span> asyncio.gather(coro1(), coro2())<br><span class="hljs-comment"># 延时</span><br><span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h2 id="异步爬虫例子"><a href="#异步爬虫例子" class="headerlink" title="异步爬虫例子"></a>异步爬虫例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio <span class="hljs-comment"># python标准库,提供异步编程的基础设施</span><br><span class="hljs-keyword">import</span> aiohttp <span class="hljs-comment"># 第三方库,提供异步的http客户端和服务端</span><br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup <span class="hljs-comment"># 用于解析html和xml</span><br><br><span class="hljs-comment"># 这个函数使用aiohttp发送一个异步GET请求到指定的url</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_html</span>(<span class="hljs-params">session, url</span>): <span class="hljs-comment"># async def 定义一个异步函数</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response: <span class="hljs-comment"># session.get()发送一个GET请求到指定url并返回一个ClientResponse对象</span><br>        <span class="hljs-comment"># async with用于正确管理异步上下文,确保在请求完成后正确释放资源</span><br>        <span class="hljs-keyword">if</span> response.statue == <span class="hljs-number">200</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.text() <span class="hljs-comment"># 获取响应的文本内容(HTML)</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 这里就是使用beautiful soup来解析html</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">此函数其实没有执行任何异步操作,所以它也可以定义为一个普通的同步函数,但是把它也定义为异步函数也是没问题的,主要是为了:</span><br><span class="hljs-string">1. 保持一致性</span><br><span class="hljs-string">2. 未来扩展考虑, 可能未来需要在这个函数内加上异步操作</span><br><span class="hljs-string">不过从性能角度考虑,如果一个函数内没有任何异步操作,最好还是直接定义为同步函数,不然会增加开销</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_links</span>(<span class="hljs-params">html</span>):<br>    soup = Beautifulsoup(html, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>    links = [a[<span class="hljs-string">&#x27;href&#x27;</span>] <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>, href=<span class="hljs-literal">True</span>)]<br>    <span class="hljs-keyword">return</span> links<br><br><span class="hljs-comment"># 递归爬取网页</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl</span>(<span class="hljs-params">url, max_depth=<span class="hljs-number">2</span>, depth=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session: <span class="hljs-comment"># 创建一个ClientSession对象,用于发送HTTP请求</span><br>        html = <span class="hljs-keyword">await</span> fetch_html(session, url) <span class="hljs-comment"># 调用fetch_html函数获取html</span><br>        <span class="hljs-keyword">if</span> html:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Crawling: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>) <span class="hljs-comment"># 如果获取到html就打印正在爬取的url</span><br>            links = <span class="hljs-keyword">await</span> extract_link(html) <span class="hljs-comment"># 并调用extract_link提取连接</span><br>            <span class="hljs-keyword">if</span> depth &lt; max_depth: <span class="hljs-comment"># 递归调用,爬取depth深度的网页</span><br>                <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>                    <span class="hljs-keyword">await</span> crawl(link, max_depth, depth+<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 主函数                   </span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    start_url = <span class="hljs-string">&quot;https://example.com&quot;</span><br>    <span class="hljs-keyword">await</span> crawl(start_url)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    asyncio.run(main()) <span class="hljs-comment"># 创建事件循环,并在该循环中运行main()</span><br></code></pre></td></tr></table></figure><p>再来看一下关键字的用法:</p><ul><li><p><code>async def</code>:</p><p>此关键字用于定义一个异步函数,需要在以下情况使用<code>async def</code>:</p><ol><li>函数内部需要使用<code>await</code>等待一个耗时的异步操作完成,比如网络请求,文件IO等</li><li>函数需要调用另一个异步函数</li></ol></li><li><p><code>await</code>:</p><p>此关键字只能在<code>async def</code>定义个异步函数内使用.作用是暂停当前异步函数的执行,等待一个耗时的异步操作完成,然后继续执行.一般在以下情况下使用:</p><ol><li>发送网络请求,等待响应返回</li><li>读写文件,等待IO完成</li><li>调用另一个异步函数,等待它执行完毕</li></ol></li><li><p><code>async with</code>:</p><p>当你使用了一个实现了<code>__aenter__</code>和<code>__aexit__</code>方法的<code>异步上下文管理器</code>对象,那么你应该使用<code>async with</code>来获取和释放该对象管理的资源.一些常见的异步上下文管理器包括但不限于:</p><ol><li><code>aiohttp.ClientSession</code></li><li><code>asyncpg.Connection</code></li><li><code>aiomysql.Connection</code></li><li><code>aiofiles.open</code></li></ol></li><li><p><code>asyncio.sleep()</code>:</p><p>这是一个异步函数,可以用于模拟一个耗时的异步操作,让事件循环有机会切换到其他任务.在爬虫中如果你需要控制爬取的速度,避免给网站过高的负载,可以在每次爬取后使用<code>await asyncio.sleep(delay)</code>来暂停一段时间.</p></li></ul><h1 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h1><p><code>asyncio</code>可以实现单线程并发IO.但是这是仅在客户端.如果把asyncio用来服务端,例如web服务器,http连接本身就是IO操作,所以可以通过单线程+<code>async</code>函数实现多用户的高并发操作.</p><p><code>asyncio</code>实现了TCP,UDP,SSL等协议,而<code>aiohttp</code>则是基于<code>asyncio</code>实现的HTTP框架.</p><p><code>aiohttp</code>是第三方库所以要用pip安装.</p><p>下面用<code>aiohttp</code>写一个http服务器,处理以下URL:</p><ul><li><code>/</code>: 首页返回<code>index.html</code></li><li><code>/&#123;name&#125;</code>: 根据URL 返回<code>hello, &#123;name&#125;!</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> web<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(<span class="hljs-params">request</span>):<br>    text = <span class="hljs-string">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span><br>    <span class="hljs-keyword">return</span> web.Response(text=text, content_type=<span class="hljs-string">&#x27;text/html&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">request</span>):<br>    name = request.match_info.get(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>)<br>    text = <span class="hljs-string">f&#x27;&lt;h1&gt;Hello, <span class="hljs-subst">&#123;name&#125;</span>&lt;/h1&gt;&#x27;</span><br>    <span class="hljs-keyword">return</span> web.Response(text=text, content_type=<span class="hljs-string">&#x27;text/html&#x27;</span>)<br><br>app = web.Application()<br><br><span class="hljs-comment"># 添加路由</span><br>app.add_routes([web.get(<span class="hljs-string">&quot;/&quot;</span>, index), web.get(<span class="hljs-string">&quot;/&#123;name&#125;&quot;</span>, hello)])<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    web.run_app(app)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-进程和线程</title>
    <link href="/2024/08/28/python-process-thread/"/>
    <url>/2024/08/28/python-process-thread/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>通俗点地理解:</p><p>对于操作系统来说,一个任务就是一个进程(process),比如打开一个浏览器就是启动一个浏览器进程,打开两个记事本就是打开两个记事本进程.</p><p>有些进程它同时不止干一件事,比如word,它同时可以打字,拼写检查,打印等.在一个进程内部可以同时运行多个”子任务”,则称之为线程(Thread).</p><p>由于每个进程至少要干一件事,所以每个进程至少要有一个线程.</p></blockquote><h2 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h2><ul><li>进程是计算机中<code>正在运行的程序的实例</code></li><li>它是操作系统<code>分配资源的基本单位</code><ul><li>所以每个进程都有自己的内存空间,系统资源和状态信息</li></ul></li></ul><h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><ul><li>线程是进程内的<code>执行单元</code></li><li>它是<code>cpu调度和分配的基本单位</code></li><li>同一进程内多个线程共享该进程的资源</li></ul><table><thead><tr><th>区别</th><th>资源占用</th><th>开销</th><th>通信</th><th>安全</th><th>并行</th></tr></thead><tbody><tr><td>进程</td><td>每个进程独立</td><td>创建和切换开销大</td><td>进程间通信(IPC)比较复杂</td><td>进程之间不会相互影响</td><td>在多核处理器上实现真正并行</td></tr><tr><td>线程</td><td>每个线程共享进程的资源</td><td>创建和切换开销小</td><td>线程间通信比较简单,直接读写进程中的数据</td><td>一个线程的奔溃可能导致整个进程奔溃</td><td>在单核处理器上是并发执行,在多核上可以并行</td></tr></tbody></table><h2 id="并发与并行-concurrency-parallelism"><a href="#并发与并行-concurrency-parallelism" class="headerlink" title="并发与并行(concurrency &amp; parallelism)"></a>并发与并行(concurrency &amp; parallelism)</h2><blockquote><ul><li>进程在多核处理器上实现真正并行:<br>多个进程在多核处理器上同时运行,每个核心执行一个进程,实现真正并行.操作系统将不同进程分配到不同的cpu核心上,这是在硬件级别实现的并行.</li><li>线程在单核处理器上是并发执行:<br>多线程通过时间片轮转(time-slicing)实现的并发,线程上下文会不停地,给人一种同时执行的错觉.<br>这种称为并发(concurrency),并不是真正的并行.</li><li>线程在多核上可以并行:<br>类似多进程,不同的线程分配到不同的核心上同时执行.<br>这种称为并行(parallelism)</li></ul></blockquote><p>那么,多任务的执行就有三种模型:</p><ul><li>多进程</li><li>多线程</li><li>多进程+多线程</li></ul><p>通常,同时执行多个任务时,各个任务之间并不是完全没有关联,通常都需要互相通信和协调,有时,任务1需要等待任务2完成后才能继续执行,有时任务3和4又不能同时执行,所以多进程和多线程程序的复杂度是很高的.</p><h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>unix&#x2F;linux 提供了一个<code>fork()</code>调用. 它调用一次,返回两次.因为操作系统会自动把当前进程(父进程)复制一份(子进程),然后分别在父子进程内返回.在<code>fork()</code>中:</p><ul><li><p>子进程永远返回<code>0</code></p></li><li><p>父进程返回子进程的<code>id</code></p></li></ul><p>python的<code>os</code>模块有fork调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;process <span class="hljs-subst">&#123;os.getpid()&#125;</span> start...&#x27;</span>)<br><br>pid = os.fork() <span class="hljs-comment"># 创建子进程</span><br><br><span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;I am child process <span class="hljs-subst">&#123;os.getpid()&#125;</span>, my pranent is <span class="hljs-subst">&#123;os.getppid()&#125;</span>&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;I <span class="hljs-subst">&#123;os.getpid&#125;</span> just create a child process <span class="hljs-subst">&#123;pid&#125;</span>.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Process (876) start...<br>I (876) just created a child process (877).<br>I am child process (877) and my parent is 876.<br></code></pre></td></tr></table></figure><p>因为父进程需要记住每个子进程的pid以便后续:</p><ul><li>等待子进程结束(wait)</li><li>向子进程发送信号(kill)</li><li>监控子进程状态</li></ul><p>而子进程可以通过<code>getppid()</code>获取父进程的pid,所以不需要在fork()时候特别记录</p><h2 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h2><p>windows没有<code>fork</code>调用,如果要在windows上使用python编写多进程程序.<code>multiprocessing</code>就是一个跨平台版本的多进程模块.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process <span class="hljs-comment"># multiprocess提供一个Process类来代表一个进程对象</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_proc</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Run child process <span class="hljs-subst">&#123;name&#125;</span> (<span class="hljs-subst">&#123;os.getpid()&#125;</span>)...&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Parent process <span class="hljs-subst">&#123;os.getpid()&#125;</span>.&#x27;</span>)<br>    p = Process(traget=run_proc, args=(<span class="hljs-string">&#x27;test&#x27;</span>,)) <span class="hljs-comment"># 输入执行函数和函数的参数,args需要以元组形式传入,所以即使只有一个元素也要加逗号</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process will start.&#x27;</span>)<br>    p.start() <span class="hljs-comment"># 启动子进程</span><br>    p.join() <span class="hljs-comment"># 等待子进程结束后再继续往下运行,通常用于进程间的同步</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Child process end.&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>需要大量创建子进程时,可以通过进程池的方式批量创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">long_time_task</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Run task <span class="hljs-subst">&#123;name&#125;</span> (<span class="hljs-subst">&#123;os.getpid()&#125;</span>)&#x27;</span>)<br>    strat = time.time()<br>    time.sleep(random.random() * <span class="hljs-number">3</span>)<br>    end = time.time()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Task <span class="hljs-subst">&#123;name&#125;</span> runs <span class="hljs-subst">&#123;(end - start)&#125;</span> seconds.&#x27;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-comment"># windows下必须在if __name__ == &#x27;__main__&#x27;:下使用进程池</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Parent process <span class="hljs-subst">&#123;os.getpid()&#125;</span>&#x27;</span>)<br>    p = Pool(<span class="hljs-number">4</span>) <span class="hljs-comment"># Pool同时执行的进程数,默认与cpu核数相同</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        p.apply_async(long_time_task, arg=(i,)) <span class="hljs-comment"># 异步执行(不等待任务完成直接返回)</span><br>        <span class="hljs-comment"># 与之相对的是p.apply(),它会阻塞等待任务完成</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Waitting for all subprocesses done...&#x27;</span>)<br>    p.close() <span class="hljs-comment"># 调用join()之前必须调用close(),执行了close()后就不能继续添加新的process了</span><br>    p.join() <span class="hljs-comment"># Pool对象调用join()方法会等待所有子进程执行完毕</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;All subprocesses done.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">Parent process 669.<br>Waiting for all subprocesses done...<br>Run task 0 (671)...<br>Run task 1 (672)...<br>Run task 2 (673)...<br>Run task 3 (674)... # 这里服务器以4核为例,Pool(4)同时执行4个进程,所以task0-3同时执行<br>Task 2 runs 0.14 seconds.<br>Run task 4 (673)... # task 4要等前面某个task完成后才能执行,如果你的服务器是8核,则要写Pool(9),才能看到等待效果<br>Task 1 runs 0.27 seconds.<br>Task 3 runs 0.86 seconds.<br>Task 0 runs 1.41 seconds.<br>Task 4 runs 1.91 seconds.<br>All subprocesses done.<br></code></pre></td></tr></table></figure><h2 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h2><p>很多时候子进程是一个外部程序.我们创建子进程后还要控制子进程的输入输出.<code>subprocess</code>模块可以很方便地做到.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;run nslookup www.python.org&#x27;</span>)<br>r = subprocess.call([<span class="hljs-string">&#x27;nslookup&#x27;</span>, <span class="hljs-string">&#x27;www.python.org&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exit code:&#x27;</span>, r)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">run nslookup www.python.org<br>Server:192.168.19.4<br>Address:192.168.19.4#53<br><br>Non-authoritative answer:<br>www.python.orgcanonical name = python.map.fastly.net.<br>Name:python.map.fastly.net<br>Address: 199.27.79.223<br><br>Exit code: 0<br></code></pre></td></tr></table></figure><p>如果子进程需要输入,则可以通过<code>communicate()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;$ nslookup&#x27;</span>)<br>p = subprocess.Popen([<span class="hljs-string">&#x27;nslookup&#x27;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<br>output, err = p.communicate(<span class="hljs-string">b&#x27;set q=mx\npython.org\nexit\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(output.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exit code:&#x27;</span>, p.returncode)<br></code></pre></td></tr></table></figure><p>实际实现的就是这种效果:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">nslookup</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">set</span> q=mx</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">python.org</span><br>Server:127.0.0.53<br>Address:127.0.0.53#53<br><br>Non-authoritative answer:<br>python.orgmail exchanger = 50 mail.python.org.<br><br>Authoritative answers can be found from:<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br></code></pre></td></tr></table></figure><h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><p>python的<code>multiprocessing</code>模块包装了底层的机制,提供<code>queue</code>, <code>pipes</code>等多种方式交换数据.</p><table><thead><tr><th>特性</th><th>Queue</th><th>Pipes</th></tr></thead><tbody><tr><td>进程数量</td><td>支持多进程</td><td>仅支两个进程</td></tr><tr><td>通信方向</td><td>单向(FIFO)</td><td>双向</td></tr><tr><td>使用场景</td><td>多生产者&#x2F;消费者(实际开发中如果不需要pipes的特殊功能,建议使用Queue,因为它更安全更易用)</td><td>点对点通信</td></tr><tr><td>安全性</td><td>进程安全(并发时不会出现数据混乱,因为有锁机制)</td><td>自行处理同步</td></tr><tr><td>性能</td><td>较慢(有锁机制)</td><td>较快</td></tr></tbody></table><p>更多通讯方式:</p><table><thead><tr><th>通信方式</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Queue</td><td>使用简单,进程安全</td><td>相对较慢</td><td>多生产者&#x2F;消费者</td></tr><tr><td>Pipe</td><td>速度快,双向通讯</td><td>仅支持两个进程</td><td>两进程间频繁通信</td></tr><tr><td>共享内存</td><td>最快的IPC方式</td><td>需要自行处理同步</td><td>大量数据共享</td></tr><tr><td>Manager</td><td>支持复杂的python对象</td><td>慢</td><td>需要共享复杂数据结构</td></tr><tr><td>Value&#x2F;Array</td><td>简单高效</td><td>仅支持基本数据类型</td><td>共享简单数据</td></tr><tr><td>文件系统</td><td>简单,持久化</td><td>最慢,需要IO操作</td><td>少量数据,需要持久化</td></tr></tbody></table><p>下面以<code>Queue</code>为例,在父进程中创建两个子进程,一个往Queue写数据,一个往Queue读数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><span class="hljs-keyword">import</span> os, time, random<br><br><span class="hljs-comment"># 写数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">write</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process to write: <span class="hljs-subst">&#123;os.getpid()&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Put <span class="hljs-subst">&#123;value&#125;</span> to queue...&#x27;</span>)<br>        q.put(value)<br>        time.sleep(random.random())<br>        <br><span class="hljs-comment"># 读数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">q</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process to read <span class="hljs-subst">&#123;os.getpid()&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        value = q.get(<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Get <span class="hljs-subst">&#123;value&#125;</span> from queue&#x27;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 父进程创建Queue,并传入子进程</span><br>    q = Queue()<br>    pw = Process(target=write, args=(q,))<br>    pr = Process(target=read, args=(q,))<br>    <span class="hljs-comment"># 子进程qw启动,写入</span><br>    pw.start()<br>    <span class="hljs-comment"># 子进程qr启动,读取</span><br>    pr.start()<br>    <span class="hljs-comment"># 等到pw结束</span><br>    pw.join()<br>    <span class="hljs-comment"># pr内是死循环,无法等待结束,只能强行终止</span><br>    pr.terminate()<br></code></pre></td></tr></table></figure><blockquote><ol><li><p>父进程和子进程间的通讯必须通过pickle序列化来传递数据.也就是说传入的args必须是可序列化的对象.比如:</p><ol><li>基本数据类型(数字, 字符串, 布尔值)</li><li>列表,字典,元组等内置容器</li><li>类实例(该类需要可实例化)</li></ol><p>以下类型则不能被实例化:</p><ol><li>函数对象</li><li>线程对象</li><li>文件句柄</li><li>数据库连接</li><li>Socket连接</li></ol><p>当你在windows系统下使用multiprocess遇到问题,首先检查是否涉及不能序列化的对象.</p></li></ol></blockquote><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h2><p>一个进程至少有一个线程,线程是操作系统直接支持的执行单元.python的线程是真正的Posix Thread,不是模拟出来的线程.</p><p>python的标准库有两个模块: <code>_thread</code>和<code>threading</code>.</p><p><code>threading</code>是<code>_thread</code>的高级封装,一般我们只要使用<code>threading</code>就行.</p><p>任何<code>进程</code>都会默认启动一个线程,称为<code>主线程</code>,主线程又可以启动新的线程.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time, threading<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>():<br>    thread_name = threading.current_thread().name <span class="hljs-comment"># current_thread()返回当前线程得实例,主线程名字就叫MainThread</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;thread_name&#125;</span> is running...&#x27;</span>)<br>    n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">5</span>:<br>        n = n + <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;thread_name&#125;</span> &gt;&gt;&gt; <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;thread_name&#125;</span> ended&#x27;</span>)<br>    <br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;threading.current_thread().name&#125;</span> is running&#x27;</span>)<br>t = threading.Thread(target=loop, name=<span class="hljs-string">&#x27;LoopThread&#x27;</span>) <span class="hljs-comment"># 创建子线程,执行loop函数,命名LoopThread,不命名的话默认是Thread-1,Thread-2,...</span><br>t.start()<br>t.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;thread <span class="hljs-subst">&#123;threading.current_thread().name&#125;</span> ended.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">thread MainThread is running...<br>thread LoopThread is running...<br>thread LoopThread &gt;&gt;&gt; 1<br>thread LoopThread &gt;&gt;&gt; 2<br>thread LoopThread &gt;&gt;&gt; 3<br>thread LoopThread &gt;&gt;&gt; 4<br>thread LoopThread &gt;&gt;&gt; 5<br>thread LoopThread ended.<br>thread MainThread ended.<br></code></pre></td></tr></table></figure><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><blockquote><ul><li>多进程中,同一个变量各自有一份拷贝存在于每个进程中,互不影响</li><li>多线程中,所有变量都是共享的,所以任何一个变量都可以被任何一个线程修改</li></ul></blockquote><p>下面是一个多线程同时操作导致变量数据混乱的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># multithread</span><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-comment"># 假定这是你的银行存款</span><br>balance = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change_it</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-comment"># 先存后取,结果应该为0</span><br>    <span class="hljs-keyword">global</span> balance <span class="hljs-comment"># 定义一个共享变量balance</span><br>    balance = balance + n<br>    balance = balance - n<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_thread</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>):<br>        change_it(n)<br>        <br>t1 = threading.Thread(target=run_thread, args=(<span class="hljs-number">5</span>,))<br>t2 = threading.Thread(target=run_thread, args=(<span class="hljs-number">8</span>,))<br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(balance) <span class="hljs-comment"># 理论上,因为先存后取,所以不管循环多少次,balance都应该为0</span><br></code></pre></td></tr></table></figure><blockquote><p>但是,由于线程的调度是由操作系统决定的,当<code>t1</code>,<code>t2</code>交替执行,balance就有出错的可能</p></blockquote><p>因为,高级语言的一条语句,在CPU执行时,实际上是若干条语句.比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">balance = balance + n<br></code></pre></td></tr></table></figure><p>在实际执行时,会分两步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">x = balance + n # 存入临时变量x<br>balance = x # 把临时变量的值赋给balance<br></code></pre></td></tr></table></figure><p>t1,t2交替执行,<code>临时变量x</code>在两个线程中单独存在,可能会出现这样的结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始值 balance = 0</span><br><br>t1: x1 = balance + 5  # x1 = 0 + 5 = 5<br><br>t2: x2 = balance + 8  # x2 = 0 + 8 = 8<br>t2: balance = x2      # balance = 8<br><br>t1: balance = x1      # balance = 5<br>t1: x1 = balance - 5  # x1 = 5 - 5 = 0<br>t1: balance = x1      # balance = 0<br><br>t2: x2 = balance - 8  # x2 = 0 - 8 = -8<br>t2: balance = x2      # balance = -8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">结果 balance = -8</span><br></code></pre></td></tr></table></figure><p>究其原因,是因为修改<code>balance</code>需要多条语句,而执行这几条语句时,线程可能中断,从而导致把同一个对象的内容改乱.</p><p>那么要确保一个线程修改<code>balance</code>的时候,别的线程一定不能改,此时就需要<code>锁机制</code>.</p><p>锁只有一个,无论有多少线程,同一时刻最多只能由一个线程持有锁.从而避免并发冲突.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br>balance = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_thread</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>        <span class="hljs-comment"># 先要获取锁:</span><br>        lock.acquire()<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 放心地改吧:</span><br>            change_it(n)<br>        <span class="hljs-keyword">finally</span>:<br>            <span class="hljs-comment"># 改完了一定要释放锁:</span><br>            lock.release()<br></code></pre></td></tr></table></figure><blockquote><p>当多个线程同时执行<code>lock.acquire()</code>时,只有一个线程能成功地获取锁,然后继续执行代码,其他线程就要继续等待知道获得锁为止.使用<code>try...finally</code>来保证锁的释放.</p><ul><li><p>所以锁虽然可以保证一个线程从头到尾地完整执行,但是也会导致其他线程一直处于等待状态,没办法实现真正并发,大大降低效率.</p></li><li><p>另外,可以存在多个锁,不同的线程持有不同的锁,并试图获取对方的锁时,可能会导致<code>死锁</code>,多个线程全部挂起,既不能执行,也无法结束,只能靠操作系统强制终止.</p></li></ul></blockquote><h2 id="python的多线程"><a href="#python的多线程" class="headerlink" title="python的多线程"></a>python的多线程</h2><p>按理来说,多核CPU可以同时跑多个线程,假如创建n个死循环线程,那么n个核就会被100%跑满.C, C++, Java都是如此.但是如果用python来实现时:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading, multiprocessing<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loop</span>():<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        x = x ^ <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(multiprocessing.cpu_count()): <span class="hljs-comment"># 启动与CPU核心数量相同的n个线程</span><br>    t = threading.Thread(target=loop)<br>    t.start()<br></code></pre></td></tr></table></figure><p>你会发现,cpu占用只去到102%,也就是仅跑满一个核.</p><blockquote><p>因为python解释器CPython在设计时,引入了GIL(Global Interpreter Lock)全局锁: 任何python线程执行前,必须先获得GIL锁,每执行100条字节码,解释器就会自动释放GIL锁,这才轮到别的进程.有了GIL的存在,python便无法真正地实现多线程并发.</p><p>目前(2024),GIL还无法移除,因此如果要使用python实现并发提升效率,目前主要的解决方案是:</p><ul><li>使用多进程编程</li><li>使用asyncio异步</li><li>使用C扩展在关键性能代码中释放GIL</li></ul></blockquote><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>多线程下,每个线程都有自己的数据.一个线程使用自己的局部变量比使用全局变量好.局部变量只有线程自己能用,全局变量要加锁.</p><p><code>ThreadLocal</code>是一个特殊的对象,它能够为每个线程存储独立的数据副本.这意味着,即使多个线程同时访问同一个<code>ThreadLocal</code>对象,每个线程都只能看到和操作自己的数据,不会影响其他线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> local<br><br><span class="hljs-comment"># 创建 ThreadLocal 对象</span><br>thread_local = local()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">worker</span>():<br>    <span class="hljs-comment"># 每个线程设置自己的数据</span><br>    thread_local.value = threading.current_thread().name<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;线程 <span class="hljs-subst">&#123;threading.current_theead().name&#125;</span> 设置的值: <span class="hljs-subst">&#123;thread_local.value&#125;</span>&#x27;</span>)<br>    <br><span class="hljs-comment"># 创建两个线程</span><br>t1 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;Thread-1&#x27;</span>)<br>t2 = threading.Thread(target=worker, name=<span class="hljs-string">&#x27;Thread-2&#x27;</span>)<br><br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br></code></pre></td></tr></table></figure><blockquote><p>主要用途包括:</p><ol><li>线程隔离: 每个线程都有自己的数据副本,避免了线程间的数据竞争.</li><li>全局变量替代: 可以避免使用全局变量来传递线程相关数据.</li><li>常见应用场景:<ol><li>数据库连接管理: 每个线程维护自己的数据库连接</li><li>用户身份信息: 在web应用重保存当前请求用户的信息</li><li>事务管理: 维护线程本地的事务状态</li></ol></li></ol></blockquote><p><code>ThreadLocal</code>在内存中的存储机制:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简化的内部实现原理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># meige ThreadLocal 对象都有一个字典</span><br>        <span class="hljs-comment"># key 是线程ID, value是该线程的数据</span><br>        <span class="hljs-variable language_">self</span>._storage = &#123;&#125;<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self</span>):<br>        thread_id = current_thread_id()<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._storage.get(thread_id)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, value</span>):<br>        thread_id = current_thread_id()<br>        <span class="hljs-variable language_">self</span>._storage[thread_id] = value<br></code></pre></td></tr></table></figure><p>存储的数据结构实际上类似这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<br>    <span class="hljs-string">&#x27;Thread-1&#x27;</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;User-0&#x27;</span>&#125;,<br>    <span class="hljs-string">&#x27;Thread-2&#x27;</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;User-1&#x27;</span>&#125;,<br>    <span class="hljs-string">&#x27;Thread-3&#x27;</span>: &#123;<span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;User-0&#x27;</span>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="进程-VS-线程"><a href="#进程-VS-线程" class="headerlink" title="进程 VS 线程"></a>进程 VS 线程</h1><p><a href="https://liaoxuefeng.com/books/python/process-thread/process-vs-thread/index.html">https://liaoxuefeng.com/books/python/process-thread/process-vs-thread/index.html</a></p><p>nginx是多进程+异步IO的Web服务器.</p><p>在多进程和多线程中应该优选多进程.因为进程更稳定,多线程下某个线程出问题很有可能导致整个进程都出问题.而且多进程可以分布到多台服务器上,而多进程只能同一台机器上的多个CPU.</p><h1 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h1><blockquote><p>python的<code>multiprocessing</code>的子模块<code>managers</code>支持把多进程分布到多台机器上.一个服务进程可以作为调度者,将任务分布到其他多个进程中,依靠网络来通信.</p></blockquote><p>比如之前我们写了一个用<code>Queue</code>通信的多进程程序,现在由于任务加重,希望把发送任务的进程和处理任务的进程分布到两台机器上.</p><p>通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去,就可以让其他机器访问<code>Queue</code>了.</p><blockquote><p>在一台机器上写多进程程序时,创建的<code>Queue</code>可以直接拿来用,但是在分布式进程环境中,添加任务到Queue不可以直接对原始的<code>task_queue</code>进行操作,这样就绕过了<code>QueueManager</code>的封装,必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加.</p></blockquote><p>先在一台机器上启动<code>任务进程</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># task_master.py</span><br><br><span class="hljs-keyword">import</span> random, time, queue<br><span class="hljs-keyword">from</span> multiprocessing.managers <span class="hljs-keyword">import</span> BaseManager<br><br><span class="hljs-comment"># 发送任务的队列</span><br>task_queue = queue.Queue()<br><span class="hljs-comment"># 接收结果的队列</span><br>result_queue = queue.Queue()<br><br><span class="hljs-comment"># 从BaseManager继承的QueueManager</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueManager</span>(<span class="hljs-title class_ inherited__">BaseManager</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义两个函数，用于获取任务队列和结果队列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_task_queue</span>():<br>    <span class="hljs-keyword">return</span> task_queue<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_result_queue</span>():<br>    <span class="hljs-keyword">return</span> result_queue<br><br><span class="hljs-comment"># 注册这两个函数</span><br>QueueManager.register(<span class="hljs-string">&#x27;get_task_queue&#x27;</span>, <span class="hljs-built_in">callable</span>= get_task_queue)<br>QueueManager.register(<span class="hljs-string">&#x27;get_result_queue&#x27;</span>,<span class="hljs-built_in">callable</span>= get_result_queue)<br><br><span class="hljs-comment"># 绑定端口5000, 设置验证码&#x27;abc&#x27;</span><br>manager = QueueManager(address=(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">5000</span>), authkey=<span class="hljs-string">b&#x27;abc&#x27;</span>)<br><span class="hljs-comment"># 启动Queue</span><br>manager.start()<br><span class="hljs-comment"># 通过网络访问Queue对象</span><br>task = manager.get_task_queue()<br>result = manager.get_result_queue()<br><span class="hljs-comment"># 放几个任务进去</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    n = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Put task <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>    task.put(n)<br><span class="hljs-comment"># 从result读取任务</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try get results...&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    r = result.get(timeout=<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Result: <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 关闭</span><br>manager.shutdown()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;master exit.&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在另一台机器上启动任务进程(本次测试在本机也行)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># task_worker.py</span><br><span class="hljs-keyword">import</span> time, sys, queue<br><span class="hljs-keyword">from</span> multiprocessing.managers <span class="hljs-keyword">import</span> BaseManager<br><br><span class="hljs-comment"># 创建类似的QueueManager</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueueManager</span>(<span class="hljs-title class_ inherited__">BaseManager</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 由于这个QueueManager只从网络上获取Queue,所以注册时只提供名字</span><br>QueueManager.register(<span class="hljs-string">&#x27;get_task_queue&#x27;</span>)<br>QueueManager.register(<span class="hljs-string">&#x27;get_result_queue&#x27;</span>)<br><br><span class="hljs-comment"># 连接到服务器,也就是运行task_master.py的机器</span><br>server_addr = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Connect to Server <span class="hljs-subst">&#123;server_addr&#125;</span> ...&#x27;</span>)<br><br><span class="hljs-comment"># 端口和验证码注意保持与task_master.py设置的一致</span><br>m = QueueManager(address=(server_addr, <span class="hljs-number">5000</span>), authkey=<span class="hljs-string">b&#x27;abc&#x27;</span>)<br><span class="hljs-comment"># 从网络连接</span><br>m.connect()<br><span class="hljs-comment"># 获取Queue的对象</span><br>task = m.get_task_queue()<br>result = m.get_result_queue()<br><span class="hljs-comment"># 从task队列取任务,并把结果写入result队列</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">try</span>:<br>        n = task.get(timeout=<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;run task <span class="hljs-subst">&#123;n&#125;</span> * <span class="hljs-subst">&#123;n&#125;</span>...&#x27;</span>)<br>        r = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;n&#125;</span> * <span class="hljs-subst">&#123;n&#125;</span> = <span class="hljs-subst">&#123;n*n&#125;</span>&#x27;</span><br>        time.sleep(<span class="hljs-number">1</span>)<br>        result.put(r)<br>    <span class="hljs-keyword">except</span> Queue.Empty:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;task queue is empty.&#x27;</span>)<br><span class="hljs-comment"># 处理结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;worker exit.&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">                                             │<br>┌─────────────────────────────────────────┐     ┌──────────────────────────────────────┐<br>│task_master<span class="hljs-selector-class">.py</span>                           │  │  │task_worker<span class="hljs-selector-class">.py</span>                        │<br>│                                         │     │                                      │<br>│  task = manager<span class="hljs-selector-class">.get_task_queue</span>()        │  │  │  task = manager<span class="hljs-selector-class">.get_task_queue</span>()     │<br>│  result = manager<span class="hljs-selector-class">.get_result_queue</span>()    │     │  result = manager<span class="hljs-selector-class">.get_result_queue</span>() │<br>│              │                          │  │  │              │                       │<br>│              │                          │     │              │                       │<br>│              ▼                          │  │  │              │                       │<br>│  ┌─────────────────────────────────┐    │     │              │                       │<br>│  │QueueManager                     │    │  │  │              │                       │<br>│  │ ┌────────────┐ ┌──────────────┐ │    │     │              │                       │<br>│  │ │ task_queue │ │ result_queue │ │◀───┼──┼──┼──────────────┘                       │<br>│  │ └────────────┘ └──────────────┘ │    │     │                                      │<br>│  └─────────────────────────────────┘    │  │  │                                      │<br>└─────────────────────────────────────────┘     └──────────────────────────────────────┘<br>                                             │<br><br>                                          Network<br></code></pre></td></tr></table></figure><blockquote><ol><li>Queue对象存储在task_master.py中</li><li>Queue可以通过网络访问是通过QueueManager实现的.由于QueueManager管理的不止一个Queue,所以要给每个Queue的网络调用接口起个名字,比如get_task_queue</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pyhton笔记-IO编程</title>
    <link href="/2024/08/22/pyhton-io/"/>
    <url>/2024/08/22/pyhton-io/</url>
    
    <content type="html"><![CDATA[<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>python内置函数,需要手动关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/xxxx/xxx/abc.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(f.read()) <span class="hljs-comment"># read 方法一次读取文件所有内容到内存</span><br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> f:<br>        f.close() <span class="hljs-comment"># 每次都要手动关闭文件</span><br></code></pre></td></tr></table></figure><h2 id="with…open…"><a href="#with…open…" class="headerlink" title="with…open…"></a>with…open…</h2><p>自动关闭文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path/to/file&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read()) <span class="hljs-comment"># 一次性读取全部内容</span><br>    <span class="hljs-comment"># readline() 每次读取一行</span><br><span class="hljs-comment"># readlines() 一次性读取所有内容并返回list</span><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>    <span class="hljs-built_in">print</span>(line.strip()) <span class="hljs-comment"># 去除每行结尾的\n</span><br></code></pre></td></tr></table></figure><h2 id="file-like-object"><a href="#file-like-object" class="headerlink" title="file-like object"></a>file-like object</h2><p>像<code>open()</code>函数返回的,有个<code>read()</code>方法的对象,在python中统称file-like object.除了file,还可以是内存字节流,网络流,自定义流等.file-like object不要求从特定类继承,只要有个<code>read()</code>方法即可.</p><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>要读取二进制文件,比如图片,视频等,用<code>&#39;rb&#39;</code>模式打开文件即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path/to/image&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>f.read()<br></code></pre></td></tr></table></figure><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过encoding参数定义</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path/to/gbk&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;gbk&#x27;</span>, errors=<span class="hljs-string">&#x27;ignore&#x27;</span>)<br><span class="hljs-comment"># error参数表示遇到编码错误后怎么处理</span><br></code></pre></td></tr></table></figure><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>通过<code>w</code>或<code>wb</code>模式来打开文件,表示写入文本文件或二进制文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path/to/file&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>f.write(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br>f.close()<br><span class="hljs-comment"># 系统不会立即把数据写入磁盘,而是先放到内存,空闲时才慢慢写入</span><br><span class="hljs-comment"># 调用close方法时,系统才保证把没有写入的数据全部写入磁盘</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;path/to/file&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>f.write(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h1 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h1><p>在内存中读写<code>IO</code>,就是一种file-like object.要实现在内存中读写,首先要创建一个<code>StringIO</code>,然后像文件一样写入即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br><span class="hljs-meta">&gt;&gt;&gt; </span>f = StringIO()<br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f.write(<span class="hljs-string">&#x27;world!&#x27;</span>)<br><span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(f.getvalue()) <span class="hljs-comment"># getvalue()用于获取写入后的str</span><br>hello world!<br><span class="hljs-comment"># 读</span><br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br>f = StringIO(<span class="hljs-string">&#x27;Hello!\nHi!\nGoodbye!&#x27;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    s = f.readline()<br>    <span class="hljs-keyword">if</span> s == <span class="hljs-string">&#x27;&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(s.strip())<br></code></pre></td></tr></table></figure><h1 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h1><p>StringIO只能操作<code>str</code>,如果要操作二进制,则要用<code>BytesIO</code></p><h1 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h1><p><code>os</code>模块可以直接调用操作系统提供的接口函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>os.name <span class="hljs-comment"># 操作系统类型</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>posix <span class="hljs-comment"># linux/unix/macOSx</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>nt <span class="hljs-comment"># windows</span><br><br>os.environ <span class="hljs-comment"># 系统定义的环境变量,全部保存在这个变量中</span><br>os.environ.get(<span class="hljs-string">&#x27;key&#x27;</span>) <br><br><span class="hljs-comment"># 查看目录绝对路径</span><br>os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>)<br><span class="hljs-comment"># 创建一个目录:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.mkdir(<span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span>)<br><span class="hljs-comment"># 删掉一个目录:</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.rmdir(<span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span>)<br><br><span class="hljs-comment"># 两个路径合成一个,通过os.path.join()函数,这样可以正确处理不同操作系统的路径分隔符</span><br>os.path.join(<span class="hljs-string">&#x27;/Users/michael&#x27;</span>, <span class="hljs-string">&#x27;testdir&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.join(<span class="hljs-string">&#x27;/Users/michael&#x27;</span>, <span class="hljs-string">&#x27;testdir&#x27;</span>)<br><span class="hljs-comment"># 拆分路径要用os.path.split(),可以把路径拆成两部分,后一部分是最后级别的目录或文件名</span><br>os.path.split(<span class="hljs-string">&#x27;/Users/michael/testdir/file.txt&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-string">&#x27;/Users/michael/testdir&#x27;</span>, <span class="hljs-string">&#x27;file.txt&#x27;</span>)<br><span class="hljs-comment"># os.path.splitext() 拆分文件后缀名</span><br>os.path.splitext(<span class="hljs-string">&#x27;path/to/file.txt&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(<span class="hljs-string">&#x27;/path/to/file&#x27;</span>, <span class="hljs-string">&#x27;.txt&#x27;</span>)<br><span class="hljs-comment"># 这些合并/拆分操作并不要求目录文件真实存在,只是字符串操作</span><br><br><span class="hljs-comment"># 重命名和删除</span><br>os.rename(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;test.py&#x27;</span>)<br>os.remove(<span class="hljs-string">&#x27;test.py&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>复制文件的函数在os模块中并不存在,原因是复制文件并不是由系统提供的系统调用.<code>shutil</code>模块提供了<code>copyfile()</code>函数来实现.</p><p>shutil可以看作是os的补充</p></blockquote><p>两个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列出当前目录下所有文件夹</span><br>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">if</span> os.path.isdir(x)]<br><span class="hljs-comment"># 列出当前目录下所有.py文件</span><br>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">if</span> ps.path.isfile(x) <span class="hljs-keyword">and</span> os.path.splitext(x)[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;.py&#x27;</span>]<br></code></pre></td></tr></table></figure><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>变量从内存中变为可存储或传输的过程称为<code>序列化</code>.</p><p>python中叫<code>pickling</code>,其他语言有不同的称呼,都是一个意思.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python提供pickle模块来实现序列化</span><br><span class="hljs-keyword">import</span> pickle<br>d = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;Bob&#x27;</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>)<br>pickle.dump(d) <span class="hljs-comment"># 把任意对象序列化成一个bytes,然后就可以把这个bytes写入文件</span><br><br><span class="hljs-comment"># 也可以直接写入一个file-like object</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;dump.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>pickle.dump(d, f)<br>f.close()<br><span class="hljs-comment"># 如果直接查看写入的dump.txt文件,你会发现是一堆乱七八糟的内容,这些都是python保存的对象内部信息</span><br><br><span class="hljs-comment"># 如果要把对象从磁盘读到内存,可以先把内容读取到一个bytes,然后用pickle.loads()方法反序列化出对象,也可以直接用pickle.load()从一个file-like object中反序列化出对象</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;dump.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>d = pickle.load(f)<br>f.close()<br><span class="hljs-built_in">print</span>(d)<br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;name=<span class="hljs-string">&#x27;Bob&#x27;</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>&#125;<br><span class="hljs-comment"># 需要注意的是,反序列化出来的变量和原来的变量是完全不相干的两个对象</span><br></code></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>如果我们要在不同的编程语言&#x2F;程序之间传递对象,就必须把对象序列化为标准格式,业界通用做法就是<code>JSON</code>.它表示出来就是一个字符串,可以被所有语言读取,也可以方便地存储到磁盘或者通过网络传输,还可以直接在web页面中读取,非常方便.</p><table><thead><tr><th>json类型</th><th>python类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>“string”</td><td>str</td></tr><tr><td>1234.56</td><td>int或float</td></tr><tr><td>true&#x2F;false</td><td>bool</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><p>内置<code>json</code>模块常用方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>d = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;Bob&#x27;</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>)<br>json.dumps(d) <span class="hljs-comment"># dumps()返回一个字符串,内容就是标准json</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>dumps()</td><td>返回一个字符串,内容就是标准json</td></tr><tr><td>dump()</td><td>直接把python对象序列化成json并写入file-like object</td></tr><tr><td>loads()</td><td>把json反序列化为python对象</td></tr><tr><td>load()</td><td>直接从file-like object读取字符串并反序列化</td></tr></tbody></table><h2 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h2><p>python的class 实例和json也可以序列化和反序列化</p><blockquote><p>绝大部分python的<code>class</code>的实例都有<code>__dict__</code>属性,用于保存<code>class</code>的变量,序列化时可以直接调用,如果不用它则手动写一个转换函数,例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">student2dict</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: s.name,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: s.age<br>    &#125;<br></code></pre></td></tr></table></figure><p>反序列化时需要手动写一个转换函数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dict2student</span>(<span class="hljs-params">d</span>):<br>    <span class="hljs-keyword">return</span> Student(d[<span class="hljs-string">&#x27;name&#x27;</span>], d[<span class="hljs-string">&#x27;age&#x27;</span>])<br><br><span class="hljs-comment"># 创建一个student实例</span><br>s = Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># 序列化,通过default指定转换函数</span><br>json_str = json.dumps(s, default=<span class="hljs-keyword">lambda</span> obj:obj.__dict__) <span class="hljs-comment"># 使用__dict__</span><br>json_str = json.dumps(s, default=student2dict) <span class="hljs-comment"># 使用转换函数</span><br><span class="hljs-comment"># lambda 匿名函数</span><br>    <span class="hljs-comment"># obj: 匿名函数的传参</span><br>    <span class="hljs-comment"># obj.__dict__ 匿名函数的返回值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;序列化结果:&#x27;</span>, json_str)<br><span class="hljs-comment"># 反序列化,通过object_hook指定转换函数</span><br>student_object = json.loads(json_str, object_hook=dict2student)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;反序列化结果:&#x27;</span>, student_object.name, student_object.age)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-错误和测试</title>
    <link href="/2024/07/28/python-error-n-test/"/>
    <url>/2024/07/28/python-error-n-test/</url>
    
    <content type="html"><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try...&#x27;</span>)<br>    r = <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;result:&#x27;</span>, r)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError:&#x27;</span>, e)<br><span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ZeroDivisionError:&#x27;</span>, e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;no error!&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><p>假如我们认为某些代码可能回出错,就可以用<code>try</code>来运行这段代码</p><p>如果执行出错,则后续代码不再执行,而是直接跳转至错误捕获代码,即<code>except</code>语句块,</p><p><code>else</code>会在try执行完毕且没有抛出异常时执行</p><p>不论有无异常抛出,<code>finally</code>都会执行,它会在try…except…else…都执行完后再执行</p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>python的错误也是类,所有错误类型都继承自<code>BaseException</code>,所以在使用<code>except</code>时,它会把定义的错误类型以及其所有<strong>子类</strong>一并捕获</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    foo()<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>)<br><span class="hljs-keyword">except</span> UnicodeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;UnicodeError&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里<code>UnicodeError</code>是<code>ValueError</code>的子类,所以第二个<code>except</code>是永远都捕获不到的,因为第一个except已经把父类给捕获了.</p><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">点击</a>查看常见错误类型及继承关系</p><h2 id="跨层调用"><a href="#跨层调用" class="headerlink" title="跨层调用"></a>跨层调用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error:&#x27;</span>, e)<br>    <span class="hljs-keyword">finally</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;finally...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>比如上面bar()调用foo(),main()调用bar().假如foo()出错,在main()中可以直接捕获到.</p><h2 id="异常栈"><a href="#异常栈" class="headerlink" title="异常栈"></a>异常栈</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># err.py:</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br><br>main()<br></code></pre></td></tr></table></figure><p>假如错误没有被捕获,它会一直往上抛,知道被python解释器捕获,然后打印错误信息并退出程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traceback (most recent call last): # 告诉我们这是错误的跟踪信息<br>  File &quot;err.py&quot;, line 11, in &lt;module&gt; # 调用main()出错,在代码文件err.py的第11行,但原因在第9行<br>    main()<br>  File &quot;err.py&quot;, line 9, in main # 调用bar(&#x27;0&#x27;)出错,在代码文件err.py的第9行,但原因在第6行<br>    bar(&#x27;0&#x27;)<br>  File &quot;err.py&quot;, line 6, in bar # 原因是return foo(s) * 2这个语句出错了但还不是最终原因<br>    return foo(s) * 2<br>  File &quot;err.py&quot;, line 3, in foo # return 10 / int(s)这个语句出错了,这是错误产生的源头,因为下面打印了具体错误<br>    return 10 / int(s)<br>ZeroDivisionError: division by zero # 根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头。<br></code></pre></td></tr></table></figure><p>这就是异常栈,出错了向大佬提问时记得把完整异常栈附上.</p><h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><p>python内置的<code>logging</code>模块可以轻松记录错误信息,而且程序出错后会继续执行,正常退出.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / <span class="hljs-built_in">int</span>(s)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> foo(s) * <span class="hljs-number">2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        bar(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        logging.exception(e) <span class="hljs-comment"># 捕获错误栈</span><br><br>main()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;END&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行后输出如下</span><br>ERROR:root:division by zero<br>Traceback (most recent call last):<br>  File &quot;err_logging.py&quot;, line 13, in main<br>    bar(&#x27;0&#x27;)<br>  File &quot;err_logging.py&quot;, line 9, in bar<br>    return foo(s) * 2<br>  File &quot;err_logging.py&quot;, line 6, in foo<br>    return 10 / int(s)<br>ZeroDivisionError: division by zero<br>END<br></code></pre></td></tr></table></figure><p>具体例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># enconding=utf-8</span><br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> sys<br><br>logging.basicConfig(filename=<span class="hljs-string">&#x27;app.log&#x27;</span>, level=logging.ERROR, <br>                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">divide</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">try</span>:<br>        result = x / y<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发生异常: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>, file=sys.stderr) <span class="hljs-comment"># 获取错误并输出到console的标准错误</span><br>        logging.error(<span class="hljs-string">f&quot;发生异常: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 记录到日志文件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-comment"># 示例用法</span><br>num1 = <span class="hljs-number">10</span><br>num2 = <span class="hljs-number">0</span><br><br>result = divide(num1, num2)<br><br><span class="hljs-keyword">if</span> result <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Done&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Done<br>发生异常: division by zero<br></code></pre></td></tr></table></figure><h2 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h2><h3 id="抛出自己定义的错误"><a href="#抛出自己定义的错误" class="headerlink" title="抛出自己定义的错误"></a>抛出自己定义的错误</h3><p>错误也是class,捕获一个错误本质上就是捕获该<code>class的一个实例</code>,因此错误并不是凭空产生的,而是有意创建并抛出的.python的内置函数会抛出很多类型的错误,我们也可以自己抛出错误.(但一般来说,尽量使用python内置的错误类型)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FooError</span>(<span class="hljs-title class_ inherited__">ValueError</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> FooError(<span class="hljs-string">f&#x27;invalid value: <span class="hljs-subst">&#123;s&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">raise</span> <span class="hljs-number">10</span> / n<br>    <br>foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br><br>&gt;&gt;&gt;<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;err_throw.py&quot;</span>, line <span class="hljs-number">11</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br>  File <span class="hljs-string">&quot;err_throw.py&quot;</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> foo<br>    <span class="hljs-keyword">raise</span> FooError(<span class="hljs-string">&#x27;invalid value: %s&#x27;</span> % s)<br>__main__.FooError: invalid value: <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="向上抛出错误"><a href="#向上抛出错误" class="headerlink" title="向上抛出错误"></a>向上抛出错误</h3><p>捕获错误的目的只是记录一下,便于后续追踪.但是如果当前函数不知道如何处理这个错误,最恰当的当时继续往上抛,让顶层调用者处理.(员工处理不了的问题抛个老板,老板处理不了抛个CEO).这是很常见的一个做法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;invalid value: %s&#x27;</span> % s)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bar</span>():<br>    <span class="hljs-keyword">try</span>:<br>        foo(<span class="hljs-string">&#x27;0&#x27;</span>)<br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError!&#x27;</span>)<br>        <span class="hljs-keyword">raise</span> <span class="hljs-comment"># raise不带参数,就会把当前错误原样抛出</span><br><br>bar()<br></code></pre></td></tr></table></figure><p>在<code>except</code>中<code>raise</code>一个error,还可以转换错误的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>: <br>    <span class="hljs-number">10</span> / <span class="hljs-number">0</span><br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;input error!&#x27;</span>) <span class="hljs-comment"># 将ZeroDivisionError转换成ValueError</span><br></code></pre></td></tr></table></figure><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>有时候遇到一些复杂的bug,需要知道出错时,哪些变量的值食正确的,哪些是错误的.此时就需要一套调试手段来修复.</p><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>最简单,最常见的手法,直接print出来</p><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>用断言来代替print</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">s</span>):<br>    n = <span class="hljs-built_in">int</span>(s)<br>    <span class="hljs-keyword">assert</span> n != <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;n is zero!&#x27;</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> / n<br></code></pre></td></tr></table></figure><p><code>assert</code>: 表达式<code>n != 0</code>应该是<code>true</code>,否则则断言失败,抛出<code>AssertionError</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traceback (most recent call last):<br>  ...<br>AssertionError: n is zero!<br></code></pre></td></tr></table></figure><p>执行时可以用<code>-O</code>来关闭断言</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python -O err.py</span><br>Traceback (most recent call last):<br>  ...<br>ZeroDivisionError: division by zero<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭后,所有assert语句都可以看成pass</span><br></code></pre></td></tr></table></figure><h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>通过写日志的方式记录错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>logging.info(<span class="hljs-string">&#x27;n = %d&#x27;</span> % n)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br><br>&gt;&gt;&gt;<br>INFO:root:n = <span class="hljs-number">0</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;err.py&quot;</span>, line <span class="hljs-number">8</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></table></figure><h2 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h2><p>python的调试器,让程序以单步方式运行,客户以随时查看运行状态.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如有这么一个程序</span><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure><p>然后通过pdb启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pdb err.py<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/Users/michael/Github/learn-python3/samples/debug/err.py(2)&lt;module&gt;()</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">s = <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment"># 这是pdb定位到的下一步要执行的代码</span></span><br></code></pre></td></tr></table></figure><p>输入<code>l</code>来查看代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(Pdb) l<br>  1     # err.py<br>  2  -&gt; s = &#x27;0&#x27;<br>  3     n = int(s)<br>  4     print(10 / n)<br></code></pre></td></tr></table></figure><p>输入<code>n</code>单步执行代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">(Pdb) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/Users/michael/Github/learn-python3/samples/debug/err.py(3)&lt;module&gt;()</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">n = int(s)</span><br>(Pdb) n<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/Users/michael/Github/learn-python3/samples/debug/err.py(4)&lt;module&gt;()</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash"><span class="hljs-built_in">print</span>(10 / n)</span><br></code></pre></td></tr></table></figure><p>任何时候输入<code>p &lt;变量名&gt;</code>来查看变量的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(Pdb) p s<br>&#x27;0&#x27;<br>(Pdb) p n<br>0<br></code></pre></td></tr></table></figure><p><code>q</code>退出</p><h2 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pdb<br><br>s = <span class="hljs-string">&#x27;0&#x27;</span><br>n = <span class="hljs-built_in">int</span>(s)<br>pdb.set_trace() <span class="hljs-comment"># 运行到这里会自动暂停</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span> / n)<br></code></pre></td></tr></table></figure><p>运行到<code>pdb.set_trace()</code>暂停并进入pdb调试环境,可以用命令<code>p</code>查看变量,或者命令<code>c</code>继续</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">python err.py</span> <br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/Users/michael/Github/learn-python3/samples/debug/err.py(7)&lt;module&gt;()</span><br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash"><span class="hljs-built_in">print</span>(10 / n)</span><br>(Pdb) p n<br>0<br>(Pdb) c<br>Traceback (most recent call last):<br>  File &quot;err.py&quot;, line 7, in &lt;module&gt;<br>    print(10 / n)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></table></figure><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>上面的方法都是土方法,最方便的就是用IDE自带的调试功能.</p><p>以vscode为例:</p><blockquote><p>设置断点: 在代码行号左侧单击,出现一个红色的圆点,表示设置了一个断点.</p><p>launch.json: vscode 自动生成一个launch.json文件,用来配置环境.用来设置调试类型,启动程序,参数等.</p><p><code>F5</code>启动用调试</p><p>继续<code>F5</code>执行到下一个断点</p><p>单步跳过<code>F10</code>: 逐行执行代码,遇到函数调用时跳过函数内部</p><p>单步调试<code>F11</code>: 逐行执行代码,遇到函数调用时进入函数内部</p><p>跳出<code>Shift+F11</code>: 跳出当前函数</p><p>重新开始调试<code>Shift+Cmd+F11</code></p><p>结束调试<code>Shit+F5</code></p></blockquote><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><blockquote><p>测试驱动开发(TDD: Test-Driven Development)</p></blockquote><p>单元测试是对一个模块,一个函数或者一个类来进行正确性检验的测试工作.</p><blockquote><p>比如对函数<code>abs()</code>,我们可以编写出以下几个测试用例.</p><ol><li>输入正数,比如<code>1</code>, <code>1.2</code>, <code>0.99</code>,期待返回值与输入相同</li><li>输入负数,比如<code>-1</code>,<code>-1.2</code>,<code>-0.99</code>,期待返回值与输入值相反</li><li>输入<code>0</code>,期待返回<code>0</code></li><li>输入非数值类型,比如<code>None</code>,<code>[]</code>,<code>&#123;&#125;</code>,期待抛出<code>TypeError</code></li></ol><p>把上面的测试用例放到一个测试模块里,就是一个完整的单元测试.</p><p>单元测试通过,说明我们测试的这个函数能够正常工作.单元测试不通过,要么函数有bug,要么测试条件不正确,总之需要修复使单元测试通过.</p></blockquote><p>下面编写一个<code>Dict</code>类,行为与<code>dict</code>一致,但是可以通过属性来访问:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d = <span class="hljs-type">Dict</span>(a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d.a<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dict</span>(<span class="hljs-title class_ inherited__">dict</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, **kw</span>):<br>        <span class="hljs-built_in">super</span>.__init__(**kw)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>[key]<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">f&quot;&#x27;Dict&#x27; object has no attribute <span class="hljs-subst">&#123;key&#125;</span>&quot;</span>)<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-variable language_">self</span>[key] = value<br></code></pre></td></tr></table></figure><p>要编写单元测试,需要用到python自带的<code>unittest</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># mydict_test.py</span><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">from</span> mydict <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span><br><br><span class="hljs-comment"># 写单元测试,需要写一个测试类,继承自unittest.TestCase</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDict</span>(unittest.TestCase):<br>    <span class="hljs-comment"># 以test开头的就是测试方法,不以test开头的不被认为是测试方法,测试时不会被执行</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_init</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>(a=<span class="hljs-number">1</span>, b=<span class="hljs-string">&#x27;test&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.assertEqual(d.a, <span class="hljs-number">1</span>) <span class="hljs-comment"># 断言函数返回结果与1相等</span><br>        <span class="hljs-variable language_">self</span>.assertEqual(d.b, <span class="hljs-string">&#x27;test&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.assertTrue(<span class="hljs-built_in">isinstance</span>(d, <span class="hljs-built_in">dict</span>)) <span class="hljs-comment"># 类型检查断言,检查返回值类型</span><br>        <span class="hljs-comment"># self.assertIsInstance(d, dict) # 与上面效果相同</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_key</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        d[<span class="hljs-string">&#x27;key&#x27;</span>] = <span class="hljs-string">&#x27;value&#x27;</span><br>        <span class="hljs-variable language_">self</span>.assertEqual(d.key, <span class="hljs-string">&#x27;value&#x27;</span>) <br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_attr</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        d.key = <span class="hljs-string">&#x27;value&#x27;</span><br>        <span class="hljs-variable language_">self</span>.assertTrue(<span class="hljs-string">&#x27;key&#x27;</span> <span class="hljs-keyword">in</span> d)<br>        <span class="hljs-variable language_">self</span>.assertEqual(d[<span class="hljs-string">&#x27;key&#x27;</span>], <span class="hljs-string">&#x27;value&#x27;</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_keyerror</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.assertRaises(KeyError): <span class="hljs-comment"># 期待排除指定类型Error的断言</span><br>            value = d[<span class="hljs-string">&#x27;empty&#x27;</span>]<br>            <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_attrerror</span>(<span class="hljs-params">self</span>):<br>        d = <span class="hljs-type">Dict</span>()<br>        <span class="hljs-keyword">with</span> <span class="hljs-variable language_">self</span>.assertRaises(AttributeError):<br>            value = d.empty<br></code></pre></td></tr></table></figure><p><code>unittest.TestCase</code>内置很多断言,常用的有:</p><ul><li><code>self.assertEqual(abs(-1), 1)</code>: 断言函数返回结果是否与预期的一致</li><li><code>self.assertTrue</code>: 验证条件是否为True,True则通过,False则不通过并抛出<code>AssertionError</code></li><li><code>self.assertIsInstance</code>: 类型检查断言</li><li><code>with self.assertRaises</code>: 检查抛出的错误是否与预期的一致</li></ul><p>运行单元测试的方式推荐使用如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m unittest mydict_test<br>.....<br>----------------------------------------------------------------------<br>Ran 5 tests in 0.000s<br><br>OK<br></code></pre></td></tr></table></figure><p>可以一次批量运行多个单元测试.</p><h2 id="setUp-and-tearDown"><a href="#setUp-and-tearDown" class="headerlink" title="setUp and tearDown"></a>setUp and tearDown</h2><p>单元测试中两个特殊方法:</p><ul><li><code>setUp()</code>: 调用一个测试方法<code>前</code>执行</li><li><code>tearDown</code>: 调用一个测试方法<code>后</code>执行</li></ul><h2 id="实际使用例子"><a href="#实际使用例子" class="headerlink" title="实际使用例子"></a>实际使用例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUserService</span>(unittest.TestCase):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 测试前准备，比如创建测试数据库连接</span><br>        <span class="hljs-variable language_">self</span>.db = Database()<br>        <span class="hljs-variable language_">self</span>.user_service = UserService(<span class="hljs-variable language_">self</span>.db)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 测试后清理，比如关闭连接</span><br>        <span class="hljs-variable language_">self</span>.db.close()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_create_user</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 可以进行多个断言</span><br>        user = <span class="hljs-variable language_">self</span>.user_service.create_user(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;zhangsan@example.com&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.assertEqual(user.name, <span class="hljs-string">&quot;张三&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.assertTrue(user.<span class="hljs-built_in">id</span> &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-variable language_">self</span>.assertRegex(user.email, <span class="hljs-string">r&#x27;^[\w\.-]+@[\w\.-]+\.\w+$&#x27;</span>)<br>    <br><span class="hljs-meta">    @unittest.skipIf(<span class="hljs-params">ENV == <span class="hljs-string">&#x27;production&#x27;</span>, <span class="hljs-string">&quot;不在生产环境运行&quot;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_sensitive_operation</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 可以跳过某些测试</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>组织结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># tests/</span><br><span class="hljs-comment">#   __init__.py</span><br><span class="hljs-comment">#   test_models/</span><br><span class="hljs-comment">#     test_user.py</span><br><span class="hljs-comment">#     test_order.py</span><br><span class="hljs-comment">#   test_services/</span><br><span class="hljs-comment">#     test_auth.py</span><br><span class="hljs-comment">#     test_payment.py</span><br></code></pre></td></tr></table></figure><p>与测试工具集成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 与 pytest 集成使用</span><br><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPayment</span>:<br><span class="hljs-meta">    @pytest.fixture</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">payment_service</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> PaymentService()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_payment</span>(<span class="hljs-params">self, payment_service</span>):<br>        <span class="hljs-keyword">with</span> pytest.raises(InsufficientBalance):<br>            payment_service.process_payment(-<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h1 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h1><p>python有个<code>doctest</code>模块,可以自动提取代码中的注释的示例代码来实现测试.对于注释它要符合基本格式规则才能识别:</p><ol><li>在<code>三引号</code>文档字符串中编写</li><li>使用<code>&gt;&gt;&gt;</code>开头表示python提示符</li><li>期望的输出直接写在新行上(不带提示符)</li><li>如果有多行输出,需要确保空白完全匹配</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;返回两个数的和</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &gt;&gt;&gt; add(1, 2)</span><br><span class="hljs-string">    3</span><br><span class="hljs-string">    &gt;&gt;&gt; add(-1, 1)</span><br><span class="hljs-string">    0</span><br><span class="hljs-string">    &gt;&gt;&gt; add(1.5, 2.5)</span><br><span class="hljs-string">    4.0</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;自定义列表类</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &gt;&gt;&gt; lst = MyList([1, 2, 3])</span><br><span class="hljs-string">    &gt;&gt;&gt; lst.append(4)</span><br><span class="hljs-string">    &gt;&gt;&gt; lst.get_all()</span><br><span class="hljs-string">    [1, 2, 3, 4]</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    &gt;&gt;&gt; lst.pop()</span><br><span class="hljs-string">    4</span><br><span class="hljs-string">    &gt;&gt;&gt; lst.get_all()</span><br><span class="hljs-string">    [1, 2, 3]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, items</span>):<br>        <span class="hljs-variable language_">self</span>.items = <span class="hljs-built_in">list</span>(items)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">append</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-variable language_">self</span>.items.append(item)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items.pop()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_all</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.items<br><br><span class="hljs-comment"># 运行测试的方法1：在模块末尾添加 (不推荐)</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> doctest<br>    doctest.testmod()<br></code></pre></td></tr></table></figure><p>推荐的运行测试的方法与<code>unittest</code>类似:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m doctest your_script.py<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面经</title>
    <link href="/2024/06/20/interview-git/"/>
    <url>/2024/06/20/interview-git/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/interview-1018333_640.png" srcset="/img/loading.gif" lazyload></p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ol><li><p>LinuxA磁盘的文件全部迁移到B磁盘</p><p>dd命令</p></li><li><p>如何创建lvm卷?</p><p>fdisk分区–&gt;pvcreate–&gt;vgcreate–&gt;lvcreate–&gt;格式化–&gt;挂载</p></li><li><p>100亿小文件删除，对比怎么删除比较高效?</p><ol><li><p>find + xargs实现分批删除</p><p>find命令可以在找到文件的同时逐个处理,不需要将整个文件列表读入内存.</p><p>find命令的算法可以更快地便利目录结构,避免不必要的IO操作</p></li><li><p>使用rsync创建一个空目录然后同步过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir empty_dir<br>rsync -a --delete emplty_dir/ /path/to/files<br></code></pre></td></tr></table></figure></li><li><p>并发删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /path/to/files -type f -name &quot;*.ext&quot; | parallel -j 10 rm<br></code></pre></td></tr></table></figure></li></ol></li><li><p>1亿行日志文件,要根据关键字统计出现次数前十的日志,只用脚本,如何做效率比较高?</p><p>将日志拆成多份,使用awk,sed,sort等工具统计排序,可以通过shell的parallel或者python的subprocess多进程&#x2F;多线程提升效率.</p></li><li><p>shell逐行处理大日志文件,有哪几种方式,有什么区别?</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">cat</span>会一次过读取整个文件的内容</span><br>cat filename.log | while read line<br>do<br>echo &quot;$line&quot;<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">while</span> + 输入重定向,边读边处理,效率更高</span><br>while read line<br>do<br>echo &quot;$line&quot;<br>done &lt; filename.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">awk/sed也是默认逐行处理</span><br>awk &#x27;&#123;print&#125;&#x27; filename.log<br>sed -n &#x27;p&#x27; filename.log<br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取实时写入的日志文件</span><br>tail --f filename.log | while read line<br>do<br>echo &quot;$line&quot;<br>done<br></code></pre></td></tr></table></figure></li></ol><h1 id="中间件-DB"><a href="#中间件-DB" class="headerlink" title="中间件&#x2F;DB"></a>中间件&#x2F;DB</h1><ol><li><p>zookeeper</p></li><li><p>kafka</p><p>架构: 生产者–&gt;broker–&gt;消费者</p><p>topic: 消息类别,生产者和消费者根据topic发送消息或消费消息</p><p>partition: 副本机制</p></li><li><p>redis</p><p>哨兵集群</p></li><li><p>mariadb</p><p>主从集群</p></li><li><p>mongodb</p><p>副本集</p></li><li><p>SQL联表查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 内连接<br># 只返回两个表中匹配的记录,如果表A的行与表B的行相匹配,则返回<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br># 左连接<br># 返回左表所有记录和右表中与匹配的记录,没有匹配就显示空值<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br># 右连接<br># 返回右表所有记录以及左表中匹配的记录,没有匹配就显示空值<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br># 全外连接<br># 返回两个表中所有的记录.当左表的行在右表中没有匹配,则在右侧显示空值,反之亦然<br><span class="hljs-keyword">select</span> columns <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">full</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.column_name <span class="hljs-operator">=</span> table2.column_name<br></code></pre></td></tr></table></figure></li></ol><h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><ol><li><p>团队维护同一份github repo,你们是工作流是怎么样的?</p><p>一般采用类似Feature Branch Workflow的流程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;repo_url&gt;<br>git checkout -b &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在分支上开发</span><br>git add .<br>git commit -m &quot;Commit message&quot;<br>git push -u origin &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会在repo上创建一个PR,团队成员对代码进行审查(code review),通过后merge到master分支</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后删除本地和远程的开发分支</span><br>git branch -d feature_branch_name  # 删除本地分支<br>git push origin --delete feature_branch_name  # 删除远程分支<br></code></pre></td></tr></table></figure><p>这是基本的工作流程,期间还可以加入其他步骤,例如代码静态分析(snoarQ),自动化测试,CI&#x2F;CD等</p></li></ol><h1 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h1><ul><li><p>Region &amp; AZs</p><p>region是指地球上的一个物理位置,比如北京,悉尼等.每个region底下都有多个AZ(可用区),AZ是指一个或者多个IDC,AZ之间独立电源和设备,相互之间通过专用线路连接,延迟低的同时也实现故障分离.也就是说一个AZ出问题了不会影响另一个AZ.所以AWS很多服务,比如EC2,RDS的高可用都是通过多可用区去实现的.</p></li><li><p>EC2</p><ul><li>autoscaling组: 自动扩展组</li><li>购买类型<ul><li>预留: 预定(一年或三年)的计算资源,折扣比按需大</li><li>spot: 将aws上未被使用的资源分配给你用,随时停止,按供需变化价格</li><li>按需: 按小时或秒收费</li><li>节省: 在一定时间内(一年或三年)使用一定量的计算资源,换取更低的价格</li></ul></li><li>集群放置组: 单可用区内将实例分配在一起(同一台物理服务器或同一个机架),实现低延迟高吞吐</li><li>分区放置组: 将一批ec2实例分布在一个region下的不同分区中(或者不同机架不同服务器),实现故障隔离.</li><li>实例类型:<ul><li>T3:通用</li><li>R5: 内存优化</li></ul></li><li>终止挂起: EC2 autoscaling检测在实例不健康会自动删除实例创建新实例,有时不方便排查问题,我们可以设置一个生命周期钩子来暂停实例的终止,设置足够长的保留时间来排查问题</li></ul></li><li><p>AWS organization</p><p>集中管理，治理多个aws账户，提供policy为基础的管理功能，用于统筹管理权限.还支持集中账单和提供自动化API.</p><ul><li><p>OUs： 组织单元，允许你按照工作负载，部门，生命周期阶段（测试，开发，生产）等来<code>分组账户</code>.</p></li><li><p>SCP: 服务控制策略，用来管理成员账户的权限.应用到组织的root,OUs或单个账户</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cloudtrail:StopLogging&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 禁止关闭cloudtrail日志记录</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>IAM</p><ul><li><p>Access Analyzer:  可以通过分析couldtrail日志记录的活动生成IAM访问策略</p></li><li><p>AAA: 认证(authentic)&#x2F;授权(Authorized)&#x2F;记录(Acounting)</p><p>解决谁可以访问什么资源的问题</p></li><li><p>用户:</p><ul><li><p>根用户: 超级管理员,注册aws的账户</p></li><li><p>普通IAM用户: 代表一个具体的人或服务,每个用户都有特定的权限</p></li><li><p>IAM组: 一组具有同样身份的用户</p></li><li><p>IAM 角色(role): 一种权限的集合,任何授权的用户或aws服务都可以暂时性地采用</p></li><li><p>IAM policy</p><p>用户和角色的授权都是通过IAM policy实现,IAM policy一般直接绑定到用户&#x2F;用户组&#x2F;角色,所以不需要写<code>principal</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;ec2:Describe*&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;ec2:StartInstances&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;ec2:StopInstances&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;ec2:TerminateInstances&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>IAM role trust policy</p><p><code>角色信任策略</code>,定义<code>哪些账户或服务可以扮演IAM角色</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;Service&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ec2.amazonaws.com&quot;</span> <span class="hljs-comment">// 允许ec2服务扮演(assume)这个角色</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRole&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br>---<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:iam::123456789012:root&quot;</span> <span class="hljs-comment">// 允许特定的账户扮演这个角色</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRole&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>VPC</p><p>虚拟私有云,可以理解为一个局域网,aws提供的虚拟网络</p><ul><li><p>Peering Link: 对等连接,连接两个vpc(不通过公共互联网传输),两个vpc都要加路由(目的地是对方vpc cidr,指向peering connection),双向,网络对网络</p></li><li><p>Private Link: 在你的vpc中通过私有的网络路径安全地访问aws服务或vpc终端节点,单向,一对一</p><ul><li>VPC endpoint:<ul><li>interface endpoint: 实际上是vpc内创建一个于特定AWS服务相关联的弹性网络接口(ENI),无需修改路由表</li><li>gateway endpoint: 针对S3和dynamoDB的流量优化端点,需要修改路由表</li></ul></li></ul></li><li><p>NACLs: 网络访问控制列表,子网级别的访问控制</p><ul><li>默认拒绝所有</li><li>无状态</li><li>作用在子网,一个NACLs可以关联多个子网,但一个子网只能关联一个NACL</li><li>按顺序匹配规则,第一个匹配的规则生效</li><li>支持黑白名单</li></ul></li><li><p>VPC endpoint policy: 资源策略,用于管理和控制到VPC Endpoint服务的访问,控制哪些aws主题可以使用该端点访问服务</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:iam::123456789012:user/MyUser&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::my-s3-bucket/*&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;StringEquals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;aws:sourceVpce&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vpce-01a23456b789c0d1e&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>AWS的policy默认是拒绝所有的,它的显式拒绝(effect: Deny)会<code>覆盖允许</code>.就是显式拒绝后,就算有其他策略允许了,还是会被拒绝.</p></blockquote></li><li><p>安全组: 虚拟防火墙,控制实例之间的出入流量</p><ul><li>有状态</li><li>默认允许出禁止入</li><li>作用在实例级别.安全组和实例是多对多的关系</li><li>所有规则同时生效(只要有允许该流量的规则,流量就会被放行)</li><li>白名单</li></ul></li><li><p>公有子网: 公有子网的实例可以直接通过<code>互联网网关</code>连接到互联网</p></li><li><p>私有子网: 私有子网通过<code>nat网关</code>去到公有子网再通过<code>互联网网关</code>出到互联网</p><ul><li>nat gateway: 运行在公有子网中给私有子网实例</li></ul></li></ul></li><li><p>ELB</p><ul><li><p>ALB</p><ul><li><p>可以通过安全组控制访问源，仅允许cloudfront流量(com.amazonaws.global.cloudfront)进入，这样客户端就只能访问cloudfront</p></li><li><p>工作在7层的负载均衡</p></li><li><p>根据URL或http头信息路由</p></li><li><p>支持websocket和http&#x2F;2</p></li><li><p>集成ECS和EKS</p><ul><li><p>代理EKS流量</p><blockquote><ol><li>在EKS中部署ALB Ingress Controller</li><li>部署ingress资源</li><li>在应用ingress资源时,ALB ingress controller会为你创建ALB并配置对应的监听器(linstener)和转发规则</li></ol></blockquote></li></ul></li><li><p>提供SSL&#x2F;TLS加解密功能,可以挂https证书</p></li><li><p>元素</p><ul><li><p>监听器(listener): 监听客户端请求(一般是80&#x2F;443),并根据请求路由到目标组的组件</p><ul><li>监听器上可以挂TLS证书(https)</li></ul></li><li><p>目标组(target group): 多个服务端点(ECS容器&#x2F;EC2实例或Lambda函数)组成的集合,每个target group针对特定的服务和端口</p><ul><li>ALB到target group也可以配置TLS</li></ul></li><li><p>规则(rules): 通过监听器上定义的条件和优先级路由到不同的目标组</p></li><li><p>健康检查: 判断目标组中的服务端点是否可以正常接受流量</p><ul><li>HTTP&#x2F;HTTPS&#x2F;TCP</li></ul></li></ul></li></ul></li><li><p>NLB</p><ul><li>工作在4层的负载均衡器</li><li>针对TCP流量优化,可以处理不稳定的和突发的流量</li><li>每个NLB都可以使用一个<code>静态IP</code></li><li>每个AZ一个独立端点,确保扩展性和容错</li><li>使用TCP长连接(websocket)</li><li>元素:<ul><li>监听器(listener)</li><li>目标组(target group)</li><li>健康检查</li><li>NLB也提供TLS监听器</li><li>粘性会话: 通过source IP</li></ul></li></ul></li></ul></li><li><p>Lambda</p><p>程序运行不可以超过15分钟</p><p>内存提供128MB-10GB</p><p>成本计算按<code>GB-秒</code>,也就是1GB用1s多少钱</p></li><li><p>S3</p><ul><li><p>版本控制</p><ol><li>上传的每个对象都会被分配一个唯一的<code>版本ID</code></li><li>对象被覆盖或删除时,旧版本不会被删除而是保留下来</li><li>上传一个跟已存在对象同名的文件,旧文件不会被覆盖,新文件会获得一个唯一的版本ID</li><li>检索开启版本控制的对象,要指定其版本ID,默认返回最新的</li><li>删除开启版本控制的对象,只会逻辑删除.删除对象的特定版本,该版本就会被删除;删除所有版本,对象才会被永久删除</li><li>开启版本控制后的存储桶才能设置<code>生命周期策略</code>,例如自动删除一定时间后的旧版本</li></ol></li><li><p>MFA delete: 多因素删除,要通过多因素认证才能删除对象</p></li><li><p>总的来说S3存储的类型可以这么划分:</p><ul><li><p>standard: 默认.即存即取</p></li><li><p>IA: 非频繁访问</p></li><li><p>Glacier(冰川): 更低的访问频率,读取需要时间,需要收费</p><ul><li>Glacier Deep: 读取延迟12-48小时</li></ul></li><li><p>Intelligent-tiering: 根据访问频率自动归类,免费</p></li></ul></li><li><p>加密</p><ul><li>SSE-S3: 使用S3自己管理的密钥加密数据,每个对象都有唯一的密钥且使用一个主密钥加固</li><li>SSE-KMS: 使用KMS管理的密钥加密数据,KMS提供密钥审计,访问控制和rotate等功能</li></ul></li><li><p>object-lock</p><ul><li>治理模式: 大多数用户不能修改对象,但可以授权某些用户可以修改对象</li><li>和规模式: 任何用户(包括根用户)在保护期之前都不能修改对象</li></ul></li><li><p>访问控制:</p><ol><li><p>存储桶策略: json定义账户对s3的访问,一般都是直接使用存储桶策略</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// policy版本&quot;2008-10-17&quot;或&quot;2012-10-17&quot;,建议选最新的以使用最新功能</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PublicReadForGetBucketObjects&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:PutObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;DenyPublicDelete&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:DeleteObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>ACLs: 粒度比桶策略粗</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccessControlPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Owner</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>owner-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Owner</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AccessControlList</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grant</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Grantee</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">&quot;CanonicalUser&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>owner-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Grantee</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span>&gt;</span>FULL_CONTROL<span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grant</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grant</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Grantee</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">&quot;CanonicalUser&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>user-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Grantee</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span>&gt;</span>READ<span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grant</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">AccessControlList</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AccessControlPolicy</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>IAM policy: 授权用户,组或角色对s3访问</p></li><li><p>预签名URL: 生成一个临时连接,允许用户在没有aws身份验证的前提下访问你的s3对象,有限时</p></li><li><p>跨资源共享(CORS):  设置CORS规则,允许一个或多个指定源的web应用程序对你的s3对象操作</p></li></ol></li></ul></li><li><p>ECS&#x2F;EKS&#x2F;Fargate </p><blockquote><p><code>ECS</code>是高度可扩展的容器管理服务,用于运行,停止和管理docker容器,提供两种模式,其中一种就是fargate,由AWS管理底层资源,用户无需关心底层配置,另一种是EC2模式,创建EC2实例来运行容器,用户需要自己管理EC2.<code>EKS</code>也是类似,有EC2和fargate模式,不过不论哪种模式,使用EKS都不需要管理控制平面的组件,即时是EC2模式,也是通过EC2实例来运行工作节点.</p></blockquote><ul><li><p>task definition: 类似<code>dockerfile+docker run</code>,用来定义如何在ECS上运行容器</p></li><li><p>TaskRoleARN: ECS task关联的IAM角色的ARN.这个角色赋予ECS任务中容器所需权限.</p></li></ul><p>EKS集群如何升级:</p><ul><li><p>影响</p><blockquote><p><code>控制平面</code>的升级是AWS负责的,即使是多可用去高可用,控制平面的升级仍然可能会遇到短暂影响,因为:</p><ol><li>即使使用滚动更新,依然不能排除会有一瞬间的连接失败,因为始终都会有流量转移的操作</li><li>假如还要升级etcd,etcd的中断也会造成某个时间点API的短暂不可用</li><li>ELB和网络路由可能会随着集群升级而进行调整或替换,AWS会尽力保证平滑过渡,但是短暂的抖动是无法避免的</li><li>控制平面升级,集群API会有短暂的不可用,会影响监控,调度等</li></ol><p><code>工作节点</code>升级分两种,一种是EC2模式,一种是fargate模式</p><p>EC2模式又分两种:</p><ul><li>托管节点组<ul><li>AWS会帮你完成大部分工作节点的运维操作,比如:<ul><li>自动化补丁更新和版本升级</li><li>自动替换不健康的节点</li><li>自动使用EKS优化的AMI</li><li>升级过程自动替换节点<ul><li>先启用新版本(新AMI)的节点</li><li>新节点加入集群</li><li>对新节点进行健康检查</li><li>排空旧节点上的pod</li><li>排空后终止旧节点</li></ul></li></ul></li><li>你只需要在EKS控制台,AWS CLI或AWS SDK发起升级即可,AWS会完成剩余操作</li></ul></li><li>自管理节点组<ul><li>则需要用户手动完成上面的操作</li><li>首先要确保控制平面升级成功</li><li>以<code>蓝绿发布</code>的方式升级:<ul><li>使用新的AMI或者手动升级好工作组件版本的AMI来创建新节点</li><li>把新节点加入到集群</li><li>把旧节点排空,确认pod有正常调度到别的节点或者新节点中</li><li>把旧节点踢除</li></ul></li></ul></li></ul><p>至于<code>fargate</code>模式,你只需要确保你的pod在新版本中兼容即可.对比EC2的托管节点组,还是有些区别:</p><ul><li>使用托管节点组,用户需要配置节点组,比如实例类型,数量和自动缩放设置,AWS负责节点的生命周期管理;fargate模式下用户不需要管这些</li><li>fargate完全serverless,以为着你不能进入到节点中做操作</li><li>对于持久存储,ec2模式可以直接使用ebs,如果要共享持久存储,可以使用EFS,FSx for linux&#x2F;windows或S3,以及第三方存储解决方案ceph等,fargate不支持ebs</li></ul></blockquote></li><li><p>备份: 升级前对etcd执行快照备份是必须的,EKS默认会定期备份etcd快照到S3</p></li></ul><p>EKS监控:</p><ul><li>cloudwatch: metrics&#x2F;logs&#x2F;alarms</li><li>eventBridge</li><li>AWS X-Ray: 跟踪分析调试微服务之间的通信</li><li>AMP(Amazon Managed Service for Prometheus): 相当于完全托管的prometheus+grafana服务,与EKS集成,自动发现和监控集群资源</li><li>第三方: datadog</li></ul></li><li><p>Confluent</p><p>完全托管的Kafka服务,可以与lambda,S3等aws服务无缝集成</p></li><li><p>Cloudfront</p><p>CDN服务,提供基础的DDos防护.另外也有故障切换功能</p></li><li><p>AWS glue</p><p>完全托管的ETL(提取,转换,加载)服务,用于处理大量复杂数据准备和载入工作.</p><ul><li><p>glue爬虫(Crawler)</p><p>数据探索: 自动连接到你的数据存储,分析并推断你的数据结构和模式(表,列,数据类型等)</p></li><li><p>自定义分类器(Custom Classifier)</p><p>标准的分类器无法准确识别你的数据格式就需要创建自定义的grok模式来识别</p></li><li><p>grok: 用于解析复杂文本数据和日志的强大工具,由一系列正则表达式组成.grok模式广泛应用在logstash中</p></li></ul></li><li><p>R53</p><p>提供DNS解析,域名注册,健康检查等服务</p><ul><li><p>故障转移:</p><ul><li><p>主动&#x2F;被动: 只有主资源在服务,主资源不健康,流量转到备用资源中</p></li><li><p>主动&#x2F;主动: 多份资源同时服务</p></li></ul></li><li><p>路由策略</p><ul><li>简单: 基础dns查询,不支持健康检查</li><li>延迟: 资源部署在多个aws区域,基于网络延迟,向延迟最低的region路由</li><li>多值: 关联多个资源,并进行健康检查,随机选一个健康的来响应</li><li>地理位置: 根据dns查询发起的地理位置来路由</li></ul></li></ul></li><li><p>secret manager</p><p>专门保护管理敏感信息(用户名密码,密钥等),支持密钥自动rotate,可以使用kms的密钥来加密</p></li><li><p>Event bridge</p><p>无服务器的事件(aws资源状态变更&#x2F;时间表等)总线,基于事件触发aws服务,api调用等</p></li><li><p>SNS: 简单通知服务,发邮件</p></li><li><p>CloudWatch</p><p>有仪表盘,可以监控可以告警,与autoscaling集成,自动调整资源</p><p>复合告警: 通过监控其他告警状态来确定复合告警的状态</p><p>可以监控:</p><ul><li>性能: 实时监控aws资源(ec2实例,rds数据库,s3等)的性能(cpu,流量,IO等)</li><li>日志: 从ec2实例,cloudTrail等源中获取日志</li><li>服务配额监控</li></ul></li><li><p>CloudTrail</p><p>记录存储aws账户中api调用的历史(console,SDKs,awscli等),相当于记录aws上所有操作</p></li><li><p>AWS CLI</p><ul><li>登录<ol><li><p>直接登录账号</p><p>access key id and secret access key</p></li><li><p>通过AssumeRole</p></li></ol></li></ul></li></ul><ol><li><p>假如我需要创建一个VPC,terraform上需要定义哪些资源</p><p>首先是<code>VPC本身</code>,要计划好ip range,然后<code>公有子网</code>,<code>私有子网</code>,如果要出外网,公有子网要创个<code>internet gateway</code>,私有子网一般用<code>nat gateway</code>,创了gateway还要创建<code>路由表</code>,如果VPC内资源要访问S3或者dynamoDB就要创建个<code>网关端口</code>,有了endpoint还要有<code>endpoint policy</code>,有需要的话给子网创个<code>NACL</code>.</p></li><li><p>AWS上做过的项目描述</p><ol><li>建立private link允许别的aws账号下的vpc访问自己vpc下confluent<ol><li>通过lambda 获取confluent实例ip,写到ELB</li></ol></li><li>lambda自动rotate secret for RDS<ol><li>创建lambda通过eventbridge定时触发secret manager 去rotate secret</li></ol></li></ol></li><li><p>限制了EC2的外网访问,却无法阻止DNS查询</p><ul><li>DNS包含TCP和UDP的53端口,可能漏了个协议</li><li>VPC的DHCP选项中提供了一个默认DNS(通常是VPC范围的DNS)</li><li>VPC有与其他VPC有连接(private link,peering link,transit gateway等)</li><li>主要是NACL和安全组的问题,另外私有子网通过nat网关访问互联网,nat网关上也是设置阻止DNS访问</li></ul></li></ol><ul><li><p>SQS</p><ul><li><p>可见性超时</p><p>队列有多个消费者时,消息发送到A消费者消费,在一定时间内,其他消费者对此消息不可见.这就是可见性超时,用来避免消息的重复消费.</p></li><li><p>死信队列</p><p>消息多次消费失败,可以把它发送到一个特定的队列,用于日后问题排查,这个队列就叫死信队列</p></li><li><p>标准队列</p><ul><li>无限吞吐</li><li>不保证消息顺序</li><li>偶发消息重传</li></ul></li><li><p>FIFO队列</p><ul><li>有序传递</li><li>每条消息在给定时间内只会被传递一次</li><li>吞吐有限,最高300条&#x2F;s或者按批次发送,最高3000条&#x2F;批</li><li>支持消息去重</li></ul></li></ul></li><li><p>dynamoDB</p><p>完全托管的noSQL数据库,对标mongodb,提供最终一致性读取和强一致性读取</p><ul><li>TTL: 和mongodb一样,可以对index设置TTL,TTL超时就删除数据,适用于大量小项目持续吞吐的场景</li><li>全局表: 一种具有多个AWS区域复制功能的dynamoDB特性.将两个或多个dynamoDB表,将其连接起来作为全局表的一部分,每个区域的表都视为一个副本,dynamoDB负载数据的复制同步.<ul><li>多活: 所有区域的表都是活的,可以随时读写</li><li>实时: 基于流技术,在几秒或更短的时间内将更新应用到全球所有复制区域</li><li>冲突处理: 使用last-write-win(最后写入胜出)策略</li><li>跨区域一致性: 在几秒内实现跨区域的最终一致性(同一时刻所有区域看到完全一致的数据)</li></ul></li></ul></li></ul><h1 id="Terraform"><a href="#Terraform" class="headerlink" title="Terraform"></a>Terraform</h1><ol><li><p>terraform语法怎么写</p><p>terrafrom使用的HCL声明式语言,以块的形式组织代码,通过大括号来划分块,常用的块有:</p><ul><li>local{}: 定义本地变量</li><li>resource{}: 定义资源</li><li>data{}: 用于数据查询或计算</li><li>module{}: 引用模块</li><li>ouput{}: 输出数据</li></ul></li><li><p>terrafrom原理</p><p>我们平时所用的terraform,其实是包含两个进程,一个是terraform自身,还有一个就是provider.对应不同的平台有不同的provider,也可以理解成插件或者SDK.terraform主进程主要负责理解并翻译我们写的terraform代码,把它转化成provider可以理解的形式,然后provider负责调用对应平台的API最终实现资源的管理.当我们执行terraform init的时候,terraform会下载所需要的provider,并且会根据配置连接backend,获取statefile,statefile记录这通过terraform管理的平台上的资源的最新状态,通过跟statefile和我们的代码进行对比,terraform plan得出这次我们要对哪些资源做哪些操作,然后通过terraform apply应用变更.</p></li><li><p>如果不用任何第三方backend,如何存储和管理terraform的statefile</p><p>terraform支持pgdb作为后端,同时它也支持通过restful-API请求来与backend交互,意味着我们可以写一个http服务器作为backend.</p></li><li><p>terraform的锁机制</p><p>terraform的状态锁是用来避免并发时发生资源抢占问题的机制,它确保同一时间内只有一个terraform进程可以修改状态文件.当运行一个terrafrom命令时,它会生成一个锁文件并获取它,执行过程中其他terraform进程因为无法获取到这个锁文件所以无法执行.</p></li><li><p>terraform的backend配置写错了,会发生什么?</p><p>backend写错了,会连不上backend,terraform默认会把statefile写在本地,修改好backend后,再次尝试连接,会发现还是连不上backend,terraform根据本地的statefile发现backend配置更改过了,它会尝试连接之前的backend并迁移到新的backend,但之前的backend本身就是错的,所以还是连不上.解决办法就是把本地的statefile移除即可.</p></li><li><p>terraform statefile如何迁移</p><p>比如已经在本地init并apply,terraform会在本地生成statefile.然后修改新的backend配置再次init.terrafrom会检测到backend改变了,它会先确认新backend中有没有状态文件,没有的话就自动迁移状态文件,用户需要手动确定.</p><p>如果检测到新backend已有了状态文件,它会把新旧statefile选在到本地的一个临时目录,然后要求用户人工核对后决定是否覆盖既有的statefile.</p></li><li><p>terraform常用命令</p><p>init&#x2F;plan&#x2F;apply&#x2F;destory&#x2F;fmt&#x2F;validate&#x2F;import&#x2F;froce-unlock&#x2F;output</p></li><li><p>terrafrom工作目录常用文件</p><p>backend.tf&#x2F;provider.tf&#x2F;version.tf: backend配置&#x2F;provider配置和版本信息&#x2F;terraform版本要求</p><p>main.tf&#x2F;data.tf&#x2F;outputs.tf: terraform资源定义代码&#x2F;查询数据data块代码&#x2F;输出代码</p><p>variables.tf: 定义变量代码</p></li><li><p>statefile的安全性</p><ul><li>使用第三方backend,比如S3</li><li>ACL</li><li>加密statefile</li><li>使用版本控制</li></ul></li><li><p>module的管理</p><ul><li>所有module存放在同一个repo里面</li><li>module单独的repo存放管理</li><li><code>source</code>引用官方module</li></ul></li><li><p>你如何管理你的状态文件和锁文件?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs hcl">terraform &#123;<br>  required_version = &quot;&gt;= 0.12&quot;<br><br>  backend &quot;s3&quot; &#123;<br>    bucket         = &quot;my-terraform-state-bucket&quot;<br>    key            = &quot;path/to/my/terraform.tfstate&quot;<br>    region         = &quot;us-west-2&quot;<br>    dynamodb_table = &quot;my-terraform-lock-table&quot;<br>    encrypt        = true<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>状态文件存在S3,启用版本控制,锁文件存在dynamodb是推荐的配置.锁文件推荐存放在数据库,这是因为:</p><ul><li>S3提供的是<code>最终一致性</code>,也就是说对象更新后,s3不保证可以立即列出最新的文件版本.但锁文件的读取必须保证每次都是最新的,所以s3并不是最优解</li><li>高并发场景下,数据库可以提供原子操作(要么完成,要么完全不发生)和事务性(一系列操作都作为一个整体来执行,要么所有操作都成功完成要么遇到错误时撤销所有操作,一个事务包括一系列的原子操作),确保并发写入的一致性和隔离性,s3并没有相关的优化</li><li>在S3中,如果多个进程同时对对象操作,会产生竞争条件,这可能会导致锁的并发控制失败.</li></ul></li><li><p>terrafrom执行错误(有人通过console修改了资源,没有通过terraform,状态文件上的状态就跟平台上的状态不一致,此时执行terraform就会报错),如何修正?</p><p>如果是云平台上有的但是statefile没有的,可以通过terraform import,把资源import进去.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform import ADDRESS ID<br></code></pre></td></tr></table></figure><p>ADDRESS: terraform代码中配置的地址,比如aws_instance.my_instance</p><p>ID: AWS资源实例在云平台上的ID(通过console&#x2F;SDK&#x2F;CLI获取)</p></li><li><p>针对不同环境,terraform代码应该如何管理?</p><p>一般是根据环境划分,比如dev对应dev分支,master对应生产环境</p></li><li><p>如何规划管理terraform模块</p><p>一般都是根据完整功能来划分,比如我做过的rotate secret,里面包括secret manager, lambda和event bridge等,就全写到同一个模块里面.但是长久以往,特别是你这一份terraform要负责管理的team多的时候,很容易出现代码重复的问题.这时可以通过将常用的基础模块独立出来,比如vpc,安全组等单独一个模块,然后要组件别的infra的时候就用source引用,模块设计的时候也要注意,根据实际多设一些变量或默认值,让你的基础模块有更大的灵活性和可用性.另外其实一般公有云都有写好的基础模块,比如aws,gcp都有对应的vpc模块在github上,可以直接引用.</p></li><li><p>我terraform代码模块的路径改变了,如何让statefile也随之更新,为什么要更新?</p><p>terrafrom的状态文件主要包含三个状态信息:</p><ol><li>资源当前状态</li><li>配置中定义的期望状态</li><li>上面二者之间的映射</li></ol><p>当terraform配置的路径和结构与statefile不一致时,会丢失资源的跟踪.比如你把module.a移动到了module.b,apply时terraform会更根据现有的statefile去寻找资源,这些资源仍然关联着旧的路径(module.a),此时terraform会认为无法找到module.b这个资源,而尝试重新创建它. 因此路径变更如果未及时反映到状态文件中,会导致terraform状态与实际云环境的状态不一致,plan和apply可能会提出错误的改动计划,可能会导致资源无意中的破坏或重复创建.另外状态文件不更新也会导致依赖关系混论.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新状态文件的方法主要靠terraform state子命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">address: module.&lt;模块名&gt;.&lt;资源类型&gt;.&lt;资源名称&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">module路径改动</span><br>terraform state mv module.old_module.resource_name module.new_module.resource_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在terraform管理中移除资源但不实际销毁它</span><br>terraform state rm &lt;address&gt; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出当前terraform状态文件中所有资源</span><br>terraform state list<br>terraform state show &lt;address&gt;<br></code></pre></td></tr></table></figure></li><li><p>terraform我在module.a中定义了一个output或data块,我如何在module.b中引用它,但不创建module.a的资源?</p><p>首先定义module.a的output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hcl"># module.a/outputs.tf<br>output &quot;example_output&quot; &#123;<br>  value = aws_instance.example.id<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用module.a的output要先声明,然后才能引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl"># 主 Terraform 配置<br>module &quot;a&quot; &#123;<br>  source = &quot;./path/to/module.a&quot;<br>  # module.a 的其他输入变量...<br>&#125;<br>module &quot;b&quot; &#123;<br>  source = &quot;./path/to/module.b&quot;<br>  input_variable = module.a.example_output<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只用到module.a的output而不创建module.a的资源,可以通过<code>有条件创建</code>来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hcl"># module.a 中的资源<br>resource &quot;aws_instance&quot; &quot;example&quot; &#123;<br>  count = var.create_instance ? 1 : 0<br>  # 其他配置...<br>&#125;<br></code></pre></td></tr></table></figure><p>不过output一般都依赖于资源,所以大部分情况下是跨模块引用data的值.要做到这一点,需要先在module.a中定义data块,然后通过output块公开你的data查询的值,再使用上面的方式来实现.更优雅的做法是,定义个<code>专门用于数据查询的模块</code>,里面不写任何resource,只写data,查询出来的值如果要在别的地方引用就通过output公开,然后通过上面的方式引用.</p></li></ol><h1 id="Jenkinsfile"><a href="#Jenkinsfile" class="headerlink" title="Jenkinsfile"></a>Jenkinsfile</h1><ol><li><p>Jenkinsfile具体语法怎么写</p><p>我一般使用声明式来写,首先是<code>pipeline</code>,如果有需要的话通过<code>agent</code>指定执行pipeline的jenkins节点,<code>parameter</code>定义参数,<code>environment</code>定义环境变量,然后就是<code>stages</code>和<code>stage</code>定义pipeline的各个阶段,每个stage中通过<code>steps</code>块来定义具体要做的动作,有时候pipeline的场景比较复杂,我会通过<code>script</code>块来写groovy,加一些判断,循环或者错误检测.最后通过<code>post</code>做一些收尾操作,比如clean work dir之类的.</p><p>另外我还写过一些功能块,比如<code>trigger</code>配合cron,定时运行pipeline;通过<code>when</code>来有条件地执行某些stage.还有<code>environment</code>可以定义在<code>stage</code>内,只在该stage内生效.</p></li><li><p>jenkins的凭证如何分级</p><p>凭证的管理分两个维度,一个叫<code>范围</code>,一个叫<code>域</code></p><p>范围有:</p><ol><li>全局: 所有项目可用,除非在域中做了限制</li><li>系统: 只允许jenkins自身以及它的节点使用</li><li>用户: 只能该用户使用</li><li>folder: 只有该folder下的项目可以使用</li></ol><p>域: 是一个对凭证<code>逻辑分组</code>的机制,比如说我们可以创建一个域,该域下的凭证只有在访问某个域名的时候才能使用.凭证默认创建在全局域下,全局域没有任何限制.</p></li><li><p>jenkinsfile如何处理并发</p><p>通过<code>parallel</code>关键字声明并发任务,下面的task1和task2会并发执行,通过<code>执行器</code>来实现,所以执行器数量决定了并发任务的数量.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent any<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;Parallel Stage&#x27;</span>) &#123;<br>            steps &#123;<br>                script &#123;<br>                    parallel(<br>                        <span class="hljs-symbol">failFast:</span> <span class="hljs-literal">false</span>, <span class="hljs-comment">// true: 其中一个任务执行失败,其他任务也会停止执行</span><br>                        <span class="hljs-symbol">task1:</span> &#123;<br>                            <span class="hljs-comment">// Task 1 steps</span><br>                            echo <span class="hljs-string">&#x27;Running task 1&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-symbol">task2:</span> &#123;<br>                            <span class="hljs-comment">// Task 2 steps</span><br>                            echo <span class="hljs-string">&#x27;Running task 2&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-comment">// Add more tasks if needed</span><br>                    )<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>jenkinsfile中三个单引号引用的代码和3个双引号引用的代码有什么区别?</p><p>3个引号都是用来引用多行字符串,单引号不会解析特殊字符,比如shell的变量引用$,双引号会解析.</p></li></ol><h1 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h1><ol><li><p>ansible语法怎么写</p><p>主机清单用INI,playbook和role用yaml和jinja2模板</p><p>常见的flag有:</p><p>name: playbook的名字</p><p>host: 远程主机名或组名</p><p>become: 是否要提升权限</p><p>become_method: 提升权限的方式,一般是sudo</p><p>remote_user: 登录到远程主机的的账号</p><p>vars: playbook定义的变量</p><p>tasks: 任务列表,每个任务都有单独的name,具体task里面的操作都是通过模块来实现,比如ping,yum,service,shell,command等等</p><p>notify和handler: 触发器和响应器,比如说一个task修改配置文件,在这个task里面定义notify,配置文件修改成功,就触发handler去重启服务</p><p>tags: 在任务中定义,用来单独执行某个task或跳过某个task</p></li><li><p>ansible的role是什么?如何编写?</p><p>role是一种组织playbook的方式,也是一种代码复用的方式.它通过一个目录结构来组织,比如:</p><p>task文件夹下写task列表</p><p>vars文件夹下定义变量</p><p>files文件夹放需要传输的文件</p><p>template文件夹放jinja2模板</p></li><li><p>ansible的变量</p><ul><li>内部变量,比如:<ul><li>: 主机清单中定义的主机的信息(主机名/ip等),以及主机清单中定义的变量和fact收集的主机的信息,字典</li><li>: 主机变量中组变量字典</li><li>: 当前远端主机的fact收集的信息字典</li><li>: 当前playbook所有主机列表</li></ul></li><li>fact: 在task中通过setup模块获取到的远端主机的系统信息</li><li>role的vars文件夹中定义的变量</li><li>主机清单中定义的变量</li></ul></li></ol><h1 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h1><ol><li><p>K8S由哪些组件构成,每个组件的功能是什么。</p><p>控制面板:</p><ul><li>apiserver: 集群API入口,也负责集群其他组件的交互,集群的大脑,也负责验证授权等</li><li>controller-manager: 管理控制器,管理deployment,statefulset,daemonset这些控制器的,另外service的clusterIP是虚拟IP,其实也是controller-manager负责分配的</li><li>scheduler: 调度器,根据算法计算pod分配到哪个node</li><li>core-dns: 提供集群内的DNS服务</li><li>etcd: k-v存储数据库,存储集群的所有配置数据</li></ul><p>工作平面:</p><ul><li>kubelet: 负责节点上的pod的生命周期管理</li><li>kube-proxy: 维护ipvs&#x2F;iptables规则,service实际上就是通过这些规则转发</li></ul></li><li><p>daemonset,deployment和statefulset的区别是什么?</p><ul><li>daemonset用来保证pod在<code>每一个节点上都运行一个</code>,一般用来运行日志收集,监控,存储等应用</li><li>deployment用来部署<code>无状态的应用</code>,并且支持声明式更新,可以实现滚动更新和回滚</li><li>statefulset用来部署<code>有状态应用</code>,它会给每个副本分配<code>稳定且唯一的网络标识和持久存储</code>,它的部署,扩展,回滚,终止以及滚动更新都是<code>有序</code>的</li></ul></li><li><p>有无写过yaml文件，里面一般有什么参数和变量</p><ul><li><p>apiVersion: 不同的资源不同的k8s版本都会有点不一样</p></li><li><p>kind: 定义资源类型</p></li><li><p>metadata: 资源的元数据,包括namespace和资源name</p></li><li><p>label: 资源的标签</p></li><li><p>spec: 定义对资源的期望状态,不同的资源有不同的参数定义,</p><p>比如deployment要定义replicas(副本数),selector(标签选择器),template(pod模板)</p><p>比如service要定义service-type,默认是clusterIP,ports和targetPort</p></li><li><p>configmap: 配置文件</p></li><li><p>secret: 敏感数据</p></li><li><p>PV和PVC: 定义持久存储</p><ul><li>accessMode: readWriteOnce&#x2F;readWriteMany&#x2F;readOnlyMany</li><li>storageClassName: 指定使用哪个存储类</li></ul></li></ul></li><li><p>有无用过探针，有几种类型，yaml文件怎么写</p><ul><li>启动探针(startup):用来判断容器内应用是否已经启动完成,只有这个探针成功了,才会开始应用后面两个探针,失败了就杀死容器然后重启</li><li>存活探针(liveness): 用来判断容器是否正在运行,检测失败就会杀死容器并重启</li><li>就绪探针(readiness): 用来判断容器是否可以接受流量,检测失败,service就不会转发流量给它</li></ul><blockquote><p>三个探针都有http get&#x2F;tcp socket&#x2F;exec的探测方式</p></blockquote><p>重启策略:</p><ul><li>Always: 不论容器返回状态码是什么,都会尝试重启容器</li><li>Onfailure: 容器返回状态码非0(非正常退出),就重启</li><li>Never: 不论容器返回状态码是什么,不论探针检测结果是什么都不会重启</li></ul><blockquote><p>一个pod内的容器共享生命周期,所以容器重启也代表pod重启.</p></blockquote><p>参数:</p><ul><li>exec<ul><li>command</li></ul></li><li>httpGet<ul><li>path</li><li>port</li><li>host</li><li>scheme: http&#x2F;https</li><li>httpHeaders</li></ul></li><li>tcpsocket:<ul><li>port</li><li>host</li></ul></li><li>initialDelaySeconds: 容器启动后多久执行第一次探测</li><li>periodSeconds: 执行探针的频率</li><li>timeoutSeconds: 超时时间</li><li>successThreshold: 成功多少次才判断成功</li><li>failureThreshold: 失败多少次才判断失败</li></ul></li><li><p>有无听过节点亲和性，具体怎么实现</p><p>节点亲和性基于nodeSelector和节点标签实现,它有两种类型,一种叫required(硬亲和),一种叫perfer(软亲和).硬亲和就是pod只能调度到匹配规则的节点上,没有就不调度,软亲和则是优先把pod调度到符合规则的节点,没有匹配的就调度到其他节点.软亲和何以设定多个并根据权重设置优先级.</p><p>它通过几个操作符来匹配:</p><ul><li>In&#x2F;NotIn: 节点必须具有&#x2F;没有指定的标签(key)和值(value)</li><li>key只能指定一个,value可以指定<code>一个列表</code>,只要节点标签的值在列表中有&#x2F;没有就算符合</li><li>Exists&#x2F;DoesNotExist: 节点必须有&#x2F;没有指定的标签(key)</li><li>Gt&#x2F;Lt: 节点标签的值必须大于&#x2F;小于指定值</li></ul><p>通过关键字<code>affinity</code>下的<code>nodeaffinity</code>定义</p></li><li><p>有无听过水平扩容和垂直扩容，具体怎么实现</p><p>水平扩容就是(<code>HPA</code>),基于metrics-server获取的实时资源使用数据来实现,比如我设置HPA的值是cpu平均利用率80%,那么K8S就会尽量将它保持在80%.利用率大于80%就扩容,小于80%就缩容.但是为了避免频繁地扩缩容,左右横跳,HPA提供一些参数和机制,比如扩缩容后有<code>冷却时间</code>,计算触发值的时候会把<code>平均值</code>也纳入计算,以及还有一个<code>稳定窗口</code>的概念(触发值超过设定值一定时间后才会触发扩缩容)</p><p>垂直扩容(<code>VPA</code>)同样也是基于metrics-server的数据来实现.它不是通过加副本来加强性能,而是通过调节pod的cpu和内存来加强性能.VPA适用于不能随便扩展副本数来加强负载的应用,比如数据库.但是VPA有个地方需要注意,它是有可能导致pod直接重启,生产环境应该选择<code>Off</code>或者<code>Initial</code>模式</p></li><li><p>有无听过动态扩容，具体怎么实现，动态扩容应用在什么地方（pod还是节点）</p><p>Cluster AutoScaler,使用一个特定的容器实现(k8s.gcr.io&#x2F;cluster-autoscaler),它会通过k8s的API获取它所需要的信息,比如集群的资源使用情况,有多少个pod处于pending状态等,然后调用对应底层平台的API,比如AWS的GCP的或者私有云的openstack的,来实现节点的按需扩缩容</p></li><li><p>如何升级k8s集群</p><p>使用kubeadm部署的集群也是通过kubeadm来升级.首先通过<code>kubeadm upgrade plan</code>来验证升级计划,然后通过<code>kubeadm upgrade apply</code>来应用升级,kubeadm主要负责控制平面组件的升级,一般生产环境中master都会部署高可用,所以需要一个个节点来.至于工作平面的组件,先要通过<code>cordon</code>命令禁止pod的调度,然后通过<code>drain</code>命令驱逐节点上的pod,然后再升级节点的kubelet,升级完通过<code>uncordon</code>来恢复调度,也是要一个个节点来.</p><p>生产环境一般采用滚动更新的方式,先创建一个新版本的新节点,然后加入到集群,再驱逐旧版本的一个节点并把它从集群中剔除.</p></li><li><p>secret如何增加安全性?</p><p>集群内组件的通信都要配上TLS,保证传输过程加密</p><p>etcd数据加密</p><p>配置RBAC和network policy对secret进行访问控制</p><p>可以使用第三方来存储secret,比如AWS的secret manager</p><p>禁止hardcode,包括日志中</p></li><li><p>pod创建过程</p><ul><li>用户提交创建pod的请求给API-server</li><li>apiserver会将相关信息写入etcd,写入完成就返回确认信息给客户端</li><li>apiserver会反映etcd中的状态变化,所有k8s组件都会通过watch机制来跟踪检查api server上的变动</li><li>比如scheduler通过watch机制觉擦到apiserver创建了一个pod但未绑定到任何节点,它就会使用调度算法为这个pod计算节点,并更新到apiserver</li><li>apiserver会把调度结果写入etcd</li><li>被调度到的节点上的kubelet会在本地抵用容器运行时(CRT)运行容器,并将容器状态同步给apiserver</li><li>apiserver更新写入到etcd,写入完成,apiserver通知kubelet完成.</li></ul></li><li><p>K8s中的跨节点通讯</p><ul><li><p>flannel有两种模式,默认是VxLan,类似VPN,在两个pod之间建立一条虚拟的隧道,使用VxLan封装,因为需要额外的封装,所以开销大性能弱</p><p>另一个是host-gw,它会在每个节点上维护一个静态的路由表,根据路由表进行流量转发,它要求每个节点都有一个单独的子网</p></li><li><p>calico的原理跟flannel的host-gw类似,也是维护路由表,但是它使用动态路由协议BGP,所以它不需要为每个节点单独分配一个子网</p></li></ul></li><li><p>k8s的资源限制</p><ul><li>ResourceQuota: 限制名称空间内<code>所有资源总量限制</code>,包括pod&#x2F;service&#x2F;pvc等数量,也包括cpu&#x2F;内存的总量</li><li>LimitRange: 限制namspace内<code>单个pod或container</code>层面上的资源分配</li></ul></li><li><p>写一份NetworkPolicy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-network-policy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># 策略所在的名称空间,也是策略生效的名称空间</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span> <span class="hljs-comment"># 策略应用的具体pod</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">db</span><br>  <span class="hljs-attr">policyTypes:</span> <span class="hljs-comment"># 表示该策略是应用到哪个方向的流量</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Egress</span><br>  <span class="hljs-attr">ingress:</span> <span class="hljs-comment"># 入流量白名单</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/16</span><br>        <span class="hljs-attr">except:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">172.17</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">project:</span> <span class="hljs-string">myproject</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 这是允许被连接到的端口,也就是入方向流量可以连接到的端口</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>  <span class="hljs-attr">egress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">5978</span><br></code></pre></td></tr></table></figure></li><li><p>etcd如何备份还原</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">etcdctl snapshot save/restore<br></code></pre></td></tr></table></figure></li><li><p>如何写helm,如何管理helm包</p><blockquote><ul><li>helm v3后直接通过kubeconfig连接apiserver</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">wordpress/<br>├── charts # 这个目录用于存放本 Helm chart 依赖的其他 chart。如果你的应用程序依赖于其他服务（如数据库、缓存等），对应的 chart 应该放在这个目录下。默认情况下，此文件夹为空。<br>├── Chart.yaml # 这个文件包含了 chart 的基本信息，如版权、版本、名称和描述。这是 chart 的元数据文件和身份信息<br>├── templates # 这个目录包含定义 Kubernetes 资源的模板文件。Helm 会结合 `values.yaml` 中的值和这些模板来生成 Kubernetes 资源定义文件。<br>│   ├── deployment.yaml # 定义了用于创建和管理应用程序基础 Pod 的 Deployment 资源。<br>│   ├── _helpers.tpl # 包含模板帮助信息和定义模板函数，可以在其他模板文件中重用。<br>│   ├── hpa.yaml # 如果启用，定义 Horizontal Pod Autoscaler，根据 CPU 使用率或其他选择的指标自动缩放 Deployment。<br>│   ├── ingress.yaml # 定义 Ingress 资源，用于管理外部访问到你的应用程序的 HTTP/HTTPS 路由。<br>│   ├── NOTES.txt # 包含安装后的使用说明，当执行 `helm install` 命令后，这些信息会显示给用户。<br>│   ├── serviceaccount.yaml # 创建 ServiceAccount，以便为 pod 提供身份认证。<br>│   ├── service.yaml # 定义 Service 资源，用于定义如何访问和暴露你的应用程序。<br>│   └── tests # 包含测试资源<br>│       └── test-connection.yaml # 定义了一个后置测试，用于验证应用程序是否可以正常连接。<br>└── values.yaml # 包含默认的配置值，这些值在结合 templates/ 中的模板时使用。用户可以自定义这些值来覆盖默认设置<br></code></pre></td></tr></table></figure><ol><li>使用<code>helm create &lt;name&gt;</code>创建helm包(chart)</li><li>编辑<code>Chart.yaml</code>写chart包的元信息(版本信息,作者,描述等)</li><li>写<code>templates</code>目录下的k8s资源模板(deployment.yaml,hpa.yaml等)</li><li>写<code>values.yaml</code>定义变量和默认值</li><li><code>files</code>目录下放一些模板中引用的文件(脚本或配置文件)</li><li>使用<code>helm install &lt;release_name&gt; &lt;path_to_chart&gt;</code>安装测试chart</li></ol><p>常用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm create &lt;name&gt;<br>helm install &lt;release_name&gt; &lt;path_to_chart&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打包成.tgz方便存储或分发</span><br>helm package &lt;path_to_chart&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加仓库</span><br>helm add &lt;repo_name&gt; &lt;repo_url&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级</span><br>helm upgrade &lt;release_name&gt; &lt;repo_name&gt;/&lt;chart_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本控制/回滚</span><br>helm rollback &lt;release_name&gt; &lt;revision&gt;<br></code></pre></td></tr></table></figure></li></ol><h2 id="EFK"><a href="#EFK" class="headerlink" title="EFK"></a>EFK</h2><ol><li><p>有无用过ELK，具体搭建过环境</p><p>部署过EFK,<code>headless service代理statefulset 3节点 es集群</code>,使用<code>daemonset部署fluentd</code>,监听的是宿主机的容器日志目录<code>/var/log/containers</code></p><p>使用fliter的<code>concat</code>插件实现多行信息拼接,使用filter的<code>grep</code>插件只采集特定标签的pod的日志</p></li><li><p>ES index的生命周期管理(ILM)</p><p>热&#x2F;温&#x2F;冷&#x2F;删除,一般是根据数据的读写频率以及物理磁盘的性能分层存放,不过我做过的就只是热+删除,实现过了一定时间就删除日志数据的功能</p></li><li><p>ES索引如何备份</p><p>使用es的快照与恢复功能: 支持各种快照仓库(S3,HDFS,本地文件系统等)</p><ul><li><p>配置快照仓库</p><p>elasticsearch.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">path.repo:</span> [<span class="hljs-string">&quot;/mount/backups/my_backup&quot;</span>]<br></code></pre></td></tr></table></figure></li><li><p>注册快照仓库</p><p>PUT &#x2F;_snapshot&#x2F;my_backup_repository&lt;自定义仓库名称&gt;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fs&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/mount/backups/my_backup&quot;</span><br> <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>创建快照</p><p>PUT &#x2F;_snapshot&#x2F;my_backup_repository&#x2F;my_snapshot&lt;自定义快照名称&gt;</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;indices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;log_index&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ignore_unavailable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include_global_state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>恢复快照</p><p>POST &#x2F;_snapshot&#x2F;my_backup_repository&#x2F;my_snapshot&#x2F;_restore</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;indices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;log_index&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;ignore_unavailable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;include_global_state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><ol><li><p>有无用过普罗米修斯等监控工具，知不知道普罗米修斯的语法怎那么写</p><p>部署过prometheus 联邦集群监控超过500台混合云环境的虚拟机,和一个k8s集群.它的查询语法叫promQL,基本语法就是metric-name{lables:value},查询支持pattern匹配,另外prometheus自带很多聚合函数,比如max(),avg()等等</p></li><li><p>如何用prometheus监控k8s集群</p><p>部署kube-state-metrics,通过这个容器获取metrics,另外api-server,control-manager,secheduler,core-dns等组件都有原生的metrics API,可以通过在prometheus中直接配置获取metrics.</p></li></ol><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol><li><p>有无写过dockerfile，语法是什么，公司的项目组用到什么镜像</p><p>FROM: docker的镜像是层级结构的,所以每次build镜像都要有一个最底层的基础镜像,from用来指定这个基础镜像</p><p>ADD: 复制文件到镜像中</p><p>COPY: 也是复制文件,不过它支持tar包和URL,tar包还可以自动展开</p><p>RUN: 在镜像<code>build</code>的过程中执行的命令</p><p>CMD: 定义镜像运行时要执行的命令,不过一般是用来给entrypoint传参用</p><p>ENTRYPOINT: 定义镜像的父进程</p></li></ol><h2 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h2><ol><li><p>helm架构?</p><p>V3后的helm,取消了中间件tiller,直接通过kubeconfig连接集群</p></li><li><p>helm动态环境支持</p><p>value.yaml配置变量,template定义模板来实现对不同环境的支持</p></li><li><p>helm不验证登录,如何获取镜像</p><p>如果是私有仓库,可以通过管理员配置允许匿名访问,另外可以提前在k8s集群中配好secret,然后在helm chart中定义imagePullSecret就可以免密获取镜像</p></li></ol><h1 id="Python运维脚本"><a href="#Python运维脚本" class="headerlink" title="Python运维脚本"></a>Python运维脚本</h1><ol><li><p>有无经常用python写运维脚本</p><p>曾经用python开发了一个prometheus的exporter基于它的官方SDK,也二开了一个alertmanager的webhook实现自定义告警</p></li><li><p>python创建一个父类,假如我不希望继承这个父类的子类使用父类中的某个变量,我可以怎么做?</p><p><code>__</code>双下划线定义私有变量</p></li><li><p>python中有哪些数据类型?</p></li><li><p>深浅拷贝的区别?</p></li><li><p>装饰器是做什么用的?</p></li><li><p>单元测试</p></li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="基本编程算法"><a href="#基本编程算法" class="headerlink" title="基本编程算法"></a>基本编程算法</h2><ol><li><p>排序算法</p><p>快速排序</p><p>归并排序</p><p>冒泡</p></li><li><p>搜索算法</p><p>二分查找</p></li></ol><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ol><li>轮询</li><li>最少连接</li><li>哈希</li><li>随机</li></ol><h2 id="故障诊断和恢复"><a href="#故障诊断和恢复" class="headerlink" title="故障诊断和恢复"></a>故障诊断和恢复</h2><ol><li><p>冗余</p><p>raid 0</p><p>raid 5</p></li><li><p>备份</p><p>全量</p><p>增量</p><p>差异备份</p><p>快照</p></li></ol><h2 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h2><ol><li>二分法</li><li>动态规划&#x2F;贪心算法</li></ol><h2 id="网络算法"><a href="#网络算法" class="headerlink" title="网络算法"></a>网络算法</h2><p>最短路径</p><p>流控制(滑动窗口协议)</p><h2 id="数据一致性和同步"><a href="#数据一致性和同步" class="headerlink" title="数据一致性和同步"></a>数据一致性和同步</h2><p>一致性哈希算法</p><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ol><li>AES</li><li>RSA(非对称加密): 安全管理密钥</li></ol><h2 id="版本控制算法"><a href="#版本控制算法" class="headerlink" title="版本控制算法"></a>版本控制算法</h2><ol><li>合并算法(三向合并)</li></ol><h2 id="系统设计算法"><a href="#系统设计算法" class="headerlink" title="系统设计算法"></a>系统设计算法</h2><ol><li>队列(kafka,rabbitMQ,rocketMQ)</li></ol><h2 id="监控和日志分析"><a href="#监控和日志分析" class="headerlink" title="监控和日志分析"></a>监控和日志分析</h2><ol><li>正则表达式</li></ol><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ol><li><p>OSI7层模型</p><p>应用层: 用户交互和数据最终处理</p><p>表示层: 数据的编码和解码,给应用层翻译数据</p><p>会话层: 应用之间的会话管理</p><p>传输层: TPC&#x2F;UDP协议</p><p>网络层: IP协议</p><p>数据链路层: mac地址寻址,arp协议</p><p>物理层: 物理链路</p></li><li><p>TCP&#x2F;IP4层模型</p><p>应用层: http&#x2F;https&#x2F;smtp&#x2F;ftp等</p><p>传输层: TCP&#x2F;UDP</p><p>网络层: IP协议</p><p>数据链路层: 网络硬件</p></li><li><p>TCP协议</p><p>面向连接: 数据传输之前需要先建立连接(<code>3次握手</code>)</p><p>可靠传输: 使用序列号和ack响应来保证数据的<code>顺序和可靠</code>,在特定时间没有收到ack就会<code>重传</code></p><p>数据流: 数据以<code>无结构的字节流</code>发送</p><p>流量控制: <code>滑动窗口协议</code>避免快发送方淹没慢接受方</p><p>拥塞控制: 算法(慢启动,拥塞避免,快速重传和快速恢复)</p><p>错误检测: tcp头包含一个<code>校验和字段</code>,用于 检测数据在传输过程中的错误</p></li><li><p>TCP3次握手4次挥手</p><p>3次握手:</p><ol><li>客户端发起SYN包给服务端</li><li>服务端收到后回一个SYN+ACK</li><li>客户端收到服务端的ACK后再回一个ACK,握手完成,连接建立</li></ol><p>4次挥手</p><ol><li>客户端发一个FIN包,申请断开连接</li><li>服务端返回一个ACK,表示收到请求</li><li>服务端没有数据发了,再发一个FIN包,表示它也可以断开连接了</li><li>客户端返回一个ACK,并等待2MSL时间,正式断开连接</li></ol></li><li><p>HTTP协议</p><ol><li><p>通过TCP3次握手建立连接</p></li><li><p>发送http请求(请求方法,请求资源URI,请求头等)</p></li><li><p>服务器响应请求(状态码,响应头和响应体等)</p></li><li><p>响应完成tcp4次挥手断开连接</p><blockquote><p>http是无状态协议,跟踪对话需要用cookie,session机制</p></blockquote></li></ol></li><li><p>HTTPS协议</p><p>握手阶段(非对称加密)</p><ol><li>客户端发起一个https请求,附带客户端支持TLS版本,加密方式等</li><li>服务端根据客户端支持的TLS版本,加密方式等发服务端的<code>https证书</code>和服务端的<code>公钥</code>给客户端</li><li>客户端验证证书是否可以信任(公信力CA),并随机生成一个<code>对称密钥</code>,用服务端的公钥加密后发送给服务端</li><li>服务端使用<code>私钥解密</code>对称密钥,至此握手完成</li></ol><p>通信阶段(对称加密)</p><p>双方通过<code>对称密钥</code>加解密通信</p></li></ol><h1 id="DEVOPS和CI-CD理念"><a href="#DEVOPS和CI-CD理念" class="headerlink" title="DEVOPS和CI&#x2F;CD理念"></a>DEVOPS和CI&#x2F;CD理念</h1><ol><li><p>如何理解CICD?</p><p>CI是持续集成,是一种开发实践,每次代码合并后都自动运行测试和其他验证过程就是CI</p><p>CD是持续部署,是CI的延申,实现自动化的构建,测试和部署</p><p>CI&#x2F;CD的一般流程就是代码提交合并触发CI过程,运行自动化测试(比如用sonarQ检查代码质量,漏洞等),测试通过就开始编译,打包,然后触发CD过程,自动部署到一个或多个非生产环境进行测试,测试都通过了没问题,就可以计划部署到生产环境</p></li><li><p>如何理解敏捷开发?</p><p>与敏捷开发模型(Agile Development Model)相对是的瀑布流模型(Waterfall Model).</p><p>敏捷开发模型:</p><pre><code class="hljs">- 强调灵活,变更成本低,迭代增量式开发,适合需求不明确</code></pre><p>瀑布流模型:</p><ul><li>严格遵从阶段顺序线性开发,变更成本高,需求需要明确</li></ul></li><li><p>git工作流</p><p>适合敏捷开发模型的git工作有两个Git Flow 和 GitHub Flow.</p><p>Git Flow:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">- main #(稳定分支) 永远保存可部署的稳定版本,通常用tag标记具体版本号,用来记录版本发布历史,每次合并代表一个正式版本<br>- develop #(主开发分支) 所有开发在develop分支执行,develop不会直接合并到main<br>- feature/* #(特性分支) 新功能从develop创建feature分支,功能完成后合并回develop分支<br>- release/* #(发布分支) 发布时从develop创建release分支,发布完成合并到develop和main<br>- hotfix/* #(紧急修复分支) 从main分支创建hotfix分支,修复生产环境紧急bug,完成后合并到develop和main<br></code></pre></td></tr></table></figure><p>GitHub Flow:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">- main #(生产分支)<br>- feature/* #(特性分支)<br></code></pre></td></tr></table></figure></li><li><p>devops排查问题的思路?</p><ul><li>收集信息</li><li>复现问题</li><li>寻找根因</li><li>制定解决方案</li><li>测试验证</li><li>分析记录</li></ul></li><li><p>遇到网络流量异常,如何排查问题?</p><p>在上面的基础上有些特定的操作:</p><ul><li>分析流量制造者,确定它的行为模式和停止它们的方法</li><li>分析网络路径: 通过traceroute,ping,dig,tcpdump等工具捉包分析</li><li>检查负载均衡器: 是否负责策略有问题</li></ul></li><li><p>常见监控指标?</p><ol><li>服务器运行状态: cpu&#x2F;mem&#x2F;disk&#x2F;network</li><li>app状态: 运行状态&#x2F;响应时间&#x2F;错误率&#x2F;日志&#x2F;异常</li><li>服务性能: 网络延迟&#x2F;http响应时间&#x2F;db响应时间&#x2F;缓存命中</li><li>安全性: 入侵检测&#x2F;访问控制&#x2F;DDos攻击</li><li>日志系统</li><li>资源使用情况: 带宽&#x2F;虚拟机状态&#x2F;存储&#x2F;硬件状态</li></ol></li><li><p>说说你运维生涯遇到印象最深的一个问题.</p><blockquote><p>我曾经遇到过一个端口复用的问题,当时我们部署的是一个IM应用,现象是A用户本该发送给B用户的消息,结果发送给了C用户.后来查出的问题就是因为用户太多,连接数不够,出现了端口复用.</p><p>当时其实查得挺困难的,因为一开始没有这个概念,日志只是一条条地输出,很难看得出来.后面开了debug level日志,发现发错的信息所用的连接的本地ip和端口与正常发送的消息所用的ip和端口是一样的.</p><p>这才想到MSL的问题.因为我们的IM使用的是TCP长连接,当时的架构在前端有一个nginx作为负载,所以可以理解为所有连接都是同样的源ip和目标ip,当用户数一多,新用户不停登录,</p><p>默认的4次挥手的等待时间,也就是2*MSL不够用,其中一方数据没有传输完端口就被用到另一个用户,就导致了消息发送的错乱.当时给出的解决方案是加节点,但是加节点涉及资源申请,要走流程;当然也许可以手动</p><p>调大每个包的MSL,不过也会有风险,每个连接断开的等待时间变长,新用户登录建立新连接的时间可能也会拉长.最终与客户沟通,决定这个问题作为当前版本的一个bug处理,等下个版本发版顺便加节点.</p></blockquote></li><li><p>如何理解DEVOPS?</p><p>根据google SRE这本书所说,DEVOPS源自google,最开始google的运维也想我们传统运维一样,手动敲命令,手动重启,日常繁琐的工作很多,后面就有了脚本可以做一些简单的自动化.但是还不够,毕竟脚本还是面向过程的嘛,你很难说一个脚本覆盖多个场景.所以就引入了开发的能力,通过开发将运维的工作实现自动化,并适配多种场景.这最开始</p></li><li><p>做过的CI&#x2F;CD流程?</p><p>gcp项目</p><p>新旧方案示意图:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240506120957837.png" srcset="/img/loading.gif" lazyload alt="image-20240506120957837"></p><p>上面是旧方案,下面是新方案.旧方案的master分支基本是没用的,每次用release都要根据现有的dev分支复制一个release专用的分支出来,然后通过ansible拉取,model也是类似,每次做release,就把对应版本的model上传到gcs,然后ansible去拉取.为了区分版本,那就要加版本号啦,所以每次做release都要手动去改ansible代码指定拉取那个版本,就比较麻烦.</p><blockquote><p>新方案会根据dev(测试审批通过后)打一个tag,到做release的时候就通过python脚本将tag自动PR并merge到master分支(PR主要是为了审计),ansible那边就固定拉取master分支的代码即可.而github上tag的页面也可以清晰看到一个版本列表(用于版本追踪&#x2F;回滚).model也是类似,不过在我进去之前他们已经定好了先把model存在nexus,做release的时候通过jenkins把model上传到gcs,然后ansible拉取部署.nexus是别的团队管理的,我们没有删除文件的权限,时间久了会有模型文件堆积的问题,所以我们也有在讨论要不是把nexus换了,比如换到github,把model各个版本存在github之类的方案.</p></blockquote><blockquote><p>旧方案主要的问题是master分支浪费了,而且分支会很多,一个release一个分支,每次都要改ansible(包括回滚),容易会人为错误的风险(墨菲定律).新方案用上了master分支,通过tag list有清晰的版本列表,ansible固定拉取master分支,不需要每次都手工修改.</p></blockquote></li><li><p>github管理代码,版本分支如何规划?</p></li><li><p>我们devops主要是管理terraform&#x2F;ansible&#x2F;Jenkinsfile的代码,都是根据环境来划分分支</p></li><li><p>业务代码一般是根据版本,也有根据环境来划分</p></li></ol><p>   一般主分支都是用于生产环境</p><blockquote><p>gcp的项目中,是按环境划分分支,最开始当需要release的时候,会根据dev分支单独创建一个release用的分支,部署的时候就部署这个分支.后面则是通过jenkins做的CICD,先是根据审批后的dev代码版本打一个tag,release的时候就把这个tag merge到主分支,生产环境就只使用主分支</p></blockquote><h1 id="架构概念"><a href="#架构概念" class="headerlink" title="架构概念"></a>架构概念</h1><ol><li><p>CAP理论</p><p>一个分布式计算系统不可能同时满足以下三个保证:</p><ul><li>一致性: 系统中所有数据副本,在同一时间内都是一致的.任何对数据的读取请求都将返回最新的写操作结果</li><li>可用性: 所有请求都会收到一个响应(但不保证返回的数据是最新的)</li><li>分区容忍性: 系统可以在任何网络分区(系统的一部分在网络中不可访问)发生时继续运行</li></ul><p>任何给定时刻,只能同时满足以上两个保证.</p><p>在现实世界设计中,分区容忍性是必须要有的(因为网络失败是难以避免的),所以设计的关键就在一致性和可用性之间做出权衡.</p></li><li><p>写时复制</p><p>copy on write:</p><ol><li>当系统需要复制一个资源(文件,对象或内存页)时,不会立即创建一个完全独立的副本,而是新旧副本共享相同的实际数据(降低内存占用)</li><li>当其中一个副本需要修改时,系统才会创建一个真正的副本(即写入数据之前先进行复制)</li><li>在新的副本修改后,其他副本仍然指向原始数据</li><li>修改不会影响原始数据或其他副本,保证数据的完整性和隔离性</li></ol></li></ol><h1 id="GIT-1"><a href="#GIT-1" class="headerlink" title="GIT"></a>GIT</h1><ol><li><p>团队维护同一份github repo,你们是工作流是怎么样的?</p><p>一般采用类似Feature Branch Workflow的流程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;repo_url&gt;<br>git checkout -b &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在分支上开发</span><br>git add .<br>git commit -m &quot;Commit message&quot;<br>git push -u origin &lt;new_branch_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此时会在repo上创建一个PR,团队成员对代码进行审查(code review),通过后merge到master分支</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后删除本地和远程的开发分支</span><br>git branch -d feature_branch_name  # 删除本地分支<br>git push origin --delete feature_branch_name  # 删除远程分支<br></code></pre></td></tr></table></figure><p>这是基本的工作流程,期间还可以加入其他步骤,例如代码静态分析(snoarQ),自动化测试,CI&#x2F;CD等</p></li><li><p>git常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">always pull before push</span><br>git pull<br>git push<br><span class="hljs-meta prompt_"># </span><span class="language-bash">display current status of git repository</span><br>git status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">display git commit <span class="hljs-built_in">history</span></span><br>git log<br>git log --oneline<br>git log --oneline --graph --decorate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">show the difference between 2 commits</span><br>git diff &lt;commitID1&gt; &lt;commitID2&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">撤销本地更改(未commit)</span><br>git reset --hard HEAD~<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AWS-SAP-MustKnow</title>
    <link href="/2024/03/20/AWS-SAP/"/>
    <url>/2024/03/20/AWS-SAP/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/90" srcset="/img/loading.gif" lazyload></p><h1 id="服务类型总结"><a href="#服务类型总结" class="headerlink" title="服务类型总结"></a>服务类型总结</h1><h2 id="计算（Compute）"><a href="#计算（Compute）" class="headerlink" title="计算（Compute）:"></a>计算（Compute）:</h2><h3 id="Amazon-EC2（Elastic-Compute-Cloud）"><a href="#Amazon-EC2（Elastic-Compute-Cloud）" class="headerlink" title="Amazon EC2（Elastic Compute Cloud）"></a>Amazon EC2（Elastic Compute Cloud）</h3><ul><li>spot: 使用aws上未被使用的计算资源,<code>随时可能被终止</code>,适用于批处理,科学计算等,价格按供需变化</li><li>预留: <code>预定</code>计算资源(一般是1年或3年),折扣比按需大</li><li>按需: <code>按小时或秒</code>收费</li><li>节省计划: 在一定时间内(一般是一年或三年)使用一定量的计算资源,<code>换取</code>比按需更低的价格</li><li>集群放置组: 在单可用区内将ec2实例紧密分组在一起,实现相互间的低延迟和高吞吐</li><li>分区放置组: 将EC2实例分布在一个region的多个分区中(不同机架或不同服务器).实现故障隔离</li><li>T3: 通用</li><li>R5: 内存优化</li></ul><blockquote><p>可以将ec2绑定一个iam角色,但不能绑定用户</p></blockquote><ul><li>实例存储卷: nvme SSD最大30TB,比EBSI&#x2F;O更高,速度最快</li><li>Auto Scaling<ul><li>简单扩展策略: 根据<code>单一</code>的云监控指标动态扩缩容,执行扩展后会有一个<code>冷却期</code></li><li>目标跟踪策略: 设置一个<code>目标值</code>(比如cpu40%),auto scaling会自动调整EC2实例的数量来<code>维持</code>这个目标值,没有冷却期</li><li>计划扩展策略: 根据<code>预知</code>的负载变化来预先安排扩展,比如指定未来某个时间点增加或减少实例数量</li></ul></li></ul><h3 id="AWS-Lambda（无服务器计算）"><a href="#AWS-Lambda（无服务器计算）" class="headerlink" title="AWS Lambda（无服务器计算）"></a>AWS Lambda（无服务器计算）</h3><ul><li>程序运行要在15mins内</li><li>128MB-10GB</li><li>成本计算:<ul><li>请求计费: 每月免费头100w次请求</li><li>执行时间: 与内存成正比,每月400000GB-秒免费<ul><li>GB-秒:一秒时间内使用1GB内存,比如分配了1GB内存,一个月就有免费400,000s</li></ul></li></ul></li></ul><h3 id="Amazon-ECS（Elastic-Container-Service，容器管理"><a href="#Amazon-ECS（Elastic-Container-Service，容器管理" class="headerlink" title="Amazon ECS（Elastic Container Service，容器管理)"></a>Amazon ECS（Elastic Container Service，容器管理)</h3><p>容器管理服务,是容器的运行和管理环境</p><ul><li>ec2 launch type</li><li>fargate launch type</li></ul><p>任务: 一个或多个容器的组合,是运行容器的基本单位,有点类似k8s的pod</p><p>任务定义: 以json格式描述容器运行的所有设置(比如镜像,端口,卷挂载,cpu内存等),类似dockerfile或k8s yaml,任务定义有版本的概念,用于部署更新或滚动更新</p><h3 id="AWS-batch"><a href="#AWS-batch" class="headerlink" title="AWS batch"></a>AWS batch</h3><p>建立在ECS之上的全托管批处理服务,一般用lambda去触发</p><h3 id="Amazon-EKS（Elastic-Kubernetes-Service，Kubernetes-管理）"><a href="#Amazon-EKS（Elastic-Kubernetes-Service，Kubernetes-管理）" class="headerlink" title="Amazon EKS（Elastic Kubernetes Service，Kubernetes 管理）"></a>Amazon EKS（Elastic Kubernetes Service，Kubernetes 管理）</h3><p>托管型k8s服务,管理k8s控制平面的高可用,扩展和安全</p><ul><li>ec2 launch type</li><li>fargate launch type</li></ul><h3 id="AWS-Fargate（容器无服务器计算）"><a href="#AWS-Fargate（容器无服务器计算）" class="headerlink" title="AWS Fargate（容器无服务器计算）"></a>AWS Fargate（容器无服务器计算）</h3><p>无服务计算引擎,结合ecs或eks,提供一种方式来执行容器,无需用户关心基础实例的运行和维护</p><h2 id="存储（Storage）"><a href="#存储（Storage）" class="headerlink" title="存储（Storage）"></a>存储（Storage）</h2><h3 id="Amazon-S3（Simple-Storage-Service，简单存储服务）"><a href="#Amazon-S3（Simple-Storage-Service，简单存储服务）" class="headerlink" title="Amazon S3（Simple Storage Service，简单存储服务）"></a>Amazon S3（Simple Storage Service，简单存储服务）</h3><ul><li><p>版本控制:</p><ol><li>当对像被覆盖或删除操作时,旧版本不会被永久删除,而是保留下来,在需要的时候可以恢复</li><li>上传的每个对象都会被分配一个唯一的版本ID</li><li>如果你上传一个跟已存在对象同名的文件,旧文件不会被覆盖,新文件会获得一个唯一的版本ID</li><li>检索开启版本控制的对象,要指定其版本ID,不指定就返回最新</li><li>删除开启版本控制的对象,只会逻辑删除;指定删除对象的特定版本,特定版本就会删除;指定删除对象的所有版本,对象才会被永久删除</li><li>开启版本控制后的存储桶才能设置<code>生命周期策略</code>,例如自动删除一定时间后的旧版本</li></ol></li><li><p>MFA delete: 多因素删除,提供两种身份认证才能删除对象</p></li><li><p>类型</p><ul><li><p>standard: 默认</p></li><li><p>IA: 非频繁访问</p></li><li><p>Glacier: 更低的访问频率,不能直接下载(至少90天才能)</p><ul><li>Glacier Deep: 读取延迟12-48小时</li></ul></li><li><p>Intelligent-tiering: 根据访问频率自动归类,免费功能</p></li></ul></li><li><p>SSE-S3(Server-Side Encryption with Amazon S3-Managed Keys)</p><ul><li>服务器端S3加密密钥,S3自动管理</li><li>每个对象都有唯一的密钥并使用一个主密钥加固</li></ul></li><li><p>SSE-KMS(Server-Side Encryption with AWS Key Management Service)</p><ul><li>使用KMS中的密钥来对s3对象进行加密</li><li>KMS提供密钥审计,访问控制和rotate等功能</li></ul></li><li><p>object-lock</p><ul><li>治理模式: 大多数用户不能修改对象,但可以授权某些用户可以修改对象</li><li>和规模式: 任何用户(包括根用户)在对象保护期限之前都不能修改或删除对象</li></ul></li><li><p>跨区复制(桶间复制): S3存储桶是全局资源,但是也有分区域,区域定义了存储桶的物理存储位置,该功能允许你自动,异步地复制对象到另一个不同aws区域的桶中</p></li><li><p>lake formation: 简化通过aws构建,保护和管理数据湖的过程.允许存储所有结构化和非结构化数据的大规模存储看.可以与S3无缝集成,可以运行不同类型的分析</p></li><li><p>macie: 利用机器学习和模式匹配,发现和保护敏感数据,专门用来识别和分类s3中敏感内容</p></li><li><p>Transfer Acceleration: 利用cloudfront优化全球文件传输,先传到最近的边缘节点,然后利用aws内部网络传输文件到目标s3</p></li></ul><blockquote><p>访问控制:</p><ol><li>存储桶策略: json格式,用于授权账户对s3资源的访问.可以控制整个桶或桶内特定对象</li><li>ACLs: 管理aws账户或预定义群组对存储桶和对象的读写权限(粒度比存储桶策略粗)</li><li>IAM: 授权IAM用户,组或角色对s3资源的访问权限</li></ol><p>以上三者是”逻辑与”的关系</p><ol start="4"><li>预签名URL: 安全地分享对象,不需要设置对象为公开访问,用户不具有账户凭据的情况下也能访问,可以设定有效期</li><li>跨资源共享(CORS): 默认情况下一个网站脚本无法访问另一个网站的内容,此功能允许你在不同域名之间的前端应用程序请求S3资源</li></ol></blockquote><h3 id="Amazon-EBS（Elastic-Block-Store，弹性块存储"><a href="#Amazon-EBS（Elastic-Block-Store，弹性块存储" class="headerlink" title="Amazon EBS（Elastic Block Store，弹性块存储)"></a>Amazon EBS（Elastic Block Store，弹性块存储)</h3><p>块存储服务,作为<code>单个</code>ec2实例的持久存储来使用</p><ul><li>快速快照恢复功能: 从EBS卷的快照中创建一个新的EBS卷</li><li>类型:<ul><li>通用型SSD<ul><li>gp2: 通用型ssd,1GB&#x2F;s的吞吐,16000 IOPS</li><li>gp3: gp2的升级版,用户可以独立选择和调整IOPS和吞吐量</li></ul></li><li>预配置IOPS SSD<ul><li>io1: 满足延迟敏感型高性能I&#x2F;O密集型应用,比如大型关系型数据库或noSql数据库</li><li>io2: io1的升级,更高的持久性和IOPS效率</li></ul></li><li>io2 block express</li><li>容量优化HDD(st1): 面向吞吐量的HDD卷,适用于频繁访问,大数据量的工作负载(数据仓库,日志处理和数据湖),高吞吐,低于SSD的成本但IOPS较低</li><li>冷HDD(sc1): 低成本磁盘卷</li></ul></li></ul><h3 id="Amazon-Glacier（长期数据归档）"><a href="#Amazon-Glacier（长期数据归档）" class="headerlink" title="Amazon Glacier（长期数据归档）"></a>Amazon Glacier（长期数据归档）</h3><h3 id="Amazon-EFS（Elastic-File-System，弹性文件系统）"><a href="#Amazon-EFS（Elastic-File-System，弹性文件系统）" class="headerlink" title="Amazon EFS（Elastic File System，弹性文件系统）"></a>Amazon EFS（Elastic File System，弹性文件系统）</h3><h3 id="Amazon-FSx-for-windows-server-专门为windows提供的存储服务-支持SMB"><a href="#Amazon-FSx-for-windows-server-专门为windows提供的存储服务-支持SMB" class="headerlink" title="Amazon FSx for windows server: 专门为windows提供的存储服务,支持SMB"></a>Amazon FSx for windows server: 专门为windows提供的存储服务,支持SMB</h3><h3 id="Amazon-FSx-for-Lustre-为高性能计算提供存储-例如机器学习-视频处理和金融建模等"><a href="#Amazon-FSx-for-Lustre-为高性能计算提供存储-例如机器学习-视频处理和金融建模等" class="headerlink" title="Amazon FSx for Lustre: 为高性能计算提供存储,例如机器学习,视频处理和金融建模等"></a>Amazon FSx for Lustre: 为高性能计算提供存储,例如机器学习,视频处理和金融建模等</h3><ul><li>可以与S3集成,将S3对象呈现为文件并讲改写的数据写回S3</li></ul><h2 id="数据库（Database）"><a href="#数据库（Database）" class="headerlink" title="数据库（Database）"></a>数据库（Database）</h2><h3 id="Amazon-RDS（Relational-Database-Service，关系型数据库服务）"><a href="#Amazon-RDS（Relational-Database-Service，关系型数据库服务）" class="headerlink" title="Amazon RDS（Relational Database Service，关系型数据库服务）"></a>Amazon RDS（Relational Database Service，关系型数据库服务）</h3><p>管理型数据库服务平台,用来管理关系型数据库,支持各种引擎(aurora,postgreSQL,mysql, mariabd,oracle,sql server)</p><ul><li>全局表: 允许你跨多个区域复制多主数据库实例,支持一主多从复制,确保多个区域之间的低延迟同步</li><li>只读副本创建:<ol><li>先让源数据库执行完长时间事务</li><li>必须设置备份保留期不等于0,在源实例上启动自动备份</li></ol></li><li>Aurora auto scaling只会缩放只读副本</li><li>时间点恢复(PITR): 将数据库恢复到过去特定的日期和时间,依赖<code>RDS自动备份功能</code> .备份保留期最少可达35天,你可以使用这个功能将数据库数据恢复到最多35天前的<code>任意时间点</code>(最少粒度为1分钟)</li></ul><blockquote><p>rds for mysql&#x2F;oracle&#x2F;…: 标准的数据库引擎</p><p>rds for custom mysql&#x2F;oracle&#x2F;…: 允许系统访问操作,自己维护自己打补丁</p><p>aurora mysql: 高性能,适用于持续,可预测负载的应用程序</p><p>aurora serverless: 按需自动启动和关闭,按需完全自动扩缩容(v2版)</p></blockquote><h3 id="Amazon-DynamoDB（NoSQL-数据库服务）"><a href="#Amazon-DynamoDB（NoSQL-数据库服务）" class="headerlink" title="Amazon DynamoDB（NoSQL 数据库服务）"></a>Amazon DynamoDB（NoSQL 数据库服务）</h3><ul><li>dynamoDB-DAX:</li></ul><p>​为dynamoDB设计的缓存服务,旨在dynamodb提高性能</p><ul><li>dynamoDB-stream</li></ul><p>​捕获任何DynamoDB表中按时间顺序排列的条目级修改,并在日志中存储这些信息,最长可达24小时.意味着我们可以获取一个DynamoDB说有操作的流数据,通过这个流数据我们可以用来触发各种响应,比如同步到另一个数据库或者简单地用于审计</p><ul><li><p>TTL</p><p>为表中的每一项定义一个过期时间,过期则删除数据(非即时,有一定延时)</p></li></ul><h3 id="Amazon-Redshift（数据仓库服务）-使用sql和现有的商业智能工具做数据分析"><a href="#Amazon-Redshift（数据仓库服务）-使用sql和现有的商业智能工具做数据分析" class="headerlink" title="Amazon Redshift（数据仓库服务）: 使用sql和现有的商业智能工具做数据分析"></a>Amazon Redshift（数据仓库服务）: 使用sql和现有的商业智能工具做数据分析</h3><h3 id="AWS-Aurora（数据库引擎）"><a href="#AWS-Aurora（数据库引擎）" class="headerlink" title="AWS Aurora（数据库引擎）"></a>AWS Aurora（数据库引擎）</h3><h3 id="Amazon-Neptune（图数据库）"><a href="#Amazon-Neptune（图数据库）" class="headerlink" title="Amazon Neptune（图数据库）"></a>Amazon Neptune（图数据库）</h3><h3 id="AWS-RDS-proxy"><a href="#AWS-RDS-proxy" class="headerlink" title="AWS RDS proxy"></a>AWS RDS proxy</h3><p>数据库代理服务,解决数据库连接限制和过多连接数的问题,保持应用程序连接的同时自动连接到备用数据库实例</p><h3 id="AWS-Database-Migration-Service-DMS"><a href="#AWS-Database-Migration-Service-DMS" class="headerlink" title="AWS Database Migration Service (DMS)"></a>AWS Database Migration Service (DMS)</h3><p>帮助用户将关系数据库,数据仓库,NOSQL等数据迁移到AWS</p><ul><li>CDC(数据变更捕获): 这个功能允许DMS捕捉到源数据库在迁移过程中发生的数据变化,并实时地将这些变化应用到目标数据库上</li></ul><h2 id="移动服务（Mobile-Services）"><a href="#移动服务（Mobile-Services）" class="headerlink" title="移动服务（Mobile Services）:"></a>移动服务（Mobile Services）:</h2><h3 id="AWS-Amplify（快速构建移动应用程序和网页应用程序）"><a href="#AWS-Amplify（快速构建移动应用程序和网页应用程序）" class="headerlink" title="AWS Amplify（快速构建移动应用程序和网页应用程序）"></a>AWS Amplify（快速构建移动应用程序和网页应用程序）</h3><h3 id="Amazon-API-Gateway（创建、发布、维护-API）"><a href="#Amazon-API-Gateway（创建、发布、维护-API）" class="headerlink" title="Amazon API Gateway（创建、发布、维护 API）"></a>Amazon API Gateway（创建、发布、维护 API）</h3><p>充当HTTP和WebSocket API的门户,允许前端应用程序以编程方式访问后端服务</p><h3 id="AWS-AppSync（管理数据同步与应用状态）"><a href="#AWS-AppSync（管理数据同步与应用状态）" class="headerlink" title="AWS AppSync（管理数据同步与应用状态）"></a>AWS AppSync（管理数据同步与应用状态）</h3><h2 id="数据分析（Analytics）"><a href="#数据分析（Analytics）" class="headerlink" title="数据分析（Analytics）:"></a>数据分析（Analytics）:</h2><ul><li>Amazon EMR（Elastic MapReduce，处理大规模数据）</li><li>AWS Glue（托管 ETL 服务）: 提取,转换和加载服务用于准备和加载数据,自动发现和分类数据,用户数据分析前的准备工作<ul><li>作业书签: 避免重复处理旧数据</li><li>数据目录: 核心组件,存储你数据的元数据,有助于自动数据的转换和加载功能.</li><li>爬虫(crawler): 自动探测你环境中的数据目录(s3,rds或redshift等),读取数据推断数据模式,创建数据表的定义,存储在数据目录中(表名,列名数据类型等),模式使用它自带的分类器实现,也可以<code>自定义分类器</code>实现自定义的推断.</li></ul></li><li>Amazon Athena（SQL 查询服务）: <code>针对s3实时执行sql查询</code>,但是可使用的资源是S3分配的,所以在高峰时候使用会慢</li><li>Amazon QuickSight（商业智能服务): 主要用来做<code>数据可视化</code></li></ul><h2 id="安全性、身份和合规性（Security-Identity-Compliance）"><a href="#安全性、身份和合规性（Security-Identity-Compliance）" class="headerlink" title="安全性、身份和合规性（Security, Identity &amp; Compliance）"></a>安全性、身份和合规性（Security, Identity &amp; Compliance）</h2><h3 id="AWS-IAM（Identity-and-Access-Management，身份及访问管理"><a href="#AWS-IAM（Identity-and-Access-Management，身份及访问管理" class="headerlink" title="AWS IAM（Identity and Access Management，身份及访问管理)"></a>AWS IAM（Identity and Access Management，身份及访问管理)</h3><ul><li>账户<ul><li>根账户: 每个aws账户的创建者和拥有者</li><li>管理账户(主账户): 主要用于统一管理和控制</li><li>用户账户: 日常运营和资源分配的基本单位</li></ul></li><li>TaskRoleARN: ECS任务关联的IAM角色的ARN.这个角色赋予ECS任务中的容器所需权限,这样他们就可以访问其他AWS服务.</li><li>API密钥: 用户使用AWS-CLI,SDKs或直接HTTP API调用时,通过API密钥,进行安全的访问和操作,无需硬编码账户名和密码.</li><li>access analyzer: 可以与cloudtrail集成,分析其中日志,自动得出账户所需的最少权限</li></ul><h3 id="AWS-Shield（DDoS-防护）"><a href="#AWS-Shield（DDoS-防护）" class="headerlink" title="AWS Shield（DDoS 防护）"></a>AWS Shield（DDoS 防护）</h3><p>免费,默认保护所有使用R53和cloudfront的资源</p><h3 id="Amazon-Cognito（用户身份管理）"><a href="#Amazon-Cognito（用户身份管理）" class="headerlink" title="Amazon Cognito（用户身份管理）"></a>Amazon Cognito（用户身份管理）</h3><p>客户身份和访问管理服务(CIAM),帮助企业简化用户身份验证,授权,用户池创建和管理.允许你让用户通过社交身份提供商(facebook,X,google等),SAML2.0标识提供商或者自有的身份系统进行登录.</p><ul><li>用户池: 创建你自己的用户目录,使用户可以注册登录并验证</li><li>身份池: 授权用户访问其他AWS服务</li></ul><h3 id="AWS-WAF（Web-Application-Firewall，网络应用防火墙）"><a href="#AWS-WAF（Web-Application-Firewall，网络应用防火墙）" class="headerlink" title="AWS  WAF（Web Application Firewall，网络应用防火墙）"></a>AWS  WAF（Web Application Firewall，网络应用防火墙）</h3><p>应用层防火墙,避免sql注入,跨脚本攻击等,还可以限制特定国家&#x2F;地区访问</p><p>规则操作:</p><pre><code class="hljs">1. count: 只计数,不做任何操作,计数用于监控,一般在测试的时候很有用1. block: 允许请求1. allow: 拦截请求</code></pre><h3 id="AWS-GuardDuty"><a href="#AWS-GuardDuty" class="headerlink" title="AWS GuardDuty"></a>AWS GuardDuty</h3><p>AWS提供的威胁检测服务,通过分析处理各种数据(比如CloudTrail事件,VPC流日志)来检测恶意活动和异常行为.</p><h3 id="Firewall-manager"><a href="#Firewall-manager" class="headerlink" title="Firewall manager"></a>Firewall manager</h3><p>中央管理工具,统一管理多个aws账户&#x2F;区域中的资源中部署的WAF规则, shield 保护规则以及其他aws防火墙规则</p><h2 id="网络和内容交付（Networking-Content-Delivery）"><a href="#网络和内容交付（Networking-Content-Delivery）" class="headerlink" title="网络和内容交付（Networking &amp; Content Delivery）"></a>网络和内容交付（Networking &amp; Content Delivery）</h2><h3 id="Amazon-VPC（Virtual-Private-Cloud，虚拟私有云）"><a href="#Amazon-VPC（Virtual-Private-Cloud，虚拟私有云）" class="headerlink" title="Amazon VPC（Virtual Private Cloud，虚拟私有云）"></a>Amazon VPC（Virtual Private Cloud，虚拟私有云）</h3><ul><li><p>peering link(对等连接): 连接两个vpc(不通过公共互联网传输),两个vpc都要添加路由,双向,网络对网络</p></li><li><p>private link(也叫vpc endpoint service): 在你的vpc中通过私有的网络路径安全地访问aws服务或vpc终端节点(不通过公共互联网传输),单向,一对一,比如允许别的vpc访问自己vpc下的某一服务端点</p><ul><li>VPC endpoint:<ul><li>接口端点: 实际上是在vpc内创建一个与特定AWS服务相关联的弹性网络接口(ENI),不需要修改vpc路由表</li><li>网关端点: 支持s3和dynamoDB,将vpc中针对这两个服务的流量(优化)路由到目标,需要在路由表中添加一个指向该端点的路由</li></ul></li></ul></li><li><p>NACLs</p><ul><li>默认拒绝所有</li><li>无状态</li><li>作用在子网,一个NACL可以关联多个子网,但一个子网只能关联一个NACL</li><li>按顺序评估规则,第一个匹配的规则生效</li><li>支持黑白名单</li></ul></li><li><p>AWS Network Firewall (网络防火墙): 支持有状态和无状态规则,web过滤,入侵检测和防御,弹性可扩展,监控进出vpc流量(通常用于补充NACLs的功能)</p></li><li><p>安全组: 虚拟防火墙,控制实例之间的出入流量</p><ul><li>默认允许所有<code>出</code>禁止所有<code>入</code></li><li>有状态</li><li>作用在实例级别.安全组和实例是多对多的关系.</li><li>所有规则同时生效(只有有允许该流量的规则,流量就会被放行)</li><li>白名单</li><li>支持前缀列表: 用于管理多个CIDR块的资源,可用于安全组中,包括aws管理的&#x2F;用户自定义的,例如cloudfront(com.amazonaws.global.cloudfront)</li></ul></li><li><p>VPC endpoint policy: 资源策略,用于管理和控制到VPC Endpoint服务的访问,附加到vpc endpoint上控制哪些aws主体可以使用该端点来访问服务.</p></li><li><p>公有子网: 公有子网的实例可以直接通过<code>互联网网关</code>连接到互联网</p></li><li><p>私有子网: 私有子网的实例不能直接访问互联网,通常通过<code>nat网关</code>连接互联网</p><blockquote><p>子网不能跨可用区,比如如果要使用跨多个AZs的</p></blockquote></li><li><p>internet gateway: 给公有子网实例连接互联网</p></li><li><p>nat gateway: 运行在公有子网中给私有子网实例连接互联网或其他aws服务,但不能从互联网接受入站连接</p></li></ul><h3 id="Transit-Gateway"><a href="#Transit-Gateway" class="headerlink" title="Transit Gateway"></a>Transit Gateway</h3><p>创建一个中心化的网络枢纽,连接多个不同网络,比如本地网络与多个VPC之间或者多个VPC之间建立连接,这样子就不需要每个VPC之间都创建一个peering link</p><h3 id="AWS-Direct-Connect（专用网络连接）"><a href="#AWS-Direct-Connect（专用网络连接）" class="headerlink" title="AWS Direct Connect（专用网络连接）"></a>AWS Direct Connect（专用网络连接）</h3><h3 id="Amazon-CloudFront（全球内容分发网络）"><a href="#Amazon-CloudFront（全球内容分发网络）" class="headerlink" title="Amazon CloudFront（全球内容分发网络）"></a>Amazon CloudFront（全球内容分发网络）</h3><p><code>http</code> CND功能和安全功能(https, 防Ddos)</p><ul><li>OAI: cloudfront的一个特性,用来限制对S3存储桶的访问,确保使用cloudfront分发的内容仅可以通过cloudfront访问,不能直接通过S3URL访问.</li><li>字段级加密配置: 在内容通过CloudFront分发到原始服务器之前,加密HTTP POST请求中表达字段中的数据.</li></ul><h3 id="AWS-Global-Accelerator（网络加速服务）"><a href="#AWS-Global-Accelerator（网络加速服务）" class="headerlink" title="AWS Global Accelerator（网络加速服务）"></a>AWS Global Accelerator（网络加速服务）</h3><p>针对<code>非http</code>场景的CDN,如游戏UDP,以及用于自我管理的DNS场景</p><h3 id="Route53"><a href="#Route53" class="headerlink" title="Route53"></a>Route53</h3><p>DNS解析;域名注册;健康检查</p><ul><li>主动&#x2F;被动故障转移: 主资源不健康,将自动把流量重定向到预先设置的备用资源</li><li>主动&#x2F;主动故障转移: 多份资源同时服务,某一份不健康,流量会停止转给它,只会转到其余健康的资源中</li><li>简单路由策略: 基础DNS查询,不支持健康检查</li><li>延迟路由策略: 资源部署在多个aws区域,基于网络延迟,向延迟最低的region路由</li><li>多值路由策略: 允许关联多个资源,并进行健康检查,随机选<code>一个</code>健康的资源来响应</li><li>地理位置路由策略: 根据dns查询的发起地理位置来路由</li></ul><p>专用托管区: 在VPC内部管理DNS记录,且这些记录不会被互联网访问得到,与特定账户和特定vpc绑定</p><p>公开托管区: 用于互联网的DNS记录查询.</p><h3 id="ELB"><a href="#ELB" class="headerlink" title="ELB"></a>ELB</h3><ul><li>ALB<ul><li>工作在<code>7层应用层</code>的负载均衡器</li><li>根据URL或HTTP头信息路由</li><li>支持websocket和http&#x2F;2</li><li>集成ECS和EKS</li><li>提供SSL&#x2F;TLS解密功能,直接在负载均衡器上管理https证书</li><li>精细化健康检查和转发规则</li><li>TargetGroup<ul><li>ALB中用来定义负载均衡器转发请求目标.(支持EC2,Lambda,IP地址或ECS中的容器)</li></ul></li></ul></li><li>NLB<ul><li>工作在<code>4层传输层</code>的负载均衡器</li><li>针对TCP流量优化,可以处理不稳定的和突发的流量</li><li>每个NLB都可以使用一个静态ip</li><li>延迟低</li><li>自动识别不健康的实例,并转发流量到健康的</li><li>适用于TCP长连接(websocket)</li><li>每个AZ一个独立端点,确保扩展性和容错性</li></ul></li></ul><h2 id="应用集成（Application-Integration）"><a href="#应用集成（Application-Integration）" class="headerlink" title="应用集成（Application Integration）"></a>应用集成（Application Integration）</h2><h3 id="AWS-Step-Functions（托管状态机服务）"><a href="#AWS-Step-Functions（托管状态机服务）" class="headerlink" title="AWS Step Functions（托管状态机服务）"></a>AWS Step Functions（托管状态机服务）</h3><h3 id="Amazon-SNS（Simple-Notification-Service，简单通知服务）"><a href="#Amazon-SNS（Simple-Notification-Service，简单通知服务）" class="headerlink" title="Amazon SNS（Simple Notification Service，简单通知服务）"></a>Amazon SNS（Simple Notification Service，简单通知服务）</h3><h3 id="Amazon-SQS（Simple-Queue-Service，简单队列服务）"><a href="#Amazon-SQS（Simple-Queue-Service，简单队列服务）" class="headerlink" title="Amazon SQS（Simple Queue Service，简单队列服务）"></a>Amazon SQS（Simple Queue Service，简单队列服务）</h3><ul><li>标准队列: 消息顺序,但有些情况下会乱序,消息至少传递一次(可能会多次处理同一条消息),无限吞吐</li><li>FIFO队列: 严格顺序,确保每条消息仅处理一次,有限吞吐</li><li>死信队列: 当一条消息被n次(可设置)连续接受但没有成功被处理(被删除),这条消息就会认为是<code>死信息</code>,自动发送到死信队列中,用于隔离和分析这些死消息,不影响正常消息处理</li></ul><blockquote><p>消息延迟发送: 消息发送到SQS中也不会被消费者立即看到,知道你设置的延迟时间过了,最多延迟15分钟</p><p>可见性超时: 当一个消息从队列中被检索出来,消息会被标记为<code>正在处理</code>,而再可见性超时期间对其他消费者来说是<code>不可见的</code>.如果消费者在可见性超时时间内成功处理并删除这条消息,就没问题.反之,超过了可见性超时,其他消费者就能看到这条消息并处理他.</p><ul><li>如果消费者因为某些原因无法处理消息,消息不会消失,而是重新进入队列给别的消费者处理</li><li>超时期间,避免多个消费者重复处理消息</li></ul></blockquote><h3 id="AWS-EventBridge（事件总线）"><a href="#AWS-EventBridge（事件总线）" class="headerlink" title="AWS EventBridge（事件总线）"></a>AWS EventBridge（事件总线）</h3><p>无服务器的时间总线,基于事件触发aws服务,api调用等</p><h3 id="AWS-Confluent"><a href="#AWS-Confluent" class="headerlink" title="AWS Confluent"></a>AWS Confluent</h3><p>完全托管的Kafka服务,可以与lambda,S3等aws服务无缝集成</p><h3 id="AWS-SES"><a href="#AWS-SES" class="headerlink" title="AWS SES"></a>AWS SES</h3><p> 基于云的电子邮件服务提供商,可以集成到任何应用程序中</p><h3 id="AWS-ElasticCache"><a href="#AWS-ElasticCache" class="headerlink" title="AWS ElasticCache"></a>AWS ElasticCache</h3><p>完全托管的内存数据缓存服务,兼容redis和memcached</p><h3 id="AWS-connect"><a href="#AWS-connect" class="headerlink" title="AWS connect"></a>AWS connect</h3><p>全渠道云联系中心,支持任何地方的代理,提供客服电话,聊天,交互式语音响应和运营分析功能</p><h3 id="AWS-pinpoint"><a href="#AWS-pinpoint" class="headerlink" title="AWS pinpoint"></a>AWS pinpoint</h3><p>灵活可扩展的市场传播服务,让你通过e-mail,<code>短信</code>,推送通知或语音等方式与顾客保持联系.并提供数据分析功能.</p><h2 id="开发者工具（Developer-Tools）"><a href="#开发者工具（Developer-Tools）" class="headerlink" title="开发者工具（Developer Tools）"></a>开发者工具（Developer Tools）</h2><ul><li>AWS CodeCommit（托管 Git 代码仓库）</li><li>AWS CodePipeline（持续集成和持续交付服务）</li><li>AWS CodeBuild（编译和测试代码）</li><li>AWS CodeDeploy（自动化代码部署）</li></ul><h2 id="物联网（IoT）"><a href="#物联网（IoT）" class="headerlink" title="物联网（IoT）"></a>物联网（IoT）</h2><ul><li>AWS IoT Core（接入和管理 IoT 设备）</li><li>AWS IoT Analytics（物联网分析）</li><li>AWS IoT Device Management（设备管理）</li></ul><h2 id="机器学习（Machine-Learning）"><a href="#机器学习（Machine-Learning）" class="headerlink" title="机器学习（Machine Learning）"></a>机器学习（Machine Learning）</h2><ul><li>Amazon SageMaker（机器学习模型构建、训练和部署）: 为ML设计的工作流编排服务,自动化所有机器学习阶段</li><li>AWS Rekognition（图像和视频分析）: 计算机视觉服务.识别分析图像和视频</li><li>Amazon textract: 机器学习服务,利用光学字符识别(OCR)来自动从扫描的文档中提取文本,手写内容和数据.</li><li>AWS Comprehend（自然语言处理）: 自然语言处理服务(NPL)</li><li>Amazon Transcribe: 自动语音识别服务(ASR)</li><li>Amazon Translate: 神经机器翻译服务</li></ul><h2 id="企业应用程序（Enterprise-Applications）"><a href="#企业应用程序（Enterprise-Applications）" class="headerlink" title="企业应用程序（Enterprise Applications）"></a>企业应用程序（Enterprise Applications）</h2><ul><li>Amazon WorkSpaces（桌面即服务）</li><li>Amazon WorkMail（企业电子邮件和日历服务）</li></ul><h2 id="管理与治理-Management-Governance"><a href="#管理与治理-Management-Governance" class="headerlink" title="管理与治理 (Management &amp; Governance)"></a>管理与治理 (Management &amp; Governance)</h2><h3 id="AWS-cloudformation"><a href="#AWS-cloudformation" class="headerlink" title="AWS cloudformation"></a>AWS cloudformation</h3><p>允许开发人员和系统管理员以编码方式创建和管理AWS资源的集合,使用模板文件定义所需资源.</p><ul><li>堆栈(stack): 根据cloudformation模板定义的资源集合.你的模板定义了需要创建和配置的所有aws资源,以及这些资源之间的依赖关系.当部署一个模板时,cloudformation会跟随模板指令,创建一个资源的集合,也就是堆栈.</li><li>堆栈集(stack set): cloudformation的一个功能,允许你在多个aws账户和区域中自动部署相同的堆栈.<ul><li>跨账户和区域部署</li><li>集中化管理</li><li>自动更新: 更新堆栈集,所有关联的堆栈也会自动更新</li><li>顺序部署: 可以对堆栈集内的堆栈进行顺序部署</li><li>偏移检测: 可以检测堆栈集以及锁管理的各个堆栈中的资源预期cloudformation模板的预期配置之间的差异.资源偏移表示资源的属性已经被外部改动,与模板定义的状态不一致.</li></ul></li></ul><h3 id="AWS-systems-manager"><a href="#AWS-systems-manager" class="headerlink" title="AWS systems manager"></a>AWS systems manager</h3><ul><li>patch manager: 管理系统补丁</li><li>run command: 允许你在aws资源上安全地执行远程命令的功能</li><li>parameter store: 提供一个中央位置管理配置数据,可以包括敏感信息,支持加密,没有rotate功能</li></ul><h3 id="AWS-key-management-service-KMS"><a href="#AWS-key-management-service-KMS" class="headerlink" title="AWS key management service(KMS)"></a>AWS key management service(KMS)</h3><p>创建控制用于加密操作的密钥,可以与其他aws服务结合为数据加解密提供密钥管理和控制</p><h3 id="AWS-secret-manager"><a href="#AWS-secret-manager" class="headerlink" title="AWS secret manager"></a>AWS secret manager</h3><p>专门保护管理敏感信息(用户名密码,密钥等),支持密钥自动rotate,可以使用kms的密钥来加密</p><h3 id="AWS-organizations"><a href="#AWS-organizations" class="headerlink" title="AWS organizations"></a>AWS organizations</h3><p>账户级别管理和政策控制,比如防止vpc访问internet或限制访问某个AZ</p><p>All Features模式: 表示启用 aws organization所有功能,包括SCP,OUs,集中式付款,集中权限管理等</p><p>OUs: 组织单元,对organization下管理的账户进行分组</p><p>SCP: 服务控制策略,定义允许或拒绝在组织中进行哪些操作的策略.类似IAM policy但是它不是用来授权的,而是用来限制组织中的账户或者OUs可以使用的服务和操作.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cloudtrail:DeleteTrail&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//紧急关闭cloudtrail日志记录功能</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="AWS-control-tower"><a href="#AWS-control-tower" class="headerlink" title="AWS control tower"></a>AWS control tower</h3><p>在上者的基础上提供更全面的管理,监控和合规自动化解决方案</p><h3 id="AWS-SSO"><a href="#AWS-SSO" class="headerlink" title="AWS SSO"></a>AWS SSO</h3><p>中心管理身份验证服务,中心化身份管理,集成AWS organizations支持现有的身份源,比如Microsoft AD和LDAP;方便多账户访问</p><h3 id="AWS-directory-service"><a href="#AWS-directory-service" class="headerlink" title="AWS directory service"></a>AWS directory service</h3><p>提供多种方式使用Microsoft AD与其他AWS服务整合的云服务</p><h3 id="Cloud-Trail"><a href="#Cloud-Trail" class="headerlink" title="Cloud Trail"></a>Cloud Trail</h3><p>记录存储aws账户中api调用的历史(console,SDKs,awscli等),相当于记录aws上所有操作</p><h3 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h3><p>监控和管理服务,提供仪表盘,可以发告警,可以直接通过邮箱地址<code>共享仪表盘</code></p><p>默认情况cloudwatch日志无限期保存</p><p>可以监控:</p><ul><li>性能: 实时监控aws资源(ec2实例,rds数据库,s3等)的性能(cpu,流量,IO等)</li><li>日志: 从ec2实例,cloudTrail等源中获取日志</li><li>服务配额监控</li></ul><h3 id="AWS架构转换-Schema-Conversion-Tools-SCT"><a href="#AWS架构转换-Schema-Conversion-Tools-SCT" class="headerlink" title="AWS架构转换(Schema Conversion Tools)(SCT)"></a>AWS架构转换(Schema Conversion Tools)(SCT)</h3><p>将现有的<code>数据库架构</code>从一种数据库引擎转换成另一种,以便<code>迁移到aws</code>,也可以用于<code>转换整个应用程序架构</code></p><h3 id="AWS-Elastic-BeanStalk"><a href="#AWS-Elastic-BeanStalk" class="headerlink" title="AWS Elastic BeanStalk"></a>AWS Elastic BeanStalk</h3><p>开发者只需要上传代码,这个服务就会自动处理代码部署到AWS上,包括服务器的设定,运维系统的配置,网络构建和安全性设置等,自动扩展,支持多种语言,本身免费</p><h3 id="AWS-config"><a href="#AWS-config" class="headerlink" title="AWS config"></a>AWS config</h3><p>评估,审计和评价AWS环境中资源的配置.持续记录和保持账户中AWS资源变化历史,允许你自动评估配置与所需配置之间的对比</p><h3 id="AWS-资源组"><a href="#AWS-资源组" class="headerlink" title="AWS 资源组"></a>AWS 资源组</h3><p>资源组是管理各种aws资源的一种方式,允许你将aws资源组织在一起(比如根据项目,应用程序,环境等关系)</p><ul><li>标签: k-v,可以在aws中创建的几乎任何资源分配标签,根据标签来管理资源</li></ul><h3 id="AWS-Trusted-Advisor"><a href="#AWS-Trusted-Advisor" class="headerlink" title="AWS Trusted Advisor"></a>AWS Trusted Advisor</h3><p>AWS提供的咨询服务,自动检查你的aws资源并提出优化建议(成本,性能,容错)</p><h3 id="Amazon-Inspector"><a href="#Amazon-Inspector" class="headerlink" title="Amazon Inspector"></a>Amazon Inspector</h3><p>自动的安全评估服务(安全漏洞,合规性)</p><h3 id="AWS-step-function"><a href="#AWS-step-function" class="headerlink" title="AWS step function"></a>AWS step function</h3><p>协调多个 AWS 服务成为一个全自动化的工作流程</p><h3 id="成本管理"><a href="#成本管理" class="headerlink" title="成本管理"></a>成本管理</h3><ul><li>AWS budgets: 设定预算监控aws服务的使用情况和成本</li><li>Cost Explorer: 可视化工具,查看分析aws成本和使用情况数据,提供历史和预测功能</li><li>AWS 账单: 控制台特性,提供每月账单详情</li><li>成本控制控制面板: 控制台中集成的综合视图</li><li>成本和使用报告(CUR): 最详细和最全面的AWS成本和使用数据,数据可以提供其他工具分析,比如Athena或Redshift</li></ul><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><ul><li>datasync: <code>在线</code>数据传输服务,<code>简化和加速</code>本地到aws或aws服务之间的数据同步</li><li>snowball: 线下物理传输,pb级别</li><li>snowball edge: 在snowball的基础上加上简单的分析和处理任务功能</li><li>snowmobile: 数十或数百PB,EB级别的数据传输</li><li>transfer acceleration: 通过cloudfront加速用户上传到<code>s3</code>的数据传输速度</li><li>AWS Transfer Family: 安全,简便地传输文件到AWS存储服务.支持<code>FTP,SFTP,FTPS和AS2</code>协议</li><li>AWS Storage Gateway（存储网关&#x2F;文件网关）: 将本地环境与云存储无缝连接起来,支持<code>NFS,SMB</code>协议,允许你将本地文件存储<code>直接连接</code>到S3</li></ul><h2 id="数据流和实时分析"><a href="#数据流和实时分析" class="headerlink" title="数据流和实时分析"></a>数据流和实时分析</h2><ul><li><p>kinesis</p><ul><li>data stream: 快速收集和存储来自多个源的数据流,如股票交易,社交媒体数据或游戏数据</li><li>data firehose: 最简单的方式将实时流数据加载到AWS的数据存储服务(s3, redshift, aws es service等)</li><li>data analytics: 让用户使用sql轻松创建和运行对数据流的实时分析</li><li>video stream: 安全地流式处理视频</li></ul></li><li><p>Amazon AppFlow: 完全托管集成服务,帮助用户在SAAS和AWS服务之间安全传输数据</p></li></ul><h1 id="各种例子"><a href="#各种例子" class="headerlink" title="各种例子"></a>各种例子</h1><h2 id="vpc-endpoint-policy"><a href="#vpc-endpoint-policy" class="headerlink" title="vpc endpoint policy"></a>vpc endpoint policy</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MyPolicyStatement1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//自定义标识符,可以是任何值,可选</span><br>      <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定哪些aws用户,&quot;*&quot;代表所有</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:*&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 指定可以执行的操作</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-comment">// 指定具体资源</span><br>        <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;arn:aws:s3:::example-bucket&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 指定策略使用条件</span><br>        <span class="hljs-attr">&quot;StringEquals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;aws:sourceVpce&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vpce-1a2b3c4d&quot;</span> <span class="hljs-comment">// 指定只有来源是特定vpc才会生效</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="terraform创建vpc"><a href="#terraform创建vpc" class="headerlink" title="terraform创建vpc"></a>terraform创建vpc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs terraform">provider &quot;aws&quot; &#123;<br>  region = &quot;us-west-2&quot;  # 这里设置您希望部署的AWS区域<br>&#125;<br><br>resource &quot;aws_vpc&quot; &quot;main&quot; &#123; # vpc自身<br>  cidr_block = &quot;10.0.0.0/16&quot;<br>  enable_dns_hostnames = true<br>  enable_dns_support = true<br>  tags = &#123;<br>    Name = &quot;main-vpc&quot;<br>  &#125;<br>&#125;<br><br>resource &quot;aws_subnet&quot; &quot;public_subnet&quot; &#123; # 公有子网<br>  vpc_id                  = aws_vpc.main.id<br>  cidr_block              = &quot;10.0.1.0/24&quot;<br>  map_public_ip_on_launch = true<br>  availability_zone       = &quot;us-west-2a&quot;<br>  tags = &#123;<br>    Name = &quot;public-subnet&quot;<br>  &#125;<br>&#125;<br><br>resource &quot;aws_subnet&quot; &quot;private_subnet&quot; &#123; # 私有子网<br>  vpc_id                  = aws_vpc.main.id<br>  cidr_block              = &quot;10.0.2.0/24&quot;<br>  map_public_ip_on_launch = false<br>  availability_zone       = &quot;us-west-2a&quot;<br>  tags = &#123;<br>    Name = &quot;private-subnet&quot;<br>  &#125;<br>&#125;<br><br>resource &quot;aws_internet_gateway&quot; &quot;gw&quot; &#123; # 互联网网关<br>  vpc_id = aws_vpc.main.id<br>  tags = &#123;<br>    Name = &quot;main-gateway&quot;<br>  &#125;<br>&#125;<br><br>resource &quot;aws_eip&quot; &quot;nat&quot; &#123;<br>  vpc = true<br>&#125;<br><br>resource &quot;aws_nat_gateway&quot; &quot;nat&quot; &#123; # nat网关<br>  allocation_id = aws_eip.nat.id<br>  subnet_id     = aws_subnet.public_subnet.id<br>  tags = &#123;<br>    Name = &quot;main-nat-gateway&quot;<br>  &#125;<br>&#125;<br><br>resource &quot;aws_route_table&quot; &quot;public_route_table&quot; &#123; # 路由表<br>  vpc_id = aws_vpc.main.id<br><br>  route &#123;<br>    cidr_block = &quot;0.0.0.0/0&quot;<br>    gateway_id = aws_internet_gateway.gw.id<br>  &#125;<br><br>  tags = &#123;<br>    Name = &quot;public-route-table&quot;<br>  &#125;<br>&#125;<br><br>resource &quot;aws_route_table_association&quot; &quot;public&quot; &#123; # 路由表绑定<br>  subnet_id      = aws_subnet.public_subnet.id<br>  route_table_id = aws_route_table.public_route_table.id<br>&#125;<br><br>resource &quot;aws_security_group&quot; &quot;default&quot; &#123; # 安全组<br>  name        = &quot;default_security_group&quot;<br>  description = &quot;Default security group&quot;<br>  vpc_id      = aws_vpc.main.id<br><br>  egress &#123;<br>    from_port   = 0<br>    to_port     = 0<br>    protocol    = &quot;-1&quot;<br>    cidr_blocks = [&quot;0.0.0.0/0&quot;]<br>  &#125;<br>&#125;<br><br># 必要情况下你还可以添加更多的规则，例如允许入站HTTP和SSH等<br></code></pre></td></tr></table></figure><h2 id="S3-存储桶策略"><a href="#S3-存储桶策略" class="headerlink" title="S3 存储桶策略"></a>S3 存储桶策略</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// policy版本&quot;2008-10-17&quot;或&quot;2012-10-17&quot;,建议选最新的以使用最新功能</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PublicReadForGetBucketObjects&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:PutObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;DenyPublicDelete&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Deny&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:DeleteObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::example-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="S3-ACLs"><a href="#S3-ACLs" class="headerlink" title="S3  ACLs"></a>S3  ACLs</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">AccessControlPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Owner</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>owner-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Owner</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AccessControlList</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grant</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Grantee</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">&quot;CanonicalUser&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>owner-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Grantee</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span>&gt;</span>FULL_CONTROL<span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grant</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Grant</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Grantee</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xsi:type</span>=<span class="hljs-string">&quot;CanonicalUser&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ID</span>&gt;</span>user-unique-id<span class="hljs-tag">&lt;/<span class="hljs-name">ID</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Grantee</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Permission</span>&gt;</span>READ<span class="hljs-tag">&lt;/<span class="hljs-name">Permission</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Grant</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">AccessControlList</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AccessControlPolicy</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="各种对比"><a href="#各种对比" class="headerlink" title="各种对比"></a>各种对比</h1><table><thead><tr><th>WAF</th><th>安全组</th><th>NACLs</th></tr></thead><tbody><tr><td>主要用于保护<code>web应用</code>免受web攻击(SQL注入,跨站脚本攻击等),通过自定义规则控制出入的http&#x2F;https请求可以部署在cloudfront,ALB,API GATEWAY上</td><td>服务于EC2<code>实例</code>,类似虚拟防火墙,控制出入站流量.白名单,默认拒绝所有,有状态</td><td><code>子网级别</code>流量控制,无状态</td></tr></tbody></table><table><thead><tr><th>AWS Trusted Advisor</th><th>Amazon Inspector</th><th>AWS Shield Advanced</th><th>Amazon GuardDuty</th></tr></thead><tbody><tr><td>咨询服务,自动检查你的aws资源并提出优化建议(成本,性能,容错)</td><td>自动的安全评估服务(安全漏洞,合规性)</td><td>DDos防护,可以部署在NLB上</td><td>威胁检测服务,通过分析处理各种数据(比如CloudTrail事件,VPC流日志)来检测恶意活动和异常行为.</td></tr></tbody></table><table><thead><tr><th>AWS Backup</th><th>Amazon Data Lifecycle Manager</th></tr></thead><tbody><tr><td>提供中心化服务配置和管理数据备份,覆盖很多AWS服务,比如EC2,RDS,DynamoDB,EFS,FSx和S3</td><td>自动化EBS卷和快照的生命周期管理</td></tr></tbody></table><table><thead><tr><th>NLB</th><th>ALB</th></tr></thead><tbody><tr><td>4层(传输层),主要用于TCP&#x2F;UDP的流量负载均衡</td><td>7层(应用层),HTTP&#x2F;HTTPS</td></tr><tr><td>处理每秒数百万请求保持低延迟</td><td>支持websocket和HTTP&#x2F;2</td></tr><tr><td>允许将流量直接路由到实例的私有IP或AWS外部的IP</td><td>适合微服务和容器</td></tr><tr><td>支持TCP长连接和websocket</td><td>支持基于路由的转发</td></tr><tr><td>不支持路由转发</td><td></td></tr></tbody></table><h1 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h1><h1 id="ALB代理ECS-Fargate"><a href="#ALB代理ECS-Fargate" class="headerlink" title="ALB代理ECS Fargate"></a>ALB代理ECS Fargate</h1><ol><li>创建ALB,选择合适的网络和子网</li><li>针对ECS Fargate的服务创建Target Group,并设好健康检查</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AWS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-面向对象高级特性</title>
    <link href="/2024/02/24/python-oop-advance/"/>
    <url>/2024/02/24/python-oop-advance/</url>
    
    <content type="html"><![CDATA[<h1 id="动态绑定属性和方法"><a href="#动态绑定属性和方法" class="headerlink" title="动态绑定属性和方法"></a>动态绑定属性和方法</h1><p>python是一种动态语言,而动态语言的类的属性和方法可以<code>动态绑定</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如有这么一个类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 动态绑定属性</span><br>s = Student()<br>s.name = <span class="hljs-string">&#x27;Peter&#x27;</span><br><span class="hljs-built_in">print</span>(s.name)<br><br><span class="hljs-comment"># 动态绑定方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>): <span class="hljs-comment"># 先定义一个函数</span><br>    <span class="hljs-variable language_">self</span>.age = age<br>    <br><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br>s.set_age = MethodType(set_age, s) <span class="hljs-comment"># 给实例绑定方法</span><br>s.set_age(<span class="hljs-number">25</span>)<br>s.age<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>这种动态绑定属性和方法,可以在程序运行过程中对实例添加属性和方法,但是<code>只是对该实例生效</code>,同一个类创建的另一个实例是不生效的.</p><h1 id="solt"><a href="#solt" class="headerlink" title="__solt__"></a>__solt__</h1><blockquote><p>如果不想让别人随意动态绑定属性,可以使用<code>__solt__</code>指定可以绑定的属性名,实例只可以绑定指定的属性.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment"># 用tuple定义允许绑定的属性名称</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student() <span class="hljs-comment"># 创建新的实例</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Michael&#x27;</span> <span class="hljs-comment"># 绑定属性&#x27;name&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age = <span class="hljs-number">25</span> <span class="hljs-comment"># 绑定属性&#x27;age&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">99</span> <span class="hljs-comment"># 绑定属性&#x27;score&#x27;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;score&#x27;</span> <span class="hljs-comment"># slot没有允许score的属性绑定,因而报错AttributeError</span><br></code></pre></td></tr></table></figure><h1 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h1><p>属性装饰器,用于将<code>类的方法</code>转换为<code>属性</code>,从而实现属性的访问和设置时调用对应的方法.</p><p>主要适用场景有:</p><ul><li>实现属性的访问控制: 将方法装饰为@property控制属性的访问权限(只读,只写,读写).</li><li>简化属性的访问: 将方法转为属性,就可以直接适用属性的访问方式(点号语法)访问方法</li><li>属性计算&#x2F;验证: 在属性访问时执行特定的计算或逻辑,或实现验证</li></ul><p>getter和setter:  类的外部公共接口,用来访问和修改属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, radius</span>):<br>        <span class="hljs-variable language_">self</span>.radius = radius<br>        <br><span class="hljs-meta">    @property </span><span class="hljs-comment"># diameter就装饰成@property,该方法就会成为对应属性的getter方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameter</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.radius * <span class="hljs-number">2</span><br>    <br><span class="hljs-meta">    @diameter.setter </span><span class="hljs-comment"># 被属性装饰器装饰后,会自动生成对应的setter装饰器</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameter</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;diameter  must be an integer!&#x27;</span>)<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;diameter must between 0 ~ 100&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>._radius = value <span class="hljs-comment"># _开头的变量名是一个约定俗成的做法,表示这个变量是一个私有变量,应谨慎处理,但开发人员依旧可以直接访问和修改该变量</span><br>        <span class="hljs-comment"># 使用_开头是为了提醒开发者,这是一个私有变量,应该通过类的公共接口(getter,setter)来访问和修改</span><br>        <br>a = Circle(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(a.diameter) <span class="hljs-comment"># 结果是10 (getter)</span><br>a.diameter = -<span class="hljs-number">1</span> <span class="hljs-comment"># 报错 (setter)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-comment">#birth是一个可读写属性</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birth</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._birth <span class="hljs-comment"># 注意实例变量名不能与方法名一样,因为在调用s.birth时,首先会转回方法调用,然后在执行return时候,又视为访问self的属性,再次转为方法调用,造成无限递归,最终导致栈溢出RecursionError</span><br>    <br><span class="hljs-meta">    @birth.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birth</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>._birth = value<br>        <br>    <span class="hljs-comment"># age只定义getter不定义setter就是只读</span><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">age</span>(<span class="hljs-params">self</span>):<br>        retuen <span class="hljs-number">2015</span> - <span class="hljs-variable language_">self</span>._birth<br></code></pre></td></tr></table></figure><h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>一个子类可以通过多重继承同时获得多个父类的所有功能.</p><p>假设要实现4种动物:</p><ul><li>Dog - 狗</li><li>Bat - 蝙蝠</li><li>Parrot - 鹦鹉</li><li>Ostrich - 鸵鸟</li></ul><p>我们可以按照哺乳动物和鸟类来归类,可以设计出这样的类的层次:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    Animal     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Mammal    │           │    Bird     │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Bat   │  │ Parrot  │  │ Ostrich │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><p>如果按<code>能跑</code>和<code>能飞</code>来划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    Animal     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │  Runnable   │           │   Flyable   │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │ Ostrich │  │ Parrot  │  │   Bat   │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><p>如果合并两种划分方式,就要设计更多层次:</p><ul><li>哺乳类: 能跑的哺乳类, 能飞的哺乳类</li><li>鸟类: 能跑的鸟类, 能飞的鸟类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    Animal     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Mammal    │           │    Bird     │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│  MRun   │  │  MFly   │  │  BRun   │  │  BFly   │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br>     │            │            │            │<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Bat   │  │ Ostrich │  │ Parrot  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><p>如果还要增加”宠物类”和”非宠物类”呢?层次将会越搞越多,类的数量也会呈指数级增长.此时就应该用到多重继承.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最开始的设计,只分哺乳类和鸟类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 大类:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mammal</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 各种动物:</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Mammal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(<span class="hljs-title class_ inherited__">Mammal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parrot</span>(<span class="hljs-title class_ inherited__">Bird</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ostrich</span>(<span class="hljs-title class_ inherited__">Bird</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 加入可跑和可飞</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Runnable</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Flying...&#x27;</span>)<br>        <br><span class="hljs-comment"># 多重继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(Mammal, Runnable):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bat</span>(Mammal, Flyable):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h2><blockquote><p>一般在设计类的继承关系时,通常都是单一继承,但是如果需要<code>混入</code>额外功能时候,可以通过多重继承实现.这种设计称为MixIn.</p><p>MixIn的目的就是给一个类增加多个功能.在设计类的时候,我们优先考虑通过多重继承组合多个MixIn功能,而不是设计多层次的继承关系</p></blockquote><p>为了更好地看出继承关系,一般我们会把需要加上的类名改为<code>xxxMixIn</code>,MixIn类的定义通常不定义<code>__init__</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeakMixin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;I can speak.&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EatMixin</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;I can eat.&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(Animal, SpeakMixin, EatMixin):<br>    <span class="hljs-keyword">pass</span><br><br>dog = Dog()<br>dog.speak()  <span class="hljs-comment"># 输出：I can speak.</span><br>dog.eat()  <span class="hljs-comment"># 输出：I can eat.</span><br></code></pre></td></tr></table></figure><p>python自带的很多库也使用了MixIn,比如<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务,如果要同时服务多个用户就必须使用多进程或多线程模型,这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTCPServer</span>(TCPServer, ForkingMixIn):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="方法解析顺序-MRO"><a href="#方法解析顺序-MRO" class="headerlink" title="方法解析顺序(MRO)"></a>方法解析顺序(MRO)</h2><p>python中用于确定类方法调用顺序的算法.在多重继承下,当一个类实例调用一个方法时,MRO会决定应该使用哪个父类的实现.确保方法调用的确定性和一致性,避免命名冲突和歧异.</p><p>基本规则:</p><ul><li>深度优先搜索: MRO从当前类开始,一次搜索父类和祖先类,直到找到要调用的方法</li><li>从左到右: 在每个类中,MRO会从左到右搜索其基类列表</li><li>线性化: MRO会将所有继承关系转换为一个线性顺序,从而避免循环引用和无限递归</li></ul><p>具体步骤:</p><ol><li>获取当前类的MRO属性: 每个类都有一个<code>__mro__</code>属性,其中包含了该类的MRO列表</li><li>遍历MRO列表: 对于MRO列表中的每个类,检查,检查该类是否定义了要调用的方法</li><li>找到第一个定义该方法的类: 如果找到,则使用该类的实现</li><li>没有找到: raise <code>AttributeError</code>异常</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> inspect<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">B</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(C, B):<br>    <span class="hljs-keyword">pass</span><br><br>mro = inspect.getmro(D)<br><span class="hljs-built_in">print</span>(mro)  <span class="hljs-comment"># 输出：(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="hljs-built_in">print</span>(D.__mro__) <span class="hljs-comment"># 也可以执行print MRO 属性</span><br></code></pre></td></tr></table></figure><h1 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h1><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><p>以<code>双下划线开头和结尾</code>的特殊方法,用于扩展类的功能和行为.这些方法允许你控制类的实例化,属性访问,运算符重载,迭代等行为,从而实现更强大的类的设计.</p><p>常见的魔术方法及用途:</p><table><thead><tr><th>魔术方法</th><th>用途</th></tr></thead><tbody><tr><td><code>__init__</code></td><td>初始化方法,用于创建类的实例时设置属性</td></tr><tr><td><code>__str__</code></td><td>字符串表示方法,用于将类实例转换成字符串</td></tr><tr><td><code>__repr__</code></td><td>表示方法,用于提供更详细的类实例表示</td></tr><tr><td><code>__iter__</code></td><td>迭代器方法,用于使类实例可用于for循环</td></tr><tr><td><code>__next__</code></td><td>迭代器方法,用于返回迭代的写一个元素</td></tr><tr><td><code>__getitem__</code></td><td>索引方法,用于获取类实例的元素</td></tr><tr><td><code>__setitem__</code></td><td>索引方法,用于设置类实例的元素</td></tr><tr><td><code>__add__</code></td><td>加法运算符重载方法，用于定义自定义加法运算</td></tr><tr><td><code>__sub__</code></td><td>减法运算符重载方法，用于定义自定义减法运算</td></tr><tr><td><code>__mul__</code></td><td>乘法运算符重载方法，用于定义自定义乘法运算</td></tr><tr><td><code>__eq__</code></td><td>等价运算符重载方法，用于定义自定义相等性检查</td></tr><tr><td><code>__call__</code></td><td>调用方法,用于使类实例可想函数一样调用</td></tr></tbody></table><p>使用这些魔术方法来<code>自定义</code>类的行为,就称为定制类,下面是一些例子</p><ol><li><p><strong><code>__init__(self, ...)</code>:</strong> 初始化实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, attr1, attr2</span>):<br>        <span class="hljs-variable language_">self</span>.attr1 = attr1<br>        <span class="hljs-variable language_">self</span>.attr2 = attr2<br></code></pre></td></tr></table></figure></li><li><p><strong><code>__str__(self):</code></strong> 返回一个可读的字符串表示该类的一个实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;MyClass(<span class="hljs-subst">&#123;self.value&#125;</span>)&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>__add__(self, other):</code></strong> 实现加法操作。注意，这个方法通常用于实现类与数字之间的相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> MyClass(<span class="hljs-variable language_">self</span>.value + other)<br></code></pre></td></tr></table></figure></li><li><p><strong><code>__len__(self):</code></strong> 返回对象的长度（如字符串或列表的长度）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.value)<br></code></pre></td></tr></table></figure></li><li><p><strong><code>__eq__(self, other):</code></strong> 实现等于操作 <code>==</code>。通过实现这个方法，你定义了两个类的实例相等的标准。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.value == other.value<br></code></pre></td></tr></table></figure></li></ol><h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>python中通常使用<code>大写字母</code>+<code>下划线</code>来定义常量,python中的常量没有严格的限制,没有关键字声明,它在代码中还是可变的.当常量数量变多,声明和引用可能会变得麻烦或混乱,此时可以使用<code>枚举类</code>来定义和管理这些常量.</p><blockquote><p>枚举是一种数据类型，用于定义一组固定且有意义的值。想象一下，你想要表示一个星期中的某一天，你可能会用数字 1 到 7 来表示，但这样容易让人混淆。枚举允许你用更具描述性的名字来表示这些值，例如 MONDAY, TUESDAY, WEDNESDAY 等。</p></blockquote><p>python中使用<code>enum</code>模块来实现<code>枚举类</code>.</p><p>优点:</p><ul><li><strong>代码可读性提升:</strong> 使用枚举类，代码更清晰易懂，因为每个值都有一个有意义的名字。</li><li><strong>类型安全:</strong> 枚举类定义了常量的类型，避免了使用错误的值。</li><li><strong>代码维护方便:</strong> 修改枚举值只需修改枚举类定义，无需修改使用该枚举类的代码。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义枚举类</span><br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    MONDAY = <span class="hljs-number">1</span><br>    TUESDAY = <span class="hljs-number">2</span><br>    WEDNESDAY = <span class="hljs-number">3</span><br>    THURSDAY = <span class="hljs-number">4</span><br>    FRIDAY = <span class="hljs-number">5</span><br>    SATURDAY = <span class="hljs-number">6</span><br>    SUNDAY = <span class="hljs-number">7</span><br>    <br><span class="hljs-comment"># 访问枚举类(使用.表达式)</span><br><span class="hljs-built_in">print</span>(Weekday.MONDAY) <span class="hljs-comment"># 输出Weekday.MONDAY</span><br><span class="hljs-built_in">print</span>(Weekday.MONDAY.value) <span class="hljs-comment"># 输出1</span><br></code></pre></td></tr></table></figure><p>枚举类可以定义方法,比如定义<code>__str__</code>自定义输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrafficLight</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    RED = <span class="hljs-string">&quot;stop&quot;</span><br>    YELLOW = <span class="hljs-string">&quot;caution&quot;</span><br>    GREEN = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.value<br><br><span class="hljs-built_in">print</span>(TrafficLight.RED)<br><span class="hljs-comment"># 直接输出stop</span><br></code></pre></td></tr></table></figure><h2 id="实际使用例子"><a href="#实际使用例子" class="headerlink" title="实际使用例子"></a>实际使用例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpStatusCode</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    OK = <span class="hljs-number">200</span><br>    CREATED = <span class="hljs-number">201</span><br>    BAD_REQUEST = <span class="hljs-number">400</span><br>    NOT_FOUND = <span class="hljs-number">404</span><br>    INTERNAL_SERVER_ERROR = <span class="hljs-number">500</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_response</span>(<span class="hljs-params">status_code</span>):<br>    <span class="hljs-keyword">if</span> status_code == HttpStatusCode.OK: <span class="hljs-comment">#可以直接使用HttpStatusCode.OK来判断</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Request successful!&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.CREATED:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Resource created successfully!&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.BAD_REQUEST:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid request parameters.&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.NOT_FOUND:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Resource not found.&quot;</span>)<br>    <span class="hljs-keyword">elif</span> status_code == HttpStatusCode.INTERNAL_SERVER_ERROR:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Server encountered an error.&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Unknown status code: <span class="hljs-subst">&#123;status_code&#125;</span>&quot;</span>)<br><br>response = requests.get(<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>)<br>response_status_code = response.status_code<br><br>handle_response(response_status_code)<br></code></pre></td></tr></table></figure><h1 id="元类与type"><a href="#元类与type" class="headerlink" title="元类与type"></a>元类与type</h1><p>在python这种动态语言中,函数和类的定义不是编译时发生的,而是在运行时动态创建的.</p><p>比如写一个<code>hello.py</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;world&#x27;</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Hello <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当python解释器载入<code>hello</code>模块,会依次执行该模块的代码,结果就是动态创建一个<code>Hello</code>的class对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> hello <span class="hljs-keyword">import</span> Hello<br><span class="hljs-meta">&gt;&gt;&gt; </span>h = Hello()<br><span class="hljs-meta">&gt;&gt;&gt; </span>h.hello()<br>Hello world<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(Hello))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;type&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(h))<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;hello.Hello&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到<code>Hello</code>是一个class,类型就是<code>type</code>,<code>h</code>是一个实例,也是一个class,类型是<code>Hello</code>.</p><hr><p>先来了解几个概念:</p><ul><li>类: 面向对象编程中,类是对象的蓝图,包含了对象的属性(数据)和方法(行为).</li><li>实例: 类是模板,实例是根据模板创建的具体对象</li><li>元类: 元类是类的一种特殊类型,用于创建类,简单来说:<strong>类是用来创建对象的,元类用来创建类</strong></li></ul><p><code>type()</code>是一个内置函数,用来获取对象的类型信息,也可以用来动态创建类.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># type()创建类的语法</span><br><span class="hljs-built_in">type</span>(name, bases, attrs)<br><span class="hljs-comment"># name: 新类名称</span><br><span class="hljs-comment"># bases: 父类列表</span><br><span class="hljs-comment"># attrs: 新类的属性和方法字典</span><br></code></pre></td></tr></table></figure><blockquote><ul><li><p>type()是动态类创建的工具或接口,而元类是这个接口背后的机制.</p></li><li><p>当我们使用type()创建动态类时,type()会调用python的元类系统.</p></li><li><p>python的默认元类就是<code>type</code>,这意味着当我们使用type()创建类时,默认会使用<code>type元类</code></p></li></ul></blockquote><p>这就解释了为什么<code>Hello</code>这个class的类型是type.因为python默认是使用type(),基于<code>type元类</code>来创建动态类的.</p><blockquote><p>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况到。</p></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义元类,来自定义类创建的机制,自定义元类需要继承自`type`类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMeta</span>(<span class="hljs-title class_ inherited__">type</span>): <span class="hljs-comment"># 按照习惯元类名总是以Meta或Metaclass结尾</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>): <span class="hljs-comment"># __new__方法是元类的关键方法,负责创建新的类</span><br>        <span class="hljs-comment"># 在这里添加自定义逻辑,例如修改类属性,添加新方法等</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br></code></pre></td></tr></table></figure><ul><li><code>__new__()</code> 方法是元类的关键方法，它负责创建新的类。</li><li><code>cls</code>: 元类自身</li><li><code>name</code>: 新类的名称</li><li><code>bases</code>: 新类的父类列表</li><li><code>attrs</code>: 新类需要包含的属性和方法字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br><span class="hljs-comment"># super(): 这个函数用于调用父类的函数或方法.这里,super()用于调用默认元类type的__new__()方法</span><br><span class="hljs-comment"># __new__(): 这是元类type的一个特殊方法,用于创建新的类对象</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">因此这行代码的的具体作用是:</span><br><span class="hljs-string">1. 调用父类type的__new__()方法: 因为我们继承自type类,需要使用父类的机制来创建新类</span><br><span class="hljs-string">2. 传递参数: 传递元类MyMeta自身(cls), 新类名称(name),新类父列表(bases)和新类属性和方法字典(attrs)到父类的__new__()方法中</span><br><span class="hljs-string">3. 返回新类对象: 父类__new__()方法最终返回一个新的类对象</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用<code>metaclass</code>参数来指定自定义元类创建类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>(metaclass=MyMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-variable language_">self</span>.value = value<br></code></pre></td></tr></table></figure><p><code>MyClass</code>使用<code>MyMeta</code>元类创建.<code>MyMeta</code>的<code>__new__()</code>方法将被调用,并能修改<code>MyClass</code>的属性和行为.</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>元类虽然不是最常见的编程技巧，但它在一些特定场景下能发挥强大的作用，提升代码的可维护性和可扩展性.</p><blockquote><p>比如你在开发一个大型电商平台,需要管理各种商品类型,比如衣服,书籍,电子产品等,每个都有特定的属性和行为,比如衣服需要尺寸,颜色等属性,书记需要作者,出版社等</p><ul><li><p>传统方式:</p><p>分别定义各种类,比如<code>Clothing</code>,<code>Book</code>,<code>Electronics</code></p><p>每个类都有各自的属性和方法,代码架构会变大且难以维护</p></li><li><p>使用元类</p><p>定义一个元类<code>ProductMeta</code>,用于创建商品类型的类</p><p><code>ProductMeta</code>可以接受商品类型的属性和方法作为参数,并根据这些参数动态创建类</p><p>这样,我们可以用一种通用的方式来定义商品类型,避免重复代码,并更容易添加新的商品类型</p></li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductMeta</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, name, bases, attrs</span>):<br>        attrs[<span class="hljs-string">&#x27;get_product_info&#x27;</span>] = <span class="hljs-keyword">lambda</span> <span class="hljs-variable language_">self</span>: <span class="hljs-string">f&quot;Product name: <span class="hljs-subst">&#123;self.__class__.__name__&#125;</span>&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, name, bases, attrs)<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>(metaclass=ProductMeta):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.price = price<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clothing</span>(<span class="hljs-title class_ inherited__">Product</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price, size, color</span>):<br>        <span class="hljs-built_in">super</span>().__inti__(name, price):<br>            <span class="hljs-variable language_">self</span>.size = size<br>            <span class="hljs-variable language_">self</span>.color = color<br>            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span>(<span class="hljs-title class_ inherited__">Product</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, price, author, publisher</span>):<br>        <span class="hljs-built_in">super</span>().__init__(name, price)<br>        <span class="hljs-variable language_">self</span>.author = author<br>        <span class="hljs-variable language_">self</span>.publisher = publisher<br>    <br><span class="hljs-comment"># 使用</span><br>clothing = Clothing(<span class="hljs-string">&quot;T-shirt&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;M&quot;</span>, <span class="hljs-string">&quot;Red&quot;</span>)<br>book = Book(<span class="hljs-string">&quot;The Hitchhiker&#x27;s Guide to the Galaxy&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;Douglas Adams&quot;</span>, <span class="hljs-string">&quot;Pan Books&quot;</span>)<br><br><span class="hljs-built_in">print</span>(clothing.get_product_info())  <span class="hljs-comment"># Output: Product name: Clothing</span><br><span class="hljs-built_in">print</span>(book.get_product_info())  <span class="hljs-comment"># Output: Product name: Book</span><br></code></pre></td></tr></table></figure><blockquote><p>这里,直接使用元类创建具体商品类也是可行的,但是中间添加一层Product中间类有以下优点:</p><ol><li>代码组织性: 将<code>Product</code>作为基类,可以将所有商品类型代码组织在一起,形成更清晰的层次结构,便于理解和维护</li><li>代码复用: <code>Product</code>类可以包含所有商品类共有的属性和方法,提高代码复用性</li><li>扩展性: 如果将来需要添加新商品,只需要继承<code>Product</code>类,并实现具体的属性和方法即可</li><li>类型安全: 所有商品类都继承<code>Product</code>保证所有商品类都拥有共同的接口,提高代码的类型安全和可维护性</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ansible-必知必会</title>
    <link href="/2024/02/22/ansible-mustknow/"/>
    <url>/2024/02/22/ansible-mustknow/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/1*8H4XYCNV-xamG0joz22apQ.png" srcset="/img/loading.gif" lazyload alt="Ansible 101 Getting Started. Ansible is an agentless automation that… | by  Winton Huang | Medium"></p><p><a href="https://ansible-tran.readthedocs.io/en/latest/index.html">中文文档</a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote><p>Ansible的名字来自小说&lt;安德的游戏&gt;是一个跨越时空的通讯工具</p></blockquote><p>Ansible本质上只是一个框架,用python开发,实际通过它的库实现功能,其中有三个关键库:</p><ul><li>Paramiko: Python对ssh的实现</li><li>PyYaml: 解析和生成yaml</li><li>jinjia2: 用于模板的生成，在使用 <code>template</code> 模块自动生成文件时特别有用</li></ul><p>特性:</p><ul><li>基于python和ssh,无需agent</li><li>安全,基于openssh</li><li><code>幂等</code>: 一个任务执行一遍和执行n遍效果一样,不会因重复执行而带来意料之外的效果</li></ul><h1 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install epel-release<br>yum -y install ansible<br></code></pre></td></tr></table></figure><p>配置ssh –&gt; 定义inventory –&gt; 执行ansible命令&#x2F;执行playbook</p><h1 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h1><p>Ansible管理的主机清单配置文件, 默认地址: <code>/etc/ansible/hosts</code></p><blockquote><p>ansible可以同时操作一个组的多台主机</p><p>组和主机之间的关系通过inventory文件配置</p><p>可以同时使用多个inventory文件</p></blockquote><h2 id="INI格式"><a href="#INI格式" class="headerlink" title="INI格式"></a>INI格式</h2><p>也支持<code>yaml</code>格式, 个人觉得<code>ini</code>更清晰易读.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 单个主机</span><br>server1.example.com<br><br><span class="hljs-comment"># 主机组 &#x27;web&#x27; 下的主机</span><br><span class="hljs-section">[web]</span><br>server2.example.com<br>server3.example.com<br><br><span class="hljs-comment"># 范围指定的主机</span><br><span class="hljs-section">[database]</span><br>db<span class="hljs-section">[01:10]</span>.example.com<br><br><span class="hljs-comment"># 使用端口和变量的主机定义</span><br><span class="hljs-section">[loadbalancer]</span><br>lb.example.com:8080 <span class="hljs-attr">ansible_connection</span>=ssh ansible_ssh_user=myuser<br></code></pre></td></tr></table></figure><h2 id="定义属于整个组的变量"><a href="#定义属于整个组的变量" class="headerlink" title="定义属于整个组的变量"></a>定义属于整个组的变量</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[atlanta]</span><br>host1<br>host2<br><br><span class="hljs-section">[atlanta:vars]</span><br><span class="hljs-attr">ntp_server</span>=ntp.atlanta.example.com<br><span class="hljs-attr">proxy</span>=proxy.atlanta.example.com<br></code></pre></td></tr></table></figure><h2 id="把一个组作为另一个组的子成员"><a href="#把一个组作为另一个组的子成员" class="headerlink" title="把一个组作为另一个组的子成员"></a>把一个组作为另一个组的子成员</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[webservers]</span><br>web1.example.com<br>web2.example.com<br><br><span class="hljs-section">[dbservers]</span><br>db1.example.com<br>db2.example.com<br><br><span class="hljs-comment"># 使用children关键字定义linux父组下有webservers和dbservers子组</span><br><span class="hljs-section">[linux:children]</span><br>webservers<br>dbservers<br></code></pre></td></tr></table></figure><h2 id="分文件保存变量"><a href="#分文件保存变量" class="headerlink" title="分文件保存变量"></a>分文件保存变量</h2><p><code>ansible&gt;1.4</code>才有的功能</p><p>在inventory文件中保存所有变量并不是最佳实践,以<code>独立文件</code>的方式保存是更优选择.这些文件应该使用<code>yaml</code>格式配置.</p><blockquote><p>假设有一个主机名为: <code>football</code>, 它同时属于两个组: <code>foo</code>和<code>bar</code>,那么以下配置文件中的变量都可以为它所用</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/ansible/group_vars/&lt;group_name&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/ansible/host_vars/&lt;hostname_name&gt;</span><br>/etc/ansible/group_vars/foo<br>/etc/ansible/group_vars/bar<br>/etc/ansible/host_vars/football<br></code></pre></td></tr></table></figure><p>另外,还可以为一个主机一个组创建一个以主机名或组名命名的目录,目录中创建多个文件,目录中的文件的变量都会被读取为主机或组的变量.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/ansible/group_vars/&lt;group_name&gt;/&lt;any_file_name&gt;</span><br>/etc/ansible/group_vars/raleigh/db_settings<br>/etc/ansible/group_vars/raleigh/cluster_settings<br></code></pre></td></tr></table></figure><blockquote><ul><li>Tip1: ansible1.2+,<code>group_vars</code>和<code>host_vars</code>可以放在inventory目录下<code>/etc/ansible/hosts</code>或是playbook目录下,其中palybook优先级更高.</li><li>Tips: 把inventory文件和变量文件都放入git中管理,是推荐做法</li></ul></blockquote><h2 id="inventory参数"><a href="#inventory参数" class="headerlink" title="inventory参数"></a>inventory参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible_ssh_host #将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.<br><br>ansible_ssh_port #ssh端口号.如果不是默认的端口号,通过此变量设置.<br><br>ansible_ssh_user #默认的 ssh 用户名<br><br>ansible_ssh_pass #ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)<br><br>ansible_sudo_pass # sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)<br><br>ansible_sudo_exe (new in version 1.8) #sudo 命令路径(适用于1.8及以上版本)<br><br>ansible_connection #与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &#x27;smart&#x27;,&#x27;smart&#x27; 方式会根据是否支持 ControlPersist, 来判断&#x27;ssh&#x27; 方式是否可行.<br><br>ansible_ssh_private_key_file #ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.<br><br>ansible_shell_type #目标系统的shell类型.默认情况下,命令的执行使用 &#x27;sh&#x27; 语法,可设置为 &#x27;csh&#x27; 或 &#x27;fish&#x27;.<br><br>ansible_python_interpreter # 目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \*BSD, 或者 /usr/bin/python<br><span class="hljs-meta prompt_"># </span><span class="language-bash">不是 2.X 版本的 Python.我们不使用 <span class="hljs-string">&quot;/usr/bin/env&quot;</span> 机制,因为这要求远程用户的路径设置正确,且要求 <span class="hljs-string">&quot;python&quot;</span> 可执行程序名不可为 python以外的名字(实际有可能名为python26).</span><br><br>ansible_[ruby|perl]_interpreter<br><span class="hljs-meta prompt_"># </span><span class="language-bash">与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径....</span><br></code></pre></td></tr></table></figure><p>一个配置例子</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini">some_host         <span class="hljs-attr">ansible_ssh_port</span>=<span class="hljs-number">2222</span>     ansible_ssh_user=manager<br>aws_host          <span class="hljs-attr">ansible_ssh_private_key_file</span>=/home/example/.ssh/aws.pem<br>freebsd_host      <span class="hljs-attr">ansible_python_interpreter</span>=/usr/local/bin/python<br>ruby_module_host  <span class="hljs-attr">ansible_ruby_interpreter</span>=/usr/bin/ruby.<span class="hljs-number">1.9</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h1 id="动态Inventory"><a href="#动态Inventory" class="headerlink" title="动态Inventory"></a>动态Inventory</h1><blockquote><p>动态生成或发现目标主机的清单,并不是预先固定写在一个静态文件里面.允许ansible与云服务提供商,虚拟化平台或其他API驱动的服务集成,从而实时获取和更新主机信息.也可以收用kubernetes模块与k8s集群集成.</p></blockquote><h1 id="Ansible-ad-hoc命令"><a href="#Ansible-ad-hoc命令" class="headerlink" title="Ansible ad-hoc命令"></a>Ansible ad-hoc命令</h1><p>其实就是命令行执行ansible命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible --help<br>-a MODULE_ARGS<br>-C #dry run模式,测试<br>-f FORK #ansible一般用来管控多台主机,此选项定义ansible分批发送管控请求,一次多少台<br>--list-hosts #列出本次操作会对哪些主机执行,不真正执行<br>--syntax-check #语法检查<br>-t TREE #将日志输出到指定目录<br>-u UESERNAME #指明使用哪个用户名连接目标主机<br>-b,--become #sudo切换root<br>   --become-user=USERNAME #指定sudo的runas用户,默认root<br>-K #提示输入sudo时的口令<br>-k #提示输入ssh连接密码<br></code></pre></td></tr></table></figure><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible HOST-PATTERN -m MOD_NAME -a MOD_ARGS -f FORKS<br></code></pre></td></tr></table></figure><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><p><code>PATTERN</code>是指如何指定要操作的主机,可以是主机名,也可以是组名,除此以为还有很多高级写法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">invertory内的所有主机</span><br>all<br>*<br><span class="hljs-meta prompt_"># </span><span class="language-bash">IP或多个主机名(<span class="hljs-string">&quot;:&quot;</span>分割),支持<span class="hljs-string">&quot;*&quot;</span>通配</span><br>one.example.com<br>one.example.com:two.example.com<br>192.168.1.50<br>192.168.1.*<br><span class="hljs-meta prompt_"># </span><span class="language-bash">多个组(<span class="hljs-string">&quot;:&quot;</span>分割)</span><br>webservers:dbservers<br><span class="hljs-meta prompt_"># </span><span class="language-bash">组排队</span><br>webservers:!phoenix # 执行的主机必须隶属webservers组但同时不在phoenix组<br>webservers:dbservers:&amp;staging:!phoenix # ‘webservers’ 和 ‘dbservers’ 两个组中隶属于 ‘staging’ 组并且不属于 ‘phoenix’ 组的机器才执行命令<br><span class="hljs-meta prompt_"># </span><span class="language-bash">还可以通过-e传变量</span><br>webservers:!&#123;&#123;excluded&#125;&#125;:&amp;&#123;&#123;required&#125;&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">组编号选主机</span><br>webservers[0]<br>webservers[0-25]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">支持通配和正则,通配何以和组混用</span><br>one*.com:dbservers<br>~(web|db).*\.example\.com<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--<span class="hljs-built_in">limit</span>排除目标</span><br>ansible-playbook site.yml --limit datacenter2<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ansible1.2后支持从文件读取hosts,使用<span class="hljs-string">&quot;@&quot;</span></span><br>ansible-playbook site.yml --limit @retry_hosts.txt<br></code></pre></td></tr></table></figure><p>支持与或非:</p><ul><li><code>:&amp;</code>: 与</li><li><code>:</code>: 或</li><li><code>:!</code>: 非</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><code>-m</code>指定使用的模块,<code>-a</code>指定模块参数.ansible的具体功能都由这些模块提供.下面列举一些常用模块和常用参数.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible-doc -l #列出可用模块<br>ansible-doc -s MOD_NAME #列出模块可用参数和playbook片段<br></code></pre></td></tr></table></figure><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><blockquote><p>创建删除组</p></blockquote><p><code>args</code>:</p><ul><li><p>gid</p></li><li><p>*name: 自定义组名</p></li><li><p>state</p><ul><li>present: 存在,即创建</li><li>absent: 不存在,即删除</li></ul></li><li><p>system: 是否创建系统用户组</p><ul><li>yes</li><li>no</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m group -a &quot;gid=3000 name=mygrp state=present system=no&quot;<br></code></pre></td></tr></table></figure></li></ul><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><blockquote><p>创建删除用户</p></blockquote><p><code>args</code>:</p><ul><li><p>*name</p></li><li><p>uid</p></li><li><p>groups</p></li><li><p>home</p></li><li><p>state&#x3D;present | absent</p></li><li><p>system&#x3D;yes | no</p></li><li><p>move_home&#x3D;yes | no</p><blockquote><p>如果系统已存在该用户,但ansible又创建了一遍,两次定义的家目录路径不一致,是否移动家目录到新位置</p></blockquote></li><li><p>generate_ssh_key&#x3D;yes | no</p><blockquote><p>是否为用户自动创建ssh密钥,如果原来就有了,不会覆盖原来的,而是创建新的</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m user -a &quot;uid=5000 name=testuser state=present groups=mygrp shell=/bin/tcsh&quot;<br></code></pre></td></tr></table></figure></li></ul><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><blockquote><p>以并行的方式同时 SCP 大量的文件到多台机器</p></blockquote><p><code>args</code>:</p><ul><li><p>*dest: 目标路径</p></li><li><p>*src:源路径,支持相对&#x2F;绝对地址</p><blockquote><p>源是目录,默认会递归复制</p><p>源以”&#x2F;“结尾,只复制目录内的内容</p><p>源不以”&#x2F;“结尾,则把目录本身也复制过去</p></blockquote></li><li><p>owner: 属主</p></li><li><p>group: 属组</p></li><li><p>mode: 权限</p></li><li><p>remote_src: 从远程源复制到主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m copy -a &quot;src=/etc/fstab dest=/tmp/fstab.ansible mode=600&quot;<br>ansible all -m copy -a &quot;src=/etc/pam.d/ dest=/tmp/&quot;<br>ansible all -m copy -a &quot;content=&#x27;hi there\n&#x27; dest=/tmp/hi.txt&quot;<br></code></pre></td></tr></table></figure></li></ul><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><blockquote><p>从远端复制文件到本机</p></blockquote><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><blockquote><p>创建或删除文件&#x2F;目录</p></blockquote><ul><li><p>state&#x3D;present | absent | directory | file | link</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m file -a &quot;path=/var/tmp/hello.txt state=directory&quot;<br>ansible all -m file -a &quot;path=/var/tmp/hello.txt state=file&quot;<br>ansible all -m file -a &quot;src=/var/tmp/hello.txt path=/var/tmp/fstab.link state=link&quot; #创建软链文件<br></code></pre></td></tr></table></figure></li></ul><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><blockquote><p>执行给定的命令,但不会使用<code>目标主机</code>shell环境,因此不支持shell特有的语法和通配符.</p><p>command模块<code>不是幂等的</code>,重复执行会失败.</p><p>比如你用command模块创建文件夹,多次执行,就会失败.command模块有相关的参数比如<code>create</code>或<code>remove</code>去处理这种情况.</p><p>当然也可以选择其他幂等的module去处理有不幂等风险的操作.</p></blockquote><ul><li><p>chdir: 切换工作目录</p></li><li><p>executable: 切换执行程序的shell,要使用绝对路径</p></li><li><p>free_from: 自由格式(命令直接给出没不需要kv格式)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m command -a &quot;ifconfig&quot;<br>ansible all -m command -a &quot;chdir=/var/tmp mkdir hi.dir&quot;<br>ansible all -m command -a &quot;echo mageedu | passwd --stdin testuser&quot; # 执行失败<br></code></pre></td></tr></table></figure></li></ul><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><blockquote><p>使用<code>目标主机的shell环境</code>执行命令,这意味着它支持管道,通配,重定向等shell特有的操作,以及可以使用环境变量.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m shell -a &quot;echo mageedu | passwd --stdin testuser&quot; # 用shell就会成功<br></code></pre></td></tr></table></figure><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><blockquote><p>设定周期性任务,实际上就是操作目标主机的crontab</p></blockquote><ul><li><p>name: 指定任务名称, 默认为none</p></li><li><p>day</p></li><li><p>hour</p></li><li><p>job</p></li><li><p>state&#x3D;present | absent</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m cron -a &quot;minute=*/3 job=&#x27;/usr/sbin/update 172.16.0.1 &amp;&gt; /dev/null&#x27;&quot;<br>ansible all -m cron -a &quot;minute=*/3 job=&#x27;/usr/sbin/update 172.16.0.1 &amp;&gt; /dev/null&#x27; name=None state=absent&quot;<br></code></pre></td></tr></table></figure></li></ul><h3 id="yum-dnf"><a href="#yum-dnf" class="headerlink" title="yum&#x2F;dnf"></a>yum&#x2F;dnf</h3><blockquote><p>包管理程序</p><p>一般redhat 8及以上使用dnf</p><p>redhat 8以下使用yum</p></blockquote><ul><li><p>*name: 包名</p></li><li><p>state&#x3D;present | installed | latest | absent | removed</p></li><li><p>disable_gpg_check</p></li><li><p>disablerepo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m yum -a &quot;name=nginx state=installed&quot;<br></code></pre></td></tr></table></figure></li></ul><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><blockquote><p>通用的服务管理模块,它会检测系统使用的是哪一种服务管理方式(sysvinit, upstart, systemd等),并尝试用正确的方式来广利服务.</p><p>当然,针对不同的服务管理方式,ansible都有对应模块,如果不清楚,或者通用功能就行,就使用service就好了</p></blockquote><ul><li><p>*name: 服务名</p></li><li><p>pattern: 如果服务不支持status命令,可以使用pattern过滤字符以获取运行状态</p></li><li><p>runlevel: 设定启动等级</p></li><li><p>enabled: 开机自启动</p></li><li><p>state&#x3D;started | stopped</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m service -a &quot;name=nginx state=started&quot;<br></code></pre></td></tr></table></figure></li></ul><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><blockquote><p>复制本地脚本到目标主机运行,不幂等</p></blockquote><ul><li><p>chdir: 切换目标主机的工作目录</p></li><li><p>cmd: 要使用的本地脚本的路径, 后面可以跟参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible all -m script -a &quot;/tmp/test.sh&quot;<br></code></pre></td></tr></table></figure></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><code>/etc/ansible/ansible.cfg</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[defaults]</span><br><span class="hljs-comment">#inventory     = /etc/ansible/hosts      # 主机列表配置文件</span><br><span class="hljs-comment">#library       = /usr/share/my_modules/  # 库文件存放目录</span><br><span class="hljs-comment">#remote_tmp    = $HOME/.ansible/tmp      # 临时py命令文件存放在远程主机目录</span><br><span class="hljs-comment">#local_tmp     = $HOME/.ansible/tmp      # 本机的临时命令执行目录  </span><br><span class="hljs-comment">#forks         = 5                       # 默认并发数,同时可以执行5次</span><br><span class="hljs-comment">#sudo_user     = root                    # 默认sudo 用户</span><br><span class="hljs-comment">#ask_sudo_pass = True                    # 每次执行ansible命令是否询问ssh密码</span><br><span class="hljs-comment">#ask_pass      = True                    # 每次执行ansible命令是否询问ssh口令</span><br><span class="hljs-comment">#remote_port   = 22                      # 远程主机的端口号(默认22)</span><br><br><span class="hljs-comment">#建议优化项： </span><br><br><span class="hljs-attr">host_key_checking</span> = <span class="hljs-literal">False</span>               <span class="hljs-comment"># 检查对应服务器的host_key，建议取消注释</span><br><span class="hljs-attr">log_path</span>=/var/log/ansible.log           <span class="hljs-comment"># 日志文件,建议取消注释</span><br><span class="hljs-attr">module_name</span>   = command                 <span class="hljs-comment"># 默认模块</span><br></code></pre></td></tr></table></figure><h1 id="ansible命令执行过程"><a href="#ansible命令执行过程" class="headerlink" title="ansible命令执行过程"></a>ansible命令执行过程</h1><ol><li>加载配置文件&#x2F;etc&#x2F;ansible&#x2F;ansible.cfg</li><li>加载自己对应的模块文件</li><li>通过ansible将模块命令生成临时的py文件<ol><li>并将该文件传输到目标主机对应执行用户的$HOME&#x2F;.ansible&#x2F;tmp&#x2F;ansible-tmp-数字&#x2F;XXX.py</li></ol></li><li>给文件+x</li><li>执行并返回结果</li><li>删除临时py文件, sleep 0 退出</li></ol><p>执行结果:</p><ul><li><p>绿色: 成功应用变更</p></li><li><p>黄色: 成功但无变更</p></li><li><p>红色: 失败</p></li></ul><h1 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h1><blockquote><p>ad-hoc与playbook就类似shell命令与shell脚本的关系.</p><p>playbook使用yaml编写.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Enhanced</span> <span class="hljs-string">Playbook</span> <span class="hljs-string">Example</span> <span class="hljs-comment"># playbook name</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">web_servers</span> <span class="hljs-comment"># inventory pattern</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span> <span class="hljs-comment"># 用于权限提升或用户切换</span><br>  <span class="hljs-attr">become_method:</span> <span class="hljs-string">sudo</span> <span class="hljs-comment"># 指定权限提升或用户切换的具体方式</span><br>  <span class="hljs-attr">remote_user:</span> <span class="hljs-string">admin</span> <span class="hljs-comment"># 定义执行远程任务的用户帐户。当 Ansible 与远程主机建立连接时，它将使用这个用户的身份来登录</span><br>  <span class="hljs-attr">tasks:</span> <span class="hljs-comment"># 任务列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Apache</span> <span class="hljs-comment"># task name</span><br>      <span class="hljs-attr">yum:</span> <span class="hljs-comment"># 使用的模块</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">httpd</span> <span class="hljs-comment"># 模块参数</span><br>        <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br>      <span class="hljs-attr">notify:</span> <span class="hljs-comment"># notify是handlers的触发标志</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Restart</span> <span class="hljs-string">Apache</span> <span class="hljs-comment"># 触发哪个handlers</span><br>      <span class="hljs-attr">tags:</span> <span class="hljs-comment"># 标签,可以根据标签指定运行或跳过运行某个或某些task</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">installation</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Copy</span> <span class="hljs-string">Apache</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">File</span><br>      <span class="hljs-attr">copy:</span><br>        <span class="hljs-attr">src:</span> <span class="hljs-string">/path/to/conf/httpd.conf</span><br>        <span class="hljs-attr">dest:</span> <span class="hljs-string">/etc/httpd/conf/httpd.conf</span><br>      <span class="hljs-attr">notify:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Restart</span> <span class="hljs-string">Apache</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">configuration</span><br><br>  <span class="hljs-attr">handlers:</span> <span class="hljs-comment"># 定义handlers任务列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Restart</span> <span class="hljs-string">Apache</span><br>      <span class="hljs-attr">service:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">httpd</span><br>        <span class="hljs-attr">state:</span> <span class="hljs-string">restarted</span><br>      <span class="hljs-attr">tags:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">handlers</span><br></code></pre></td></tr></table></figure><p>其实就是命令调用模块改为yaml写法.</p><h2 id="notify和handlers"><a href="#notify和handlers" class="headerlink" title="notify和handlers"></a>notify和handlers</h2><p>notify是触发器,handlers是响应器.</p><p>如果notify所在的task没有触发变更,notify所定义的handler也不会被触发</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">确保</span> <span class="hljs-string">web</span> <span class="hljs-string">服务正确运行</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">web_servers</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">将配置文件拷贝到远程服务器</span><br>      <span class="hljs-attr">copy:</span><br>        <span class="hljs-attr">src:</span> <span class="hljs-string">/src/webserver.conf</span><br>        <span class="hljs-attr">dest:</span> <span class="hljs-string">/etc/webserver.conf</span><br>      <span class="hljs-attr">notify:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">重启</span> <span class="hljs-string">web</span> <span class="hljs-string">服务</span><br><br>  <span class="hljs-attr">handlers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">重启</span> <span class="hljs-string">web</span> <span class="hljs-string">服务</span><br>      <span class="hljs-attr">service:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">webserver</span><br>        <span class="hljs-attr">state:</span> <span class="hljs-string">restarted</span><br></code></pre></td></tr></table></figure><h2 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指执行有这个tag的任务</span><br>ansible-playbook install_apache.yml --tags &quot;configuration&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">跳过执行有这个tag的任务</span><br>ansible-playbook install_apache.yml --skip-tags &quot;configuration&quot;<br></code></pre></td></tr></table></figure><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">-C #dry run<br>--syntax-check #语法检查<br>-t #指定调用对应标签的任务<br>--list-hosts<br>--list-tags<br>--list-tasks<br></code></pre></td></tr></table></figure><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p><code>vars</code>定义变量,<code>&#123;&#123;var_name&#125;&#125;</code>调用变量</p><h3 id="Fact"><a href="#Fact" class="headerlink" title="Fact"></a>Fact</h3><p>ansible的setup模块获取的主机自带的系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install facter<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取本机的系统信息,setup模块获取的也就是这些信息</span><br>facter -p<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看setup模块参数</span><br>ansible-doc -s setup<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取facts并通过filter参数过滤想要的fact</span><br>ansible all -i inventory.ini -m setup -a &#x27;filter=ansible_*_mb&#x27;<br></code></pre></td></tr></table></figure><p>这种类型的变量直接调用即可.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Collect</span> <span class="hljs-string">only</span> <span class="hljs-string">certain</span> <span class="hljs-string">facts</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">all</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Gather</span> <span class="hljs-string">only</span> <span class="hljs-string">memory</span> <span class="hljs-string">related</span> <span class="hljs-string">facts</span><br>      <span class="hljs-attr">setup:</span> <span class="hljs-comment"># 通过setup模块获取fact</span><br>        <span class="hljs-attr">filter:</span> <span class="hljs-string">ansible_*_mb</span> <span class="hljs-comment"># 过滤fact</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Print</span> <span class="hljs-string">out</span> <span class="hljs-string">the</span> <span class="hljs-string">total</span> <span class="hljs-string">memory</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-comment"># debug模块用于打印或调试信息，它主要用于输出变量的值来帮助理解和调试 playbook 的执行流程。`debug`可以用来输出字符串信息，也可以用来展示`register`所捕获的变量内容。</span><br>    <span class="hljs-attr">msg:</span> <span class="hljs-string">&quot;Total memory on this machine is <span class="hljs-template-variable">&#123;&#123; ansible_memtotal_mb &#125;&#125;</span> MB&quot;</span> <span class="hljs-comment"># 直接使用fact变量</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Check</span> <span class="hljs-string">if</span> <span class="hljs-string">a</span> <span class="hljs-string">directory</span> <span class="hljs-string">exists</span><br>  <span class="hljs-attr">ansible.builtin.stat:</span> <span class="hljs-comment"># Ansible 中的一个内置模块，它用于获取文件或文件夹在远程主机上的状态信息。这些信息包括文件的存在性、类型、大小、权限、所属用户、所属组、最后修改时间等。</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/a/specific/path&quot;</span><br>  <span class="hljs-attr">register:</span> <span class="hljs-string">result</span> <span class="hljs-comment"># register关键词用于捕获任务执行的输出结果，例如命令执行的输出，模块执行的详细结果等。通过`register`保存的结果可以被后续的任务使用，像条件判断、循环迭代等。</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Display</span> <span class="hljs-string">results</span> <span class="hljs-string">if</span> <span class="hljs-string">directory</span> <span class="hljs-string">exists</span><br>  <span class="hljs-attr">debug:</span><br>    <span class="hljs-attr">msg:</span> <span class="hljs-string">&quot;The directory exists!&quot;</span><br>  <span class="hljs-attr">when:</span> <span class="hljs-string">result.stat.exists</span><br></code></pre></td></tr></table></figure><h3 id="用户自定义"><a href="#用户自定义" class="headerlink" title="用户自定义"></a>用户自定义</h3><ol><li><p>命令行定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible-playbook -e pkgname=memcached test.yaml<br></code></pre></td></tr></table></figure></li><li><p>playbook中定义</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">vars:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">var1:</span> <span class="hljs-string">value1</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">var2:</span> <span class="hljs-string">value2</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="通过roles传递"><a href="#通过roles传递" class="headerlink" title="通过roles传递"></a>通过roles传递</h3><h3 id="通过-Invertory传递"><a href="#通过-Invertory传递" class="headerlink" title="通过 Invertory传递"></a>通过 Invertory传递</h3><p>前面有说过Invertory文件可以定义变量,但是要注意跟inventory参数的区分</p><h2 id="template模块"><a href="#template模块" class="headerlink" title="template模块"></a>template模块</h2><p>主要用来动态生成配置文件.</p><blockquote><p>用于基于Jinja2模板语言处理模板文件。Jinja2模板中可以包含变量和表达式，这些变量将在Ansible运行时根据具体的上下文环境进行替换。<code>template</code> 模块主要用于生成配置文件或其他类型的文本文件，并且将这些文件复制到远程主机上.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">hosts:</span> <span class="hljs-string">webservers</span><br>  <span class="hljs-attr">vars:</span> <span class="hljs-comment"># playbook定义的变量,会被使用到模板上</span><br>    <span class="hljs-attr">http_port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">max_clients:</span> <span class="hljs-number">200</span><br><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Create</span> <span class="hljs-string">nginx</span> <span class="hljs-string">configuration</span> <span class="hljs-string">file</span> <span class="hljs-string">from</span> <span class="hljs-string">template</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">src:</span> <span class="hljs-string">/srv/http/nginx.conf.j2</span> <span class="hljs-comment"># 要使用的jinja2模板</span><br>        <span class="hljs-attr">dest:</span> <span class="hljs-string">/etc/nginx/nginx.conf</span><br>        <span class="hljs-attr">owner:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">group:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">mode:</span> <span class="hljs-string">&#x27;0644&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="task高级用法"><a href="#task高级用法" class="headerlink" title="task高级用法"></a>task高级用法</h2><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p>关键字: <code>when</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">conf</span> <span class="hljs-string">file</span> <span class="hljs-string">to</span> <span class="hljs-string">centos7</span><br>  <span class="hljs-attr">template:</span> <span class="hljs-string">src=files/nginx.conf.c7.j2</span><br>  <span class="hljs-attr">when:</span> <span class="hljs-string">ansible_distribution_major_version</span> <span class="hljs-string">==</span> <span class="hljs-string">&quot;7&quot;</span> <span class="hljs-comment"># when语句为true则执行</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">conf</span> <span class="hljs-string">file</span> <span class="hljs-string">to</span> <span class="hljs-string">centos6</span><br>  <span class="hljs-attr">template:</span> <span class="hljs-string">src=files/nginx.conf.c6.j2</span><br>  <span class="hljs-attr">when:</span> <span class="hljs-string">ansible_distribution_major_version</span> <span class="hljs-string">==</span> <span class="hljs-string">&quot;6&quot;</span><br></code></pre></td></tr></table></figure><h3 id="迭代循环"><a href="#迭代循环" class="headerlink" title="迭代循环"></a>迭代循环</h3><p>关键字: </p><ul><li><p>旧版本: <code>item</code>, <code>with_item</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">some</span> <span class="hljs-string">packages</span><br>  <span class="hljs-attr">yum:</span> <span class="hljs-string">name=&#123;&#123;</span> <span class="hljs-string">item</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">state=present</span><br>  <span class="hljs-attr">with_items:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">memcached</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">php-fpm</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">add</span> <span class="hljs-string">some</span> <span class="hljs-string">groups</span><br>  <span class="hljs-attr">group:</span> <span class="hljs-string">name=&#123;&#123;</span> <span class="hljs-string">item</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">state=present</span><br>  <span class="hljs-attr">with_items:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">group1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">group2</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">add</span> <span class="hljs-string">some</span> <span class="hljs-string">users</span><br>  <span class="hljs-attr">user:</span> <span class="hljs-string">name=&#123;&#123;</span> <span class="hljs-string">item.name</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">group=&#123;&#123;</span> <span class="hljs-string">item.group</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">state=present</span><br>  <span class="hljs-attr">with_items:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;user1&#x27;</span>, <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;group1&#x27;</span> &#125;<br><span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;user2&#x27;</span>, <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;group2&#x27;</span> &#125;<br></code></pre></td></tr></table></figure></li><li><p>新版本: <code>loop</code>,<code>item</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 基本迭代,迭代列表的每一项</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Add</span> <span class="hljs-string">several</span> <span class="hljs-string">users</span><br>  <span class="hljs-attr">ansible.builtin.user:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br>    <span class="hljs-attr">groups:</span> <span class="hljs-string">&quot;wheel&quot;</span><br>  <span class="hljs-attr">loop:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">testuser1</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">testuser2</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">testuser3</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 迭代字典</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Ensure</span> <span class="hljs-string">several</span> <span class="hljs-string">users</span> <span class="hljs-string">have</span> <span class="hljs-string">specific</span> <span class="hljs-string">properties</span><br>  <span class="hljs-attr">ansible.builtin.user:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.key &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br>    <span class="hljs-attr">groups:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.value.groups &#125;&#125;</span>&quot;</span><br>    <span class="hljs-attr">uid:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; item.value.uid &#125;&#125;</span>&quot;</span><br>  <span class="hljs-attr">loop:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; users | dict2items &#125;&#125;</span>&quot;</span> <span class="hljs-comment"># dict2items过滤器将字典转换为项列表</span><br>  <span class="hljs-attr">vars:</span><br>    <span class="hljs-attr">users:</span> <span class="hljs-comment"># dict name</span><br>      <span class="hljs-attr">alice:</span><br>        <span class="hljs-attr">uid:</span> <span class="hljs-number">1001</span><br>        <span class="hljs-attr">groups:</span> <span class="hljs-string">&quot;wheel&quot;</span><br>      <span class="hljs-attr">bob:</span><br>        <span class="hljs-attr">uid:</span> <span class="hljs-number">1002</span><br>        <span class="hljs-attr">groups:</span> <span class="hljs-string">&quot;staff&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="role"><a href="#role" class="headerlink" title="role"></a>role</h1><blockquote><p>是一种组织playbook的方式,可以把复杂的任务拆分成更小的,可复用的文件.类似python的模块,role也可以让ansible代码更加模块化,更容易管理和服用.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建role</span><br>ansible-galaxy init my_role<br></code></pre></td></tr></table></figure><h2 id="目录架构"><a href="#目录架构" class="headerlink" title="目录架构"></a>目录架构</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">my_role/<br>├── defaults<br>│   └── main.yml # 定义变量默认值<br>├── files # 存放role需要复制到目标主机的源文件<br>├── handlers<br>│   └── main.yml # 存放handlers任务,只有被notify触发才会执行<br>├── meta<br>│   └── main.yml # 定义role的元数据(作者信息, 支持平台, 依赖关系等)<br>├── README.md # 项目README<br>├── tasks <br>│   └── main.yml # 定义role要执行的主要任务列表,当角色被引用,这里的任务将会按序执行<br>├── templates # jinjia2模板文件<br>├── tests # 用于存放测试role的文件<br>│   ├── inventory # 列出测试用的主机<br>│   └── test.yml # 测试用playbook (ansible-playbook -i tests/inventory tests/test.yml)<br>└── vars<br>    └── main.yml # 定义变量<br></code></pre></td></tr></table></figure><h2 id="meta-main-yaml-例子"><a href="#meta-main-yaml-例子" class="headerlink" title="meta&#x2F;main.yaml 例子"></a>meta&#x2F;main.yaml 例子</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">galaxy_info:</span> <span class="hljs-comment"># role的相关信息</span><br>  <span class="hljs-attr">author:</span> <span class="hljs-string">your_name</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">Example</span> <span class="hljs-string">role</span> <span class="hljs-string">for</span> <span class="hljs-string">web</span> <span class="hljs-string">server</span> <span class="hljs-string">setup</span><br>  <span class="hljs-attr">company:</span> <span class="hljs-string">Your</span> <span class="hljs-string">Company</span> <span class="hljs-string">(optional)</span><br>  <span class="hljs-attr">license:</span> <span class="hljs-string">MIT</span> <span class="hljs-string">(或你选择的其他许可证)</span><br>  <span class="hljs-attr">min_ansible_version:</span> <span class="hljs-number">2.9</span> <span class="hljs-string">(或其他最小版本要求)</span> <span class="hljs-comment"># ansible版本要求</span><br>  <span class="hljs-attr">platforms:</span> <span class="hljs-comment"># 支持的平台</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">EL</span><br>      <span class="hljs-attr">versions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">7</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">8</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Ubuntu</span><br>      <span class="hljs-attr">versions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">xenial</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">bionic</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">focal</span><br>  <span class="hljs-attr">galaxy_tags:</span>                    <span class="hljs-comment"># 类似于标签，用于在Ansible Galaxy中分类和搜索你的角色</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">web</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">server</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">httpd</span><br><br><span class="hljs-attr">dependencies:</span>                     <span class="hljs-comment"># 如果你的角色依赖于其他角色，则在这里列出</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">other_role</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">role:</span> <span class="hljs-string">conditional_role</span>, <span class="hljs-attr">when:</span> <span class="hljs-string">&quot;some_condition|bool&quot;</span>, <span class="hljs-attr">var1:</span> <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-attr">var2:</span> <span class="hljs-string">&quot;value2&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="default-main-yaml"><a href="#default-main-yaml" class="headerlink" title="default&#x2F;main.yaml"></a>default&#x2F;main.yaml</h2><p>列出kv定义变量和默认值即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nginx_user:</span> <span class="hljs-string">www-data</span><br><span class="hljs-attr">nginx_http_port:</span> <span class="hljs-number">80</span><br><span class="hljs-attr">nginx_configure_default_site:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="handlers-main-yaml"><a href="#handlers-main-yaml" class="headerlink" title="handlers&#x2F;main.yaml"></a>handlers&#x2F;main.yaml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">restarted</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 若需要管理员权限，则设置为true</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">reload</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">reloaded</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="task-main-yaml"><a href="#task-main-yaml" class="headerlink" title="task&#x2F;main.yaml"></a>task&#x2F;main.yaml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">apt:</span> <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">present</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span> <br>    <span class="hljs-attr">src:</span> <span class="hljs-string">nginx.conf.j2</span><br>    <span class="hljs-attr">dest:</span> <span class="hljs-string">/etc/nginx/nginx.conf</span><br>  <span class="hljs-attr">notify:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Ensure</span> <span class="hljs-string">nginx</span> <span class="hljs-string">is</span> <span class="hljs-string">running</span> <span class="hljs-string">(and</span> <span class="hljs-string">enable</span> <span class="hljs-string">it</span> <span class="hljs-string">at</span> <span class="hljs-string">boot)</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">state:</span> <span class="hljs-string">started</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="vars-main-yaml"><a href="#vars-main-yaml" class="headerlink" title="vars&#x2F;main.yaml"></a>vars&#x2F;main.yaml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nginx_version:</span> <span class="hljs-string">&quot;1.14.2&quot;</span><br><span class="hljs-attr">nginx_core_module_settings:</span><br>  <span class="hljs-attr">worker_processes:</span> <span class="hljs-string">&quot;auto&quot;</span><br>  <span class="hljs-attr">worker_connections:</span> <span class="hljs-number">1024</span><br>  <span class="hljs-attr">multi_accept:</span> <span class="hljs-string">&quot;on&quot;</span><br><span class="hljs-attr">nginx_event_module_settings:</span> <span class="hljs-comment"># 嵌套变量,通过&quot;.&quot;表达式引用: &#123;&#123; nginx_event_module_settings.use &#125;&#125;</span><br>  <span class="hljs-attr">use:</span> <span class="hljs-string">&quot;epoll&quot;</span><br></code></pre></td></tr></table></figure><h2 id="playbook引用"><a href="#playbook引用" class="headerlink" title="playbook引用"></a>playbook引用</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">webservers</span><br>  <span class="hljs-attr">become:</span> <span class="hljs-literal">yes</span><br>  <span class="hljs-attr">roles:</span> <span class="hljs-comment"># role可以引用多个,playbook将会按次序执行</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">common</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">application</span><br></code></pre></td></tr></table></figure><h1 id="完整的目录架构"><a href="#完整的目录架构" class="headerlink" title="完整的目录架构"></a>完整的目录架构</h1><p>一个完整的playbook+role的典型目录架构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">playbook-directory/<br>│<br>├── ansible.cfg  # Ansible 配置文件（可选）不存在则使用默认的/etc/ansible/ansible.cfg<br>├── inventory    # 存储库存信息的文件或目录 (可选) 不存在则使用默认的/etc/ansible/hosts<br>│<br>├── group_vars/<br>│   └── group1   # 组1的变量<br>│<br>├── host_vars/<br>│   └── hostname # 特定主机的变量<br>│<br>├── roles/<br>│   ├── role1/   # 第一个 role<br>│   │   ├── defaults/<br>│   │   │   └── main.yml  # role 的默认变量<br>│   │   ├── handlers/<br>│   │   │   └── main.yml  # role 的 handlers<br>│   │   ├── meta/<br>│   │   │   └── main.yml  # role 的元数据<br>│   │   ├── tasks/<br>│   │   │   └── main.yml  # role 的任务列表<br>│   │   ├── templates/<br>│   │   │   └── template.j2  # Jinja2 模版文件<br>│   │   └── vars/<br>│   │       └── main.yml  # role 的其他变量<br>│   │<br>│   └── role2/   # 第二个 role<br>│       ├── defaults/<br>│       ├── handlers/<br>│       ├── meta/<br>│       ├── tasks/<br>│       ├── templates/<br>│       └── vars/<br>│<br>├── site.yml      # 主 playbook 文件<br>├── webservers.yml    # 针对 web 服务器的 playbook<br>└── databases.yml     # 针对数据库服务器的 playbook<br></code></pre></td></tr></table></figure><h1 id="import-playbook"><a href="#import-playbook" class="headerlink" title="import_playbook"></a>import_playbook</h1><p>playbook可以通过import来调用,这就有了上面的<code>主playbook</code></p><p>例如site.yml可以这么写</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">import_playbook:</span> <span class="hljs-string">webservers.yml</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">import_playbook:</span> <span class="hljs-string">databases.yml</span><br></code></pre></td></tr></table></figure><p>ansible会按次序执行webservers.yml和databases.yml两个playbook</p><h1 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h1><p><a href="https://galaxy.ansible.com/ui/">官网</a></p><blockquote><p>在 Ansible 中，共享和使用别人创建的 roles 是一个常见的做法，用于促进可重用性和合作。Ansible 的主要方式是通过 Ansible Galaxy，它是一个共享和寻找 Ansible role 的中心化平台。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible-galaxy install geerlingguy.apache -p /path/to/role<br></code></pre></td></tr></table></figure><h2 id="requirements-yaml"><a href="#requirements-yaml" class="headerlink" title="requirements.yaml"></a>requirements.yaml</h2><p>与python一样,playbook目录可以创建一个<code>requirements.yaml</code>,里面列出需要的role,通过命令一次安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ansible-galaxy install -r requirements.yml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># requirements.yaml</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">src:</span> <span class="hljs-string">geerlingguy.apache</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ansible</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-理论</title>
    <link href="/2024/02/20/k8s-theory/"/>
    <url>/2024/02/20/k8s-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><p>控制平面:</p><p><code>apiserver</code>: 集群的API入口,所有内部通信都通过apiserver,集群控制面前端.</p><p><code>etcd</code>: 分布式键值存储,存储集群配置,状态等数据,是整个集群的最终数据源.</p><p><code>scheduler</code>: 负责调度决策,分配pod到相应的node上.</p><p><code>controller manager</code>: 负责管理控制器(deployment,daemonset,stateful等等).</p><p>工作平面:</p><p><code>kubelet</code>: 在每个节点上,负责管理节点上pod的生命周期</p><p><code>kube-proxy</code>: 节点网络代理,ipvs&#x2F;iptables规则(service)就是它来维护.</p><p><code>core-dns</code>: 集群内的DNS.</p><p>第三方但必须:</p><p><code>CNI</code>: 如calico,负责pod之间的通讯,以及集群内的网络策略(NetworkPolicy)实现.</p><h1 id="重要资源"><a href="#重要资源" class="headerlink" title="重要资源"></a>重要资源</h1><p>k8s里面一切皆资源(resources).</p><p><code>service</code>: 本质上是iptables&#x2F;ipvs转发规则,负责对外暴露服务.</p><p><code>Pod</code>: k8s基本部署单元,包括网络,存储以及如何运行怎么运行容器的规定.</p><p><code>namespace</code>: k8s集群的逻辑隔离分组.</p><p><code>volume</code>: 卷,提供持久化存储能力和共享存储机制.</p><p><code>configmap</code>: 存储配置文件.</p><p><code>secret</code>: 存储机密数据(默认使用base64加密).</p><p><code>控制器</code>: 控制pod的生命周期,不同类型有不同的定义.</p><p>​<code>deployment</code>: pod的副本及更新管理.</p><p>​<code>replicaSet</code>: 保证任何时候都有指定数量的pod副本.</p><p>​<code>StatefulSet</code>: 为有状态应用设计,提供稳定的,唯一的网络标识符,以及稳定的持久化存储和部署顺序保证.</p><p>​<code>DaemonSet</code>: 确保所有(或特定)节点上都运行一个pod副本.</p><p><code>job和CronJob</code>: 用于处理一次性任务和定时任务.</p><p><code>PV和PVC</code>: PV对应实际的物理存储资源,PVC是用户对存储资源的请求.集群会根据PVC自动创建PV.</p><p><code>ingress</code>: 管理外部对集群内部服务的访问,提供http和https路由规则.(有ingress-controller提供).</p><p><code>ResourceQuota</code>: 限制namespace层面的资源.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ResourceQuota</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-quota</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">example-namespace</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hard:</span><br>    <span class="hljs-attr">pods:</span> <span class="hljs-string">&quot;10&quot;</span>  <span class="hljs-comment"># 最大 Pod 数量</span><br>    <span class="hljs-attr">requests.cpu:</span> <span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-comment"># Pod 请求的最大 CPU 总量</span><br>    <span class="hljs-attr">requests.memory:</span> <span class="hljs-string">1Gi</span>  <span class="hljs-comment"># Pod 请求的最大内存总量</span><br>    <span class="hljs-attr">limits.cpu:</span> <span class="hljs-string">&quot;2&quot;</span>  <span class="hljs-comment"># Pod 限制的最大 CPU 总量</span><br>    <span class="hljs-attr">limits.memory:</span> <span class="hljs-string">2Gi</span>  <span class="hljs-comment"># Pod 限制的最大内存总量</span><br></code></pre></td></tr></table></figure><p><code>LimitRange</code>: 限制pod或container层面上的资源大小.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">LimitRange</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-limitrange</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">example-namespace</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">limits:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Pod</span><br>    <span class="hljs-attr">min:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;100m&quot;</span>  <span class="hljs-comment"># 每个 Pod 的最小 CPU 请求量</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;100Mi&quot;</span>  <span class="hljs-comment"># 每个 Pod 的最小内存请求量</span><br>    <span class="hljs-attr">max:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span>  <span class="hljs-comment"># 每个 Pod 的最大 CPU 请求量</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;500Mi&quot;</span>  <span class="hljs-comment"># 每个 Pod 的最大内存请求量</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">Container</span><br>    <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;200m&quot;</span>  <span class="hljs-comment"># 没有指定资源请求的容器的默认 CPU 请求量</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;200Mi&quot;</span>  <span class="hljs-comment"># 没有指定资源请求的容器的默认内存请求量</span><br>    <span class="hljs-attr">defaultRequest:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;150m&quot;</span>  <span class="hljs-comment"># 没有指定资源请求的容器的默认 CPU 限制量</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;150Mi&quot;</span>  <span class="hljs-comment"># 没有指定资源请求的容器的默认内存限制量</span><br>    <span class="hljs-attr">max:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;300m&quot;</span>  <span class="hljs-comment"># 每个容器的最大 CPU 限制量</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;300Mi&quot;</span>  <span class="hljs-comment"># 每个容器的最大内存限制量</span><br></code></pre></td></tr></table></figure><h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><p>是k8s的访问控制机制,有以下四种资源组成:</p><ul><li><code>serviceaccount</code>: sa,可以理解为就是一个用户名,命名空间级资源.</li><li><code>role</code>: 角色,权限赋予给role, 命名空间级资源</li><li><code>clusterrole</code>: 与role一样,但是是集群级的资源 </li><li><code>rolebinding/clusterrolebinding</code>: 负责将sa和role&#x2F;clusterrole关联起来</li></ul><h1 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h1><h2 id="init-pod"><a href="#init-pod" class="headerlink" title="init-pod"></a>init-pod</h2><p>在pod中定义一个先于其他容器启动的小容器,用于在主容器启动前完成一些必要的初始化配置.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">myapp-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">initContainers:</span> <span class="hljs-comment"># 定义一个init-pod,检查myservice ready,ready后init-pod会退出,然后再启动myapp-container</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-myservice</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]<br></code></pre></td></tr></table></figure><p>常见场景:</p><ul><li>启动时进行数据库或缓存的初始化</li><li>下载配置信息</li><li>检查依赖关系</li><li>创建数据卷</li><li>网络初始化</li></ul><h2 id="Pause"><a href="#Pause" class="headerlink" title="Pause"></a>Pause</h2><p>是一个<code>隐蔽但重要</code>的容器,1.19前称为kube-pause,1.19后被合并进kubelet,并改名为PodSandbox.</p><p>负责保持并管理容器的命名空间(这里指的LXC的内核的命名空间),它负责初始化并保持命名空间(比如网络和PID),这样子其他容器就可以在相同的pod中共享这些命名空间.</p><blockquote><ol><li><p><strong>命名空间锚点</strong>：Pause容器创建了网络和PID两个重要的命名空间。这些命名空间为Pod内所有的容器提供了共享的环境和上下文。其它容器在初始化时会加入到Pause容器创建的命名空间中，并在这些共享的空间内运行。</p></li><li><p><strong>Pod级别的生命周期管理</strong>：由于Pause容器是Pod启动时最先创建的容器，其生命周期与Pod一致。即使Pod内的业务容器被重启或崩溃后重启，Pause容器仍然在运行，这样保证了Pod的网络和PID命名空间在容器重启过程中是持久且稳定的。</p></li><li><p><strong>资源共享</strong>：Pause容器为Pod内的其他容器挂载点提供共享的资源，比如卷挂载。这意味着即使业务容器出现重启，共享资源仍然可用，从而保证了容器间资源的持续连贯性。</p></li><li><p><strong>处理僵尸进程</strong>：在Linux中，一个僵尸进程是已经完成但其父进程尚未对其进行回收的进程。Pause容器作为Pod内所有容器的共同父进程，有助于回收这些僵尸进程，从而避免资源泄漏。</p></li><li><p><strong>防止孤立</strong>：如果没有Pause容器，且Pod内的所有业务容器都停止运行了，那么Pod的网络命名空间和PID命名空间可能会失去，这将导致任何重启的容器进入一个全新的环境。Pause容器的存在，使得Pod在其生命周期内始终保持一个稳定的运行环境。</p></li></ol></blockquote><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="Secret的安全性"><a href="#Secret的安全性" class="headerlink" title="Secret的安全性"></a>Secret的安全性</h2><p>Secret是用来存储敏感数据的资源,本质上<code>一种特殊的卷</code>,但是默认情况下,secret只是将数据做了base64加密,假如数据被截获,敏感数据依旧可以轻松被获取.因此针对secret有一些额外的安全补充手段:</p><ol><li>通过<code>RBAC</code>和<code>网络策略</code>对secret进行访问控制</li><li><code>定期轮换</code>secret</li><li>secret可以存放在<code>第三方密钥管理工具</code>,比如AWS 的secret manager等,如果存放在etcd,可以对<code>etcd配置加密</code>(支持多种加密算法).</li><li>secret之间的传输使用<code>mTLS</code>.</li><li><code>禁止硬编码</code>,包括在日志打印中显示也要避免.</li></ol><h1 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h1><h2 id="容器间通讯"><a href="#容器间通讯" class="headerlink" title="容器间通讯"></a>容器间通讯</h2><p>同一个pod内多个容器<code>共享网络命名空间</code>,通过<code>L0环回口</code>通讯</p><h2 id="相同节点pods间通讯"><a href="#相同节点pods间通讯" class="headerlink" title="相同节点pods间通讯"></a>相同节点pods间通讯</h2><h2 id="不同节点pods间通讯"><a href="#不同节点pods间通讯" class="headerlink" title="不同节点pods间通讯"></a>不同节点pods间通讯</h2><p>k8s规定所有pod都要运行在<code>同一个扁平的没有nat转换的网络中</code>,物理上pod可以运行在不同的节点上,但是看起来他们就像运行同一个<code>局域网</code>中.实现这个要求的就是<code>CNI</code>,当pod创建或销毁时,CNI就负责pod的网络配置,比如分配ip,配置路由等.</p><p>不同的CNI的实现方式不一样,以主流的fannel和calico为例:</p><h3 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h3><p>Flannel主要支持两种后端:</p><ul><li><p>VxLan(默认)</p><p>类似VPN,在两个pod之间建立虚拟的网络隧道实现通讯.是一种在<code>3层网络</code>上通过封装原始数据包来创建一个<code>虚拟的2层网络</code>来实现的点对点通讯.</p><blockquote><p>工作方式：VXLAN 使用 UDP 数据包来封装和转发原始的以太网帧。每个主机以 VTEP（VXLAN Tunnel Endpoint）的身份运行，负责封装和解封装从 Pods 发出或发送到 Pods 的数据包。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240313222411556.png" srcset="/img/loading.gif" lazyload alt="image-20240313222411556"></p></li></ul><p>​缺点: 隧道通讯,多层封装,开销大</p><ul><li><p>Host-GW</p><p>Flannel在初始化时会被分配一个大的IP段,然后会自动将这个大IP段分割成多个小的子网块,这些子网会分配给各个节点.每个节点上维护一个<code>静态路由表</code>.</p><p>每个节点的pod都在独自的网段中,通过静态路由到达目标节点的网段,从而到达目标pod.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240313224650354.png" srcset="/img/loading.gif" lazyload alt="image-20240313224650354"></p></li></ul><h3 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h3><p>默认与Flannel的host-GW类似,不过Calico使用的是<code>动态路由协议(BGP)</code>来维护和更新路由表.</p><p>另外Calico也支持VxLan模式的封装.</p><h3 id="Flannel-VS-Calico"><a href="#Flannel-VS-Calico" class="headerlink" title="Flannel  VS Calico"></a>Flannel  VS Calico</h3><table><thead><tr><th></th><th>Calico</th><th>Flannel</th></tr></thead><tbody><tr><td>实现方式</td><td>1. VxLan(默认)<br />2. Host-GW静态路由</td><td>1. 动态路由协议<br />2. 支持VxLan</td></tr><tr><td>性能</td><td>默认使用隧道,性能差</td><td>默认直接使用路由,性能等同主机网络</td></tr><tr><td>网络策略</td><td>不支持</td><td>支持</td></tr><tr><td>配置管理</td><td>简单</td><td>复杂,粒度细</td></tr></tbody></table><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h3><p>Service本质上是<code>kube-proxy管理的一系列iptables/ipvs规则</code>,其Cluster-IP(本质上是一个虚拟IP)实际上是<code>kube-controller-manager</code>负责管理提供.给集群内部的其他组件使用访问后端的一组pod.</p><p>当一个pod试图通信到一个service的Cluster-IP,kube-proxy会介入数据流,从service绑定的endpoint中选择合适的后端Pod进行流量转发.因为kube-proxy使用iptables&#x2F;ipvs规则实现流量转发,不涉及用户空间,所以性能优秀.</p><p>core-dns也会给每个svc绑定一个域名,映射对应的clusterIP</p><h3 id="Headless"><a href="#Headless" class="headerlink" title="Headless"></a>Headless</h3><p>当使用Headless类型的service时,service只会绑定一个域名,而不会分配IP.</p><p>pod访问其域名,core-DNS返回的是一个<code>所有后端Pod IP的列表</code></p><p>客户端需要使用返回的IP列表选择一个或多个来通信,也可以自行实现负载均衡去访问.</p><p>通常与<code>statefulset</code>一同使用,此时每个statefulset的pod都会有一个<code>独立的</code>网络标识和持久化存储.</p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-监控与日志</title>
    <link href="/2024/02/16/k8s-monitor-2/"/>
    <url>/2024/02/16/k8s-monitor-2/</url>
    
    <content type="html"><![CDATA[<h1 id="外部Prometheus"><a href="#外部Prometheus" class="headerlink" title="外部Prometheus"></a>外部Prometheus</h1><blockquote><p>关于prometheus监控k8s集群的方案可以看看:</p><ul><li><a href="https://yunlzheng.gitbook.io/prometheus-book/part-iii-prometheus-shi-zhan/readmd">prometheus-book</a></li><li><a href="https://anthing.cn/2023/03/20/k8s-monitor/">这篇文章</a></li></ul><p>以上两篇参考都是将prometheus部署在<code>集群内</code>为前提,本文是将Prometheus部署在<code>集群外部</code>,主要参考了:</p><ul><li><a href="https://www.cnblogs.com/ygbh/p/17328667.html#_label4">这篇博客</a></li><li>和ChatGPT-4</li></ul></blockquote><h2 id="kube-state-metrics"><a href="#kube-state-metrics" class="headerlink" title="kube-state-metrics"></a>kube-state-metrics</h2><blockquote><p>用于生成关于 Kubernetes 对象状态的广泛指标。它从 Kubernetes API 获取元数据，然后转化成Prometheus指标格式以供Prometheus等监控系统使用。它生成的是”静态”数据，例如一个Deployment有多少副本正在运行，一个Service有多少个Endpoints，等等。跟<code>metrics-server</code>是两个不同的东西,作用场景野不一样.</p><ul><li><strong>kube-state-metrics</strong> 不能提供HPA和VPA所需的实时资源使用数据。</li><li><strong>metrics-server</strong> 不像<code>kube-state-metrics</code>那样提供关于Kubernetes对象状态的丰富指标。</li></ul></blockquote><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需要魔法</span><br>helm repo add prometheus-community https://prometheus-community.github.io/helm-charts<br>helm repo update<br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉到本地</span><br>helm pull prometheus-community/kube-state-metrics <br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改镜像源使用代理(因为kubelet不能直接使用系统代理下载镜像)</span><br>sed -i &quot;+registry.k8s.io+k8s.dockerproxy.com+&quot; kube-state-metrics/values.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装</span><br>helm install kube-state-metrics ./kube-state-metrics/<br><span class="hljs-meta prompt_"># </span><span class="language-bash">由于Prometheus在集群的外部,所以需要部署个ingress将kube-state-metrics的api暴露出来</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果是生产环境最好配置https</span><br>cat &gt; kube-state-metrics-ingress.yaml &lt;&lt;EOF<br>apiVersion: networking.k8s.io/v1<br>kind: Ingress<br>metadata:<br>  name: kube-state-metrics-ingress<br>  namespace: default<br>  annotations:<br>    kubernetes.io/ingress.class: &quot;nginx&quot;<br>spec:<br>  rules:<br>  - http:<br>      paths:<br>      - path: /metrics<br>        pathType: ImplementationSpecific<br>        backend:<br>          service:<br>            name: kube-state-metrics<br>            port:<br>              number: 8080<br>EOF<br>kubectl apply -f kube-state-metrics-ingress<br></code></pre></td></tr></table></figure><blockquote><p>默认kube-state-metrics使用本地存储(应该都是些监控数据,部署prometheus获取后会存在prometheus中,所以应该不重要)且副本数为1,生产环境中部署要注意修改.</p></blockquote><h2 id="prometheus和grafana配置"><a href="#prometheus和grafana配置" class="headerlink" title="prometheus和grafana配置"></a>prometheus和grafana配置</h2><p>prometheus配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">k8s-kube-state-metrics-peter-cluster</span><br>  <span class="hljs-attr">honor_timestamps:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/metrics</span><br>  <span class="hljs-attr">scheme:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;&lt;ip&gt;:&lt;port&gt;&#x27;</span>]<br>  <span class="hljs-attr">metric_relabel_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">cluster</span><br>    <span class="hljs-attr">replacement:</span> <span class="hljs-string">peter-cluster</span><br></code></pre></td></tr></table></figure><p>grafana使用dashboard: <a href="https://grafana.com/grafana/dashboards/13332-kube-state-metrics-v2/">kube-state-metrics-v2</a></p><p>接下来就是grafana的数据源,每个图表的promql等微调了(全是图形界面).</p><p>kube-state-metrics的metrics非常丰富,上面的dashboard只是用到一小部分,实际使用要根据具体环境自己创建dashboard.</p><h2 id="原生metrics"><a href="#原生metrics" class="headerlink" title="原生metrics"></a>原生metrics</h2><p>k8s原生组件自带metrics API,下面以API-server为例子,演示如何通过<code>TLS</code>联通<code>外部的</code>Prometheus:</p><ol><li><p>要使外部的Prometheus可以安全访问首先要给它创建SA,绑定token并授权</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-monitor-sa</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">prometheus</span> <span class="hljs-comment"># SA是namespace级资源,为了好区分,我给它额外创建了个promethes的namespace</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-monitor-cr</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">nodes/proxy</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">pods/proxy</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">nodes/metrics</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">services</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">endpoints</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">pods</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ingresses</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">configmaps</span><br>    <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">get</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;extensions&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;networking.k8s.io&quot;</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ingresses/status</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ingresses</span><br>    <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">get</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">nonResourceURLs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/metrics&quot;</span><br>    <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">get</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-monitor-crb</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-monitor-sa</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-monitor-cr</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-monitor-tk</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">prometheus</span> <span class="hljs-comment"># secret是namespace级资源,为了好区分,我给它额外创建了个promethes的namespace</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/service-account.name:</span> <span class="hljs-string">prometheus-monitor-sa</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/service-account-token</span><br></code></pre></td></tr></table></figure></li><li><p>生成token文件并传到prometheus服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get secrets -n prometheus prometheus-monitor-tk -o jsonpath=&quot;&#123;.data.token&#125;&quot; | base64 --decode &gt; prometheus.token<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后scp传过去</span><br></code></pre></td></tr></table></figure></li><li><p>除了token文件,ca证书也要传过去: <code>/etc/kubernetes/pki/ca.crt</code></p></li><li><p>配置Prometheus</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">kubernetes-apiservers</span><br>  <span class="hljs-comment"># k8s自动发现</span><br>  <span class="hljs-attr">kubernetes_sd_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">endpoints</span><br>    <span class="hljs-attr">api_server:</span> <span class="hljs-string">https://&lt;api-server_ip&gt;:&lt;api-server_port&gt;</span><br>    <span class="hljs-attr">bearer_token_file:</span> <span class="hljs-string">/root/prometheus/pki/prometheus.token</span><br>    <span class="hljs-attr">tls_config:</span><br>      <span class="hljs-attr">ca_file:</span> <span class="hljs-string">/root/prometheus/pki/ca.crt</span><br>      <span class="hljs-comment"># 由于使用的是自签证书所以要skip_verify</span><br>      <span class="hljs-attr">insecure_skip_verify:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">relabel_configs:</span><br>  <span class="hljs-comment"># 根据regex正则匹配下面的source_labels,匹配上的就keep(保留下来写入Prometheus)</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">keep</span><br>    <span class="hljs-attr">regex:</span> <span class="hljs-string">.+;kubernetes;https</span><br>    <span class="hljs-comment"># 使用k8s自动发现获取的metrics,Prometheus会给它添加上一些labels,这里是根据这些labels做了些过滤</span><br>    <span class="hljs-attr">source_labels:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">__meta_kubernetes_namespace</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">__meta_kubernetes_service_name</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">__meta_kubernetes_endpoint_port_name</span><br>  <span class="hljs-attr">scheme:</span> <span class="hljs-string">https</span><br>  <span class="hljs-attr">bearer_token_file:</span> <span class="hljs-string">/root/prometheus/pki/prometheus.token</span><br>  <span class="hljs-attr">tls_config:</span><br>    <span class="hljs-attr">insecure_skip_verify:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="常用metrics"><a href="#常用metrics" class="headerlink" title="常用metrics"></a>常用metrics</h3><p>ChatGPT-4生成:</p><blockquote><p>kube-apiserver:</p><ul><li><strong>apiserver_request_total</strong>: API 服务器处理的请求数量。</li><li><strong>apiserver_request_duration_seconds</strong>: 请求的处理时间。</li><li><strong>apiserver_client_certificate_expiration_seconds</strong>: 客户端证书的过期时间大小。</li></ul><p>etcd: </p><ul><li><strong>etcd_request_duration_seconds</strong>: ETCD 存储请求的延迟时间。</li><li><strong>etcd_disk_wal_fsync_duration_seconds</strong>: 写入和同步预写日志文件操作所花费的时间。</li><li><strong>etcd_network_client_grpc_received_bytes_total</strong>: 通过 gRPC 接收的字节总数。</li></ul><p>kube-controller-manager:</p><ul><li><strong>workqueue_depth</strong>: 工作队列的深度。</li><li><strong>workqueue_adds_total</strong>: 添加到工作队列的总项目数。</li><li><strong>controller_runtime_reconcile_time_seconds</strong>: 控制器中 reconcile 方法的耗时。</li></ul><p>kube-scheduler:</p><ul><li><strong>scheduler_e2e_scheduling_duration_seconds</strong>: 调度程序从开始调度到完成调度的时间。</li><li><strong>scheduler_schedule_attempts_total</strong>: 调度尝试的总数，按结果进行分类。</li><li><strong>scheduler_pod_preemption_victims</strong>: 每次抢占事件中的受害者 pod 数量。</li></ul></blockquote><h1 id="内部Prometheus"><a href="#内部Prometheus" class="headerlink" title="内部Prometheus"></a>内部Prometheus</h1><h2 id="使用deployment部署"><a href="#使用deployment部署" class="headerlink" title="使用deployment部署"></a>使用deployment部署</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-config</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">monitoring</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">prometheus.yml:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    global:</span><br><span class="hljs-string">      scrape_interval:     15s</span><br><span class="hljs-string">      evaluation_interval: 15s</span><br><span class="hljs-string">    scrape_configs:</span><br><span class="hljs-string">      - job_name: &#x27;prometheus&#x27;</span><br><span class="hljs-string">        static_configs:</span><br><span class="hljs-string">        - targets: [&#x27;localhost:9090&#x27;]</span><br><span class="hljs-string">      - job_name: k8s-kube-state-metrics-peter-cluster</span><br><span class="hljs-string">        honor_timestamps: true</span><br><span class="hljs-string">        metrics_path: /metrics</span><br><span class="hljs-string">        scheme: http</span><br><span class="hljs-string">        static_configs:</span><br><span class="hljs-string">        # 与kube-state-metrics不同namespace,跨namespace访问要写全域名</span><br><span class="hljs-string">          - targets: [&#x27;kube-state-metrics.default.svc.cluster.local:8080&#x27;]</span><br><span class="hljs-string">        metric_relabel_configs:</span><br><span class="hljs-string">        - target_label: cluster</span><br><span class="hljs-string">          replacement: peter-cluster</span><br><span class="hljs-string"></span><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-deployment</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">monitoring</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">prometheus</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">prometheus</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus:v2.31.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9090</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/prometheus</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-config</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">monitoring</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9090</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9090</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">prometheus</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-ingress</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">monitoring</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">prometheus-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">9090</span><br></code></pre></td></tr></table></figure><h2 id="Prometheus-Operator"><a href="#Prometheus-Operator" class="headerlink" title="Prometheus-Operator"></a>Prometheus-Operator</h2><h3 id="CRD"><a href="#CRD" class="headerlink" title="CRD"></a>CRD</h3><p>在了解Operator之前,先来了解一下CRD(CustomResourceDefinition).</p><blockquote><ol><li><p>想象k8s是一个可扩展的积木系统,那么它原有的积木类型(内置资源类型)有:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-string">Pod</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Service</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Deployment</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>就是客制化定义一个新的资源类型,比如定义一个prometheus资源类型</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 通过 CRD 定义一个新的&quot;积木类型&quot; - Prometheus</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apiextensions.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CustomResourceDefinition</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">prometheuses.monitoring.coreos.com</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># 定义这个&quot;新积木&quot;的规格</span><br>  <span class="hljs-attr">group:</span> <span class="hljs-string">monitoring.coreos.com</span><br>  <span class="hljs-attr">names:</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">Prometheus</span>    <span class="hljs-comment"># 新资源类型的名字</span><br>    <span class="hljs-attr">plural:</span> <span class="hljs-string">prometheuses</span><br>  <span class="hljs-attr">scope:</span> <span class="hljs-string">Namespaced</span><br>  <span class="hljs-attr">versions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>      <span class="hljs-attr">served:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">schema:</span><br>        <span class="hljs-comment"># 定义这个&quot;新积木&quot;可以有哪些属性</span><br>        <span class="hljs-attr">openAPIV3Schema:</span><br>          <span class="hljs-attr">properties:</span><br>            <span class="hljs-attr">spec:</span><br>              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span><br>              <span class="hljs-attr">properties:</span><br>                <span class="hljs-attr">replicas:</span><br>                  <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>                <span class="hljs-attr">version:</span><br>                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br></code></pre></td></tr></table></figure></li><li><p>CRD从创建到可用大概过程</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">步骤</span> <span class="hljs-attr">1:</span> <span class="hljs-string">注册新的&quot;积木类型&quot;</span><br><span class="hljs-string">┌────────────────┐</span><br><span class="hljs-string">│</span> <span class="hljs-string">提交</span> <span class="hljs-string">CRD</span> <span class="hljs-string">定义</span>   <span class="hljs-string">│</span><br><span class="hljs-string">└────────────────┘</span><br>        <span class="hljs-string">↓</span><br><span class="hljs-string">步骤</span> <span class="hljs-attr">2:</span> <span class="hljs-string">API</span> <span class="hljs-string">Server</span> <span class="hljs-string">处理</span> <span class="hljs-string">(等待Kubernetes完全理解和接受这个新类型)</span><br><span class="hljs-string">┌─────────────────────┐</span><br><span class="hljs-string">│</span> <span class="hljs-bullet">-</span> <span class="hljs-string">验证定义</span>          <span class="hljs-string">│</span><br><span class="hljs-string">│</span> <span class="hljs-bullet">-</span> <span class="hljs-string">创建新的</span> <span class="hljs-string">API</span> <span class="hljs-string">端点</span>  <span class="hljs-string">│</span><br><span class="hljs-string">│</span> <span class="hljs-bullet">-</span> <span class="hljs-string">设置数据存储</span>      <span class="hljs-string">│</span><br><span class="hljs-string">└─────────────────────┘</span><br>        <span class="hljs-string">↓</span><br><span class="hljs-string">步骤</span> <span class="hljs-attr">3:</span> <span class="hljs-string">CRD</span> <span class="hljs-string">变为可用状态</span><br><span class="hljs-string">┌────────────────────┐</span><br><span class="hljs-string">│</span> <span class="hljs-string">现在可以创建新类型</span>  <span class="hljs-string">│</span><br><span class="hljs-string">└────────────────────┘</span><br></code></pre></td></tr></table></figure></li></ol></blockquote><h3 id="CR"><a href="#CR" class="headerlink" title="CR"></a>CR</h3><p>可以这么理解CRD是类,CR则是类的具体实例.</p><h1 id="日志收集方案"><a href="#日志收集方案" class="headerlink" title="日志收集方案"></a>日志收集方案</h1><h2 id="技术栈选择"><a href="#技术栈选择" class="headerlink" title="技术栈选择"></a>技术栈选择</h2><p><code>elasticsearch+logstash+kibana</code>: 是最著名的日志收集方案,但是elasticsearch和kibana在新版本中都推出企业lic,不能免费使用它的全功能,所以要么使用旧版本,要么只使用它的部分功能,要么给钱.至于logstash,则有不少更轻量或更新的替代产品,比如loki,Fluentd等,都是开源的.这方面的选择就比较多.</p><p><code>Prometheus+grafana+loki</code>: 比较适合中小型集群,这个技术栈的特点是全开源且轻量,还能直接集成监控系统.</p><p><code>opensearch+logstash</code>: opensearch是AWS发起的,旨在完全兼容elasticsearch功能的开源工具,它取自elasticsearch+kibana的分支,诞生在elasticsearch+kibana不再完全开源免费之后.自带一个opensearch dashboard可以替代kibana功能.性能上还比不上elasticsearch.但是如果你希望免费部署日志收集系统,可以接受一部分的性能下降,这是个很不错的选择,AWS云也有使用opensearch的公共服务.</p><blockquote><p>日志代理有很多选择: logstash&#x2F;loki&#x2F;Fluentd&#x2F;Filebeat&#x2F;…</p></blockquote><h2 id="日志收集等级"><a href="#日志收集等级" class="headerlink" title="日志收集等级"></a>日志收集等级</h2><p>k8s支持三种不同等级的日志收集方式</p><p><code>sidecar</code>: 在每个pod之内额外部署一个log agent的容器作为sidecar运行,收集日志数据,将日志发送到es&#x2F;opensearch等日志存储系统.</p><p><code>节点级</code>: 在每个节点上部署一个日志代理(Fluentd&#x2F;Filebeat等),通常以daemonset的方式部署,收集的日志信息发送到集群外部的日志存储系统.</p><p><code>集群级</code>: 就是把日志收集系统全部部署在集群内部,以获取最及时的日志数据.(比如你的集群部署在海外,如果把日志存储分析系统部署在国内,数据传输就会消耗一定时间).</p><blockquote><p>三种级别的日志收集方式需要根据实际,选择使用,或者组合使用.</p></blockquote><h2 id="EFK"><a href="#EFK" class="headerlink" title="EFK"></a>EFK</h2><p>用<code>Fluentd</code>替代了<code>Logstage</code>.</p><p>Fluentd的主要特点有:</p><ul><li>插件化架构,拥有丰富的插件生态系统,通过不同插件实现收集,过滤,缓冲和输出的不同功能</li><li>使用内存和文件基础的缓冲区机制,保护数据免受网络问题和宕机影响</li><li>CNCF云原生项目</li></ul><p>Fluentd的配置文件语法:</p><blockquote><ul><li>fluentd的配置使用自己的标记语言编写,借鉴了XML的某些视觉元素,但不是XML.</li><li>使用<tag>来表示配置开始</tag>表示配置结束</li><li>配置文件以<code>.conf</code>为后缀,其内容包括:<ul><li>指令: <source>,<match>,<filter>等</li><li>参数: 缩进的键值对</li><li>注释: <code>#</code></li></ul></li></ul><p><code>&lt;source&gt;</code>: 指定日志数据来自何处</p><p><code>&lt;match&gt;</code>和<code>&lt;filter&gt;</code>指定如何处理这些数据</p></blockquote><p>Fluentd VS Logstage:</p><ul><li>Fluentd更轻量,默认配置配置下使用更少的内存资源</li><li>Logstash提供更多的过滤器和插件,可以处理更复杂的数据逻辑</li><li>Fluentd更容易上手</li></ul><h3 id="部署ES-Kibana"><a href="#部署ES-Kibana" class="headerlink" title="部署ES+Kibana"></a>部署ES+Kibana</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create ns nfk<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">elasticsearch</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">elasticsearch</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span> <span class="hljs-comment"># 创建一个headless service,通过service的dns即可获取集群所有节点ip</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9200</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">rest</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9300</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">inner</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">es</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">elasticsearch</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">elasticsearch</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">elasticsearch</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">initContainers:</span> <span class="hljs-comment"># 起两个init-pod负责初始化系统参数</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">increase-vm-max-map</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">&quot;IfNotPresent&quot;</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sysctl&quot;</span>, <span class="hljs-string">&quot;-w&quot;</span>, <span class="hljs-string">&quot;vm.max_map_count=262144&quot;</span>]<br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">increase-fd-ulimit</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;ulimit -n 65536&quot;</span>]<br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.elastic.co/elasticsearch/elasticsearch:7.17.1</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">&quot;IfNotPresent&quot;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">rest</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9200</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">inner</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9300</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">1000m</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">1000m</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/elasticsearch/data</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cluster.name</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">k8s-logs</span> <span class="hljs-comment"># es-cluster-name</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">node.name</span><br>          <span class="hljs-attr">valueFrom:</span><br>            <span class="hljs-attr">fieldRef:</span><br>              <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cluster.initial_master_nodes</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;es-0,es-1,es-2&quot;</span> <span class="hljs-comment"># &lt;sts-name&gt;-&lt;num&gt;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">discovery.zen.minimum_master_nodes</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;2&quot;</span> <span class="hljs-comment"># node/2-1</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">discovery.seed_hosts</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;elasticsearch&quot;</span> <span class="hljs-comment"># 填写es的svc-name,因为在同一个namespace所以不需要写full DNS</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ES_JAVA_OPTS</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;-Xms512m -Xmx512m&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">network.host</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">elasticsearch</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">openebs-hostpath</span> <span class="hljs-comment"># 按实际填写</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span> <span class="hljs-comment"># 按需填写</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kibana-config</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kibana</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">kibana.yml:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    server.name: kibana</span><br><span class="hljs-string">    server.host: &quot;0.0.0.0&quot;</span><br><span class="hljs-string">    i18n.locale: zh-CN                      #设置默认语言为中文</span><br><span class="hljs-string">    elasticsearch:</span><br><span class="hljs-string">      hosts: $&#123;ELASTICSEARCH_HOSTS&#125;         #es集群连接地址</span><br><span class="hljs-string"></span><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kibana</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">5601</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kibana</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">kibana</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">kibana</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">docker.elastic.co/kibana/kibana:7.17.1</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">&quot;IfNotPresent&quot;</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">1000m</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">1000m</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ELASTICSEARCH_URL</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">http://elasticsearch:9200</span>                 <span class="hljs-comment">#设置为handless service dns地址即可</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ELASTICSEARCH_HOSTS</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">http://elasticsearch:9200</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5601</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/kibana/config/kibana.yml</span>     <span class="hljs-comment">#kibana配置文件挂载地址</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">subPath:</span> <span class="hljs-string">kibana.yml</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config</span>             <span class="hljs-comment"># 跟上面得volumeMounts名称匹配</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">kibana-config</span><br></code></pre></td></tr></table></figure><h3 id="部署Fluented"><a href="#部署Fluented" class="headerlink" title="部署Fluented"></a>部署Fluented</h3><p>首先配置Fluented的配置文件,在EFK中这一步最为复杂,需要定义如何获取日志,如何处理日志,以及输出到哪里.</p><p>以下示例分三个配置文件,收集k8s集群内容器的日志文件:</p><ol><li><p>system.conf</p><blockquote><p>配置Fluentd的系统级参数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;system&gt;<br>  root_dir /tmp/fluentd-buffers/ <span class="hljs-comment"># fluentd使用的根目录,这是fluentd运行时临时文件的总目录</span><br>&lt;/system&gt;<br></code></pre></td></tr></table></figure></li><li><p>containers.input.conf</p><blockquote><p>以下配置文件定义了一些列规则,用于从k8s容器中收集,处理和过滤日志,主要操作有:</p><p>**日志收集:**使用tail插件监控特定路径下的日志文件</p><p>**异常检测和处理:**使用<code>detect_exceptions</code>插件来识别和处理多行异常信息</p><p>**日志连接与过滤:**使用<code>concat</code>插件将多行日志合并成单个事件,使用<code>grep</code>插件根据标签过滤日志</p><p>**元数据添加:**使用k8s元数据插件来添加有关k8s环境的信息</p><p>**日志清理:**移除日志中不必要的字段</p><p>**日志解析改善:**使用<code>parser</code>插件进一步解析日志记录中的json字段,如果无法解析则保留原数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;source&gt; <span class="hljs-comment"># 定义数据输入开始的标签</span><br><span class="hljs-meta">  @id fluentd-containers.log </span><span class="hljs-comment"># &quot;@id&quot;用于定义这个&lt;source&gt;配置的唯一标识符,相当于给这段&lt;source&gt;命名,方便日后管理和调试</span><br><span class="hljs-meta">  @type tail </span><span class="hljs-comment"># &quot;@type&quot;用于指定使用的插件,这里使用&quot;tail&quot;插件用于追踪日志文件的增长,并持续读取新增内容                      </span><br>  path /var/log/containers/*.log <span class="hljs-comment"># &quot;path&quot;使用路径模式指向一个日志文件,意味着fluentd会监听该路径下所有的.log文件,并读取其内容          </span><br>  pos_file /var/log/es-containers.log.pos <span class="hljs-comment"># &quot;pos_file&quot;用于指定一个文件,该文件用来记录fluentd已经读取日志数据到哪个点,重启后也能从上次停止的位置开始读取</span><br>  tag raw.kubernetes.* <span class="hljs-comment"># &quot;tag&quot;用于给&lt;source&gt;输入的日志打标签,所有以这个&lt;source&gt;为源输入的日志都会以&quot;raw.kubernetes.&quot;开头                   </span><br>  read_from_head true <span class="hljs-comment"># 首次读取日志文件时,是否从头开始读取数据</span><br>  &lt;parse&gt;  <span class="hljs-comment"># &lt;parse&gt;配置块定义如何解析读取的数据,即数据的格式化方式                               </span><br><span class="hljs-meta">    @type multi_format </span><span class="hljs-comment"># 使用&quot;multi_format&quot;解析器插件,支持多格式解析     </span><br>    <span class="hljs-comment"># 下面两个&quot;&lt;pattern&gt;&quot;指定两种不同的日志格式和对应的解析方法</span><br>    &lt;pattern&gt; <span class="hljs-comment"># 第一个模式指定使用json解释器   </span><br>      <span class="hljs-built_in">format</span> json                       <br>      time_key time  <span class="hljs-comment"># 指定json中哪个字段表示日志时间                     </span><br>      time_format %Y-%m-%dT%H:%M:%S.%NZ  <span class="hljs-comment"># 定义这个时间字段的格式 </span><br>    &lt;/pattern&gt;<br>    &lt;pattern&gt; <span class="hljs-comment"># 第二个模式使用正则表达式解析不是json的日志行</span><br>      <span class="hljs-built_in">format</span> /^(?&lt;time&gt;.+) (?&lt;stream&gt;stdout|stderr) [^ ]* (?&lt;log&gt;.*)$/ <span class="hljs-comment"># 使用命名捕获提取time和stream(标准输出和标准错误),以及日志消息log本身</span><br>      time_format %Y-%m-%dT%H:%M:%S.%N%:z <span class="hljs-comment"># 同样定义时间字段的格式</span><br>    &lt;/pattern&gt;<br>  &lt;/parse&gt;<br>&lt;/source&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在日志输出中检测异常，并将其作为一条日志转发</span><br><span class="hljs-comment"># https://github.com/GoogleCloudPlatform/fluent-plugin-detect-exceptions</span><br>&lt;<span class="hljs-keyword">match</span> raw.kubernetes.**&gt;           <span class="hljs-comment"># &lt;match&gt;块匹配tag为raw.kubernetes.**开头的日志信息</span><br><span class="hljs-meta">  @id raw.kubernetes</span><br><span class="hljs-meta">  @type detect_exceptions           </span><span class="hljs-comment"># 使用detect-exceptions插件处理异常栈信息,它可以自动识别多行的异常堆栈跟踪，并将其作为单个日志事件进行聚合</span><br>  remove_tag_prefix raw             <span class="hljs-comment"># remove_tag_prefix删除指定前缀(raw)</span><br>  message log <span class="hljs-comment"># message参数定义存储日志消息的字段名称,这里是(log)</span><br>  stream stream <span class="hljs-comment"># stream参数定义将会存储&quot;stdout&quot;或&quot;sederr&quot;这样的流字段(stream)</span><br>  multiline_flush_interval <span class="hljs-number">5</span> <span class="hljs-comment"># 设置检测到异常后,在强制刷新前等待的最大秒数.如果在5秒内没有接收到新的日志行,插件会发送当前缓冲的日志事件</span><br>  max_bytes <span class="hljs-number">500000</span> <span class="hljs-comment"># 限制单个异常事件可包含的最大字节数</span><br>  max_lines <span class="hljs-number">1000</span> <span class="hljs-comment"># 控制单个异常事件可包含的最大行数</span><br>&lt;/<span class="hljs-keyword">match</span>&gt;<br>   <br>&lt;<span class="hljs-built_in">filter</span> **&gt;  <span class="hljs-comment"># 匹配所有日志</span><br><span class="hljs-meta">  @id filter_concat</span><br><span class="hljs-meta">  @type concat                </span><span class="hljs-comment"># 指定concat过滤器插件,将日志事件中分散的多行信息连接为一个单独的日志事件</span><br>  key message <span class="hljs-comment"># key指定要处理并连接为多行信息的字段名称(message)</span><br>  multiline_end_regexp /\n$/  <span class="hljs-comment"># 指定一个正则,用来确定何时结束一个消息,并且可以将分散的行连接起来.这里指定&quot;\n$&quot;结尾的换行符.这里意味着每当一行以换行符结束,就为认为是一个消息的结束</span><br>  separator <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># separator定义多行消息连接时使用的分隔符</span><br>&lt;/<span class="hljs-built_in">filter</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;<span class="hljs-built_in">filter</span> kubernetes.**&gt; <span class="hljs-comment"># 过滤器匹配所有kubernetes.**开头的标签</span><br><span class="hljs-meta">     @id filter_kubernetes_metadata</span><br><span class="hljs-meta">     @type kubernetes_metadata </span><span class="hljs-comment"># 这个插件可以从k8s API中补充和丰富日志记录的元数据</span><br>   &lt;/<span class="hljs-built_in">filter</span>&gt;<br>   <br>   <span class="hljs-comment"># 修复 ES 中的 JSON 字段</span><br>   <span class="hljs-comment"># 插件地址：https://github.com/repeatedly/fluent-plugin-multi-format-parser</span><br>   &lt;<span class="hljs-built_in">filter</span> kubernetes.**&gt;<br><span class="hljs-meta">     @id filter_parser</span><br><span class="hljs-meta">     @type parser                </span><span class="hljs-comment"># 指定parser过滤器类型,用于解析日志中的指定字段</span><br>     key_name log                <span class="hljs-comment"># 指定过滤器要解析的字段名称(log)</span><br>     reserve_data true           <span class="hljs-comment"># 是否在解析后保留日志记录中的原始数据</span><br>     remove_key_name_field true  <span class="hljs-comment"># log字段解析成功后是否从记录中移除</span><br>     &lt;parse&gt;<br><span class="hljs-meta">       @type multi_format</span><br>       &lt;pattern&gt; <span class="hljs-comment"># 定义了两种模式</span><br>         <span class="hljs-built_in">format</span> json <span class="hljs-comment"># 第一种是json,它会尝试把日志按照json格式解析</span><br>       &lt;/pattern&gt;<br>       &lt;pattern&gt;<br>         <span class="hljs-built_in">format</span> none <span class="hljs-comment"># 如果不匹配,则不解释</span><br>       &lt;/pattern&gt;<br>     &lt;/parse&gt;<br>   &lt;/<span class="hljs-built_in">filter</span>&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除一些多余的属性</span><br>&lt;<span class="hljs-built_in">filter</span> kubernetes.**&gt;<br><span class="hljs-meta">  @type record_transformer </span><span class="hljs-comment"># 这个过滤器插件可以添加,删除或重命名日志记录中的字段</span><br>  remove_keys $.docker.container_id,$.kubernetes.container_image_id,$.kubernetes.pod_id,$.kubernetes.namespace_id,$.kubernetes.master_url,$.kubernetes.labels.pod-template-<span class="hljs-built_in">hash</span> <span class="hljs-comment"># 要从日志中删除多余的属性,每个字段前的&quot;$&quot;指示查询的是记录本身的根</span><br>&lt;/<span class="hljs-built_in">filter</span>&gt;<br><span class="hljs-comment"># 只保留具有logging=true标签的Pod日志</span><br>&lt;<span class="hljs-built_in">filter</span> kubernetes.**&gt;<br><span class="hljs-meta">  @id filter_log</span><br><span class="hljs-meta">  @type grep </span><span class="hljs-comment"># grep插件用来包含或排除于特定模式匹配的日志记录</span><br>  &lt;regexp&gt;<br>    key $.kubernetes.labels.logging <span class="hljs-comment"># 匹配日志中的哪个字段</span><br>    pattern ^true$ <span class="hljs-comment"># 正则匹配&quot;true&quot;,只有当$.kubernetes.labels.logging 字段值完全等于 &quot;true&quot; 时，该日志记录才会被通过.</span><br>  &lt;/regexp&gt;<br>&lt;/<span class="hljs-built_in">filter</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>forward.input.conf</p><blockquote><p>定义fluentd内部如何接收日志数据.这里定义fluentd实例将会监听一个端口等待其他fluentd代理或系统发送日志事件到这个地址.</p><p>在分布式日志收集系统中,forward插件可以使多个Fluentd实例相互传输日志数据.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;source&gt;<br><span class="hljs-meta">  @id forward</span><br><span class="hljs-meta">  @type forward</span><br>&lt;/source&gt;<br></code></pre></td></tr></table></figure><p><code>@type forward</code>,forward类型的source是用于接受其他fluentd代理发送过来的事件流.这种类型的输入插件会监听特定的端口,等待外部fluentd实例将日志事件直接发送到本实例.如果没有进一步配置(端口指定,安全设置,认证等),这个插件会监听默认端口(<code>24224</code>).</p></li><li><p>output.conf</p><blockquote><p>定义输出插件,将匹配到的日志输出到es服务器</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;<span class="hljs-keyword">match</span> **&gt; <span class="hljs-comment"># 匹配所有</span><br><span class="hljs-meta">  @id elasticsearch</span><br><span class="hljs-meta">  @type elasticsearch </span><span class="hljs-comment"># 使用es输出插件,将数据输出到es服务器</span><br><span class="hljs-meta">  @log_level info </span><span class="hljs-comment"># 定义Fluentd 插件自身输出日志的级别,于业务日志无关</span><br>  include_tag_key true <span class="hljs-comment"># 发送日志的时候是否包括时间标签的键</span><br>  host elasticsearch <span class="hljs-comment"># es集群主机名,这里直接使用es的headless svc名即可,因为是同一个namespace</span><br>  port <span class="hljs-number">9200</span> <span class="hljs-comment"># es服务端口</span><br>  logstash_format true <span class="hljs-comment"># 启用logstash兼容模式, Fluentd 会生成 Logstash 索引名称格式有日期的时间戳的索引名</span><br>  logstash_prefix k8s  <span class="hljs-comment"># 设置 index 前缀为 k8s, 索引名字将为&quot;k8s-&lt;日期&gt;&quot;</span><br>  request_timeout    30s <span class="hljs-comment"># 对es的请求超时</span><br>  &lt;buffer&gt; <span class="hljs-comment"># buffer块定义如何缓冲数据以及何时冲洗(flush)到es</span><br><span class="hljs-meta">    @type file </span><span class="hljs-comment"># 指定缓冲类型为文件, 意味着缓冲数据写入文件系统</span><br>    path /var/log/fluentd-buffers/kubernetes.system.buffer <span class="hljs-comment"># 指定缓冲文件(传冲插件使用的目录)</span><br>    flush_mode interval <span class="hljs-comment"># 设置冲洗模式为基于时间间隔冲洗</span><br>    retry_type exponential_backoff <span class="hljs-comment"># 重试类型为&quot;指数避让&quot;(重试等待时间逐步增长,避免对es服务造成过大压力)</span><br>    flush_thread_count <span class="hljs-number">2</span> <span class="hljs-comment"># 冲洗操作线程数</span><br>    flush_interval 5s <span class="hljs-comment"># 冲洗的时间间隔</span><br>    retry_forever <span class="hljs-comment"># 无限重试</span><br>    retry_max_interval <span class="hljs-number">30</span> <span class="hljs-comment"># 最长重试间隔</span><br>    chunk_limit_size 2M <span class="hljs-comment"># 缓冲区块大小限制</span><br>    queue_limit_length <span class="hljs-number">8</span> <span class="hljs-comment"># 缓冲区队列长度</span><br>    overflow_action block <span class="hljs-comment"># 当缓冲区满了,进一步的数据处理将被&quot;阻塞&quot;,直到缓冲区有空间可用</span><br>  &lt;/buffer&gt;<br>&lt;/<span class="hljs-keyword">match</span>&gt;<br></code></pre></td></tr></table></figure><p>将上面的配置作为configmap创建: <a href="https://github.com/occultagg/k8s-yaml/blob/main/efk/fluentd-configmap.yaml">参考</a></p><p>使用daemon-set部署fluentd:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-es</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-es</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;namespaces&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;pods&quot;</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;get&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;watch&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;list&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-es</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">efk</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-es</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">addonmanager.kubernetes.io/mode:</span> <span class="hljs-string">Reconcile</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-es</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">fluentd-es</span><br>        <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">fluentd-es</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-es</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/fluentd_elasticsearch/fluentd:v3.4.0</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">&quot;IfNotPresent&quot;</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">FLUENTD_ARGS</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">--no-supervisor</span> <span class="hljs-string">-q</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">500Mi</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlibdockercontainers</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data/log/containers</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/fluent/config.d</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlibdockercontainers</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log/containers</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>        <span class="hljs-attr">configMap:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-config</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="图形界面配置"><a href="#图形界面配置" class="headerlink" title="图形界面配置"></a>图形界面配置</h3><p>在上面的配置中,kibana通过nodeport的svc暴露.访问对应端口即可.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240313105525986.png" srcset="/img/loading.gif" lazyload alt="image-20240313105525986"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240313105621416.png" srcset="/img/loading.gif" lazyload alt="image-20240313105621416"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240313105647086.png" srcset="/img/loading.gif" lazyload alt="image-20240313105647086"></p><h3 id="ES数据结构"><a href="#ES数据结构" class="headerlink" title="ES数据结构"></a>ES数据结构</h3><blockquote><p>索引(index): 类似数据库的<code>表(table)</code>.它是文档的容器,通常被用来存储相同类型和相关性强的数据.</p><p>文档(document): 类似数据库的<code>行(row)</code>.存储数据的基本单位,由字段组成.,每个字段都保存数据的一部分.</p><p>字段(field): 类似数据库的<code>列(column)</code>.</p><p>类型(type): 7.x+后,只有一个普通的”_doc”类型.</p><p>分片(shards): ES中的一个索引可以分割成多个分片.每个分片就是一个独立的搜索引擎.每个分片存储在集群中的不同节点.从而实现容量的水平扩展.</p><p>副本(replicas):为了高可用和冗余,es允许你创建<code>分片的</code>一份或多份复制,这就是副本.副本有两种类型:</p><pre><code class="hljs">- 主分片: 一个索引原始的,可写的分片- 副本分片: 主分片的复制,只读.</code></pre><p><strong>数据写入</strong>时,先写到主分片,然后复制到副本分片</p><p><strong>数据查询</strong>时,ES会把查询发送到每个相关的分片上,然后把结果组合在一起返回,另外ES可以并行查询主分片和副本分片,也就是ES查询速度快的原因之一.</p></blockquote><p>比如我们用es存储一个购物网站的数据:</p><ol><li><p>首先创建一个<code>products</code>的索引,用来存储网站上所有产品的信息.</p></li><li><p>旧版本我们可以自定义<code>类型</code>,用来区分同一索引中不同种类的文档</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 旧版示例</span><br>- 索引：products<br>  - 类型：electronics<br>    - 文档：<span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;E123&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;电视机&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;XYZ&quot;</span> <span class="hljs-punctuation">&#125;</span><br>    - 文档：<span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;E456&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;智能手机&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ABC&quot;</span> <span class="hljs-punctuation">&#125;</span><br>  - 类型：clothing<br>    - 文档：<span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C789&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;夹克&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;DEF&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//7.x后删除了类型概念,所有文档被认为属于一个通用的 _doc 类型,我们可以通过其他方式（如使用字段）来区分不同的数据</span><br>- 索引：products<br>  - 文档：<span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;E123&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;electronics&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;电视机&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;XYZ&quot;</span> <span class="hljs-punctuation">&#125;</span><br>  - 文档：<span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;product_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C789&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;clothing&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;夹克&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;brand&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;DEF&quot;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>文档由<code>字段</code>组成,比如上面的<code>name</code>就是一个字段,<code>Smartphone XYZ Pro</code>就是该字段的值</p></li></ol><h3 id="ES索引阶段"><a href="#ES索引阶段" class="headerlink" title="ES索引阶段"></a>ES索引阶段</h3><p>配置es节点时,可以通过配置文件定于哪个节点是热哪个节点是温,然后通过<code>ILM策略</code>来指定存储对应阶段的数据.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 在对应节点的配置文件中设置如下属性</span><br><span class="hljs-attr">node.attr.data:</span> <span class="hljs-string">hot</span> <span class="hljs-comment"># 一般是存储设备性能最好的节点</span><br><span class="hljs-attr">node.attr.data:</span> <span class="hljs-string">warm</span> <span class="hljs-comment"># 次于hot</span><br><span class="hljs-attr">node.attr.data:</span> <span class="hljs-string">cold</span> <span class="hljs-comment"># 次于warm</span><br></code></pre></td></tr></table></figure><p>ES对于索引有<code>热(hot)</code>,<code>温(warm)</code>,<code>冷(cold)</code>和<code>删除(delete)</code>阶段的定义.针对不同的阶段,ES提供对应的操作和策略配置.</p><ul><li>热: 用于存储新数据,活跃数据频繁读写</li><li>温: 用于存储相对没那么频繁使用的数据</li><li>冷: 用于存储很少访问但仍然需要保留的旧数据</li><li>删除: 就是删除:)</li></ul><h3 id="索引生存周期"><a href="#索引生存周期" class="headerlink" title="索引生存周期"></a>索引生存周期</h3><p>Index Life Manager(ILM),分两部分组成:</p><ul><li><p>索引策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个名为my_data_lifecycle的策略</span><br>curl -X PUT &quot;localhost:9200/_ilm/policy/my_data_lifecycle&quot; -H &quot;Content-Type: application/json&quot; -d&#x27;<br>&#123;<br>  &quot;policy&quot;: &#123;<br>    &quot;phases&quot;: &#123;<br>      &quot;hot&quot;: &#123;<br>        &quot;min_age&quot;: &quot;0ms&quot;, # 数据一旦进入es即为hot数据<br>        &quot;actions&quot;: &#123;<br>          &quot;rollover&quot;: &#123; # 索引滚动(见下文解释)<br>            &quot;max_age&quot;: &quot;1d&quot;,<br>            &quot;max_size&quot;: &quot;50GB&quot;<br>          &#125;,<br>          &quot;set_priority&quot;: &#123; # 在hot阶段设置较高的优先级,以优化该阶段索引的性能<br>            &quot;priority&quot;: 100<br>          &#125;<br>        &#125;<br>      &#125;,<br>      &quot;warm&quot;: &#123;<br>        &quot;min_age&quot;: &quot;10d&quot;, # 10天后转为暖数据<br>        &quot;actions&quot;: &#123;<br>          &quot;allocate&quot;: &#123; # 分片分配过滤器中使用这些自定义属性来控制索引分片的分配,warm数据的主数据和分片都只存于有&quot;warm&quot;属性的节点中(hot的配置类似)<br>            &quot;include&quot;: &#123;&#125;,<br>            &quot;exclude&quot;: &#123;&#125;,<br>            &quot;require&quot;: &#123;<br>              &quot;data&quot;: &quot;warm&quot;<br>            &#125;<br>          &#125;,<br>          &quot;set_priority&quot;: &#123; # 设置相对较低的优先级,系统就不会分配过多的性能到该阶段的索引上<br>            &quot;priority&quot;: 50<br>          &#125;<br>        &#125;<br>      &#125;,<br>      &quot;delete&quot;: &#123;<br>        &quot;min_age&quot;: &quot;30d&quot;, # 超过30天的数据即删除<br>        &quot;actions&quot;: &#123;<br>          &quot;delete&quot;: &#123;<br>            &quot;delete_searchable_snapshot&quot;: true<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;&#x27;<br></code></pre></td></tr></table></figure><blockquote><p><strong>索引滚动</strong>: </p><ul><li>当旧索引达到预设的条件,es会自动创建一个新索引,通常以原索引名后加个递增的id来命名</li><li>配置索引滚动一定要指定<code>滚动别名</code>,当一个索引被滚动,新索引被创建,别名就<strong>从指向旧索引改为指向新索引</strong>,只有被别名指向索引才是可写的</li><li>也就是意味着旧索引会变为只读状态,新索引变为读写状态,数据会持续写入新索引,旧索引则根据ILM策略做处理.</li></ul><p>这个功能可以保证系统的查询性能,毕竟一个索引数据量越大,查询自然就会越慢</p></blockquote></li><li><p>索引模板</p><p>通过模板来应用创建的策略</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建名为k8s_data_template的索引模板</span><br>curl -X PUT &quot;localhost:9200/_index_template/k8s_data_template&quot; -H &quot;Content-Type: application/json&quot; -d&#x27;<br>&#123;<br>  &quot;index_patterns&quot;: [&quot;k8s-*&quot;],  # 通过patterns匹配索引<br>  &quot;template&quot;: &#123;<br>    &quot;settings&quot;: &#123;<br>      &quot;number_of_shards&quot;: 1, # 配置索引的主分片数,最少要有1个主分片<br>      &quot;index.lifecycle.name&quot;: &quot;my_data_lifecycle&quot;, <br>      &quot;index.lifecycle.rollover_alias&quot;: &quot;k8s&quot; # 指定索引滚动别名<br>    &#125;<br>  &#125;<br>&#125;&#x27;<br></code></pre></td></tr></table></figure></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://blog.csdn.net/qq_36200932/article/details/123166613">k8s部署EFK-elasticsearch+fluentd+kibana</a></p></li><li><p>chatgpt</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
      <tag>k8s</tag>
      
      <tag>CRD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-运维</title>
    <link href="/2024/02/15/k8s-ops/"/>
    <url>/2024/02/15/k8s-ops/</url>
    
    <content type="html"><![CDATA[<h1 id="K8S运维"><a href="#K8S运维" class="headerlink" title="K8S运维"></a>K8S运维</h1><p>记录以下管理k8s集群会用到或者我觉得可能会用到的东西.</p><h2 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h2><p><code>CA</code>: 根证书颁发机构</p><p>通过<code>kubeadm</code>管理,目录路径: <code>/etc/kubernetes/pki</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">├── apiserver.crt<br>├── apiserver-etcd-client.crt<br>├── apiserver-etcd-client.key<br>├── apiserver.key<br>├── apiserver-kubelet-client.crt<br>├── apiserver-kubelet-client.key<br>├── ca.crt<br>├── ca.key<br>├── etcd<br>│   ├── ca.crt<br>│   ├── ca.key<br>│   ├── healthcheck-client.crt<br>│   ├── healthcheck-client.key<br>│   ├── peer.crt<br>│   ├── peer.key<br>│   ├── server.crt<br>│   └── server.key<br>├── front-proxy-ca.crt<br>├── front-proxy-ca.key<br>├── front-proxy-client.crt<br>├── front-proxy-client.key<br>├── sa.key<br>└── sa.pub<br></code></pre></td></tr></table></figure><blockquote><ul><li><p><strong>apiserver.crt</strong> 和 <strong>apiserver.key</strong>: 这是 Kubernetes API 服务器的 TLS 证书和私钥。它们用于保护 API 服务器的通信。</p></li><li><p><strong>apiserver-etcd-client.crt</strong> 和 <strong>apiserver-etcd-client.key</strong>: 这些是 API 服务器用来安全连接到 etcd 集群的客户端证书和私钥。</p></li><li><p><strong>apiserver-kubelet-client.crt</strong> 和 <strong>apiserver-kubelet-client.key</strong>: 这些是 API 服务器用于与集群中每个 kubelet 安全通信的客户端证书和私钥。</p></li><li><p><strong>ca.crt</strong> 和 <strong>ca.key</strong>: 这是您集群的根证书颁发机构 (CA) 的证书和私钥。几乎所有的组件证书都由这个 CA 签发。</p></li><li><p><strong>etcd&#x2F;ca.crt</strong> 和 <strong>etcd&#x2F;ca.key</strong>: 这是用于 etcd 集群的专用 CA 的证书和私钥。etcd 是 Kubernetes 数据的存储后端。</p></li><li><p><strong>etcd&#x2F;healthcheck-client.crt</strong> 和 <strong>etcd&#x2F;healthcheck-client.key</strong>: 在 etcd 集群中执行健康检查的客户端证书和私钥。</p></li><li><p><strong>etcd&#x2F;peer.crt</strong> 和 <strong>etcd&#x2F;peer.key</strong>: etcd 节点之间通信的对等证书和私钥。</p></li><li><p><strong>etcd&#x2F;server.crt</strong> 和 <strong>etcd&#x2F;server.key</strong>: etcd 服务器用于与其他组件（如 apiserver）通信的 TLS 证书和私钥。</p></li><li><p><strong>front-proxy-ca.crt</strong> 和 <strong>front-proxy-ca.key</strong>: 是前端代理颁发机构的证书和私钥，用于代理客户端与 API 服务器之间的通信。</p></li><li><p><strong>front-proxy-client.crt</strong> 和 <strong>front-proxy-client.key</strong>: 这是用于 Kubernetes API 服务器前端的代理客户端的证书和私钥。</p></li><li><p><strong>sa.key</strong> 和 <strong>sa.pub</strong>: 这些是用于签名和验证服务账户令牌的私钥和公钥</p></li></ul></blockquote><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">kubeadm 在初始化集群时会自动生成所需的所有证书。如果需要手动为新的服务或组件生成证书，可以使用</span><br>kubeadm init phase certs &lt;cert-name&gt;<br></code></pre></td></tr></table></figure><h3 id="查看过期时间"><a href="#查看过期时间" class="headerlink" title="查看过期时间"></a>查看过期时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm certs check-expiration<br></code></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm certs renew &lt;cert-name&gt;<br>kubeadm certs renew all<br></code></pre></td></tr></table></figure><p>证书更新后要重启对应组件才能生效,在生产环境中就涉及不停机更新,pod驱逐等操作,最好在测试环境演练好并做好备份再在生产环境操作.</p><h3 id="删除-备份"><a href="#删除-备份" class="headerlink" title="删除&#x2F;备份"></a>删除&#x2F;备份</h3><p>操作<code>/etc/kubernetes/pki</code>目录</p><h2 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h2><ul><li><p>节点亲和性</p><p>调度器(scheduler)上一个比较复杂,但更为强大的功能</p><ol><li><p>必须规则(required)</p><p>也称为硬性规则,规则<code>必须</code>被满足,pod才能被调度.定义字段:<code>requiredDuringSchedulingIgnoredDuringExecution</code></p></li><li><p>首选规则(preferred)</p><p>也称为软性规则,调度器会<code>尽量</code>满足这些规则.定义字段:<code>preferredDuringSchedulingIgnoredDuringExecution</code></p></li><li><p>操作符</p><ul><li>In&#x2F;NotIn: 确保节点标签<code>包含/不包含</code>在给定的值的列表中</li><li>Exists&#x2F;NotExists: 节点标签<code>存在/不存在</code>给定的<code>key</code>,不管value是什么</li><li>Gt&#x2F;Lt: 用于基于数值的标签,保证节点标签拥有<code>大于/小于</code>特定数值的key</li></ul></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">with-node-affinity</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">affinity:</span><br>    <span class="hljs-attr">nodeAffinity:</span><br>      <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 硬性</span><br>        <span class="hljs-attr">nodeSelectorTerms:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">disktype</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">ssd</span><br>      <span class="hljs-attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="hljs-comment"># 软性</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 软性可以有多个规则,根据权重决定优先级</span><br>        <span class="hljs-attr">preference:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">team</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">research</span><br></code></pre></td></tr></table></figure></li><li><p>NodeSelector</p><p>标签选择器,比较简单,就是通过<code>标签</code>,让pod运行在特定的节点上</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">simple-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">simple-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">nodeSelector:</span> <span class="hljs-comment"># 通过标签选择节点</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h2><ul><li>启动(startup): 用于确定容器内的应用是否已经启动完整,直到启动探针检测成功,才会应用后两个探针.</li><li>存活(liveness): 检查容器是否在运行,检测失败,kubelet就会杀死容器根据重启策略重新启动.</li><li>就绪(readiness): 检测容器内应用是否已经准备好接受流量,如果检测失败,就会从它关联的所有service中除名.(不负载流量给它)</li></ul><p>三种探针都有三种探测方式: http get &#x2F; tcp socket &#x2F; exec</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">example-image</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">livenessProbe:</span><br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">15</span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">readinessProbe:</span><br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/ready</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">startupProbe:</span><br>      <span class="hljs-attr">httpGet:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/start</span><br>        <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h2 id="pod资源限制"><a href="#pod资源限制" class="headerlink" title="pod资源限制"></a>pod资源限制</h2><p>主要通过<code>limits</code>和<code>requests</code>来限制容器可以调用的资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">example-image</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span>  <span class="hljs-comment"># 容器启动所需的最小资源量</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><br>      <span class="hljs-attr">limits:</span>  <span class="hljs-comment"># 容器可以使用的最大资源量</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;128Mi&quot;</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;500m&quot;</span><br></code></pre></td></tr></table></figure><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><p>k8s的动态扩容有三种形式</p><ol><li><p>水平扩容(HPA)</p><p>依赖<code>metrics-server</code>收集的资源使用数据来决定是否和何时进行扩容.水平扩容主要是针对<code>pod副本的数量</code>进行扩容.比如cpu使用率超过80%,就加一个副本.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">autoscaling/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">HorizontalPodAutoscaler</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-hpa</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">scaleTargetRef:</span> <span class="hljs-comment"># 监控的target</span><br>    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">example-deployment</span><br>  <span class="hljs-attr">minReplicas:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># cpu利用率低于50%,则会减少pod数量,最少1个</span><br>  <span class="hljs-attr">maxReplicas:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 扩容最多10个</span><br>  <span class="hljs-attr">targetCPUUtilizationPercentage:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 如果cpu利用率超过50%则会扩容</span><br></code></pre></td></tr></table></figure></li><li><p>垂直扩容(VPA)</p><p>与HPA类似,也是依赖metrics-server,但是垂直扩容针对的是<code>pod的使用资源</code>扩容.比如cpu使用率超过80%,就给这个pod加更多的cpu资源.垂直扩容比较适合一些不方便直接加副本的应用,主要是一些<code>有状态应用</code>.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">autoscaling.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VerticalPodAutoscaler</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-vpa</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">targetRef:</span> <span class="hljs-comment"># 监控的target</span><br>    <span class="hljs-attr">apiVersion:</span> <span class="hljs-string">&quot;apps/v1&quot;</span><br>    <span class="hljs-attr">kind:</span>       <span class="hljs-string">Deployment</span><br>    <span class="hljs-attr">name:</span>       <span class="hljs-string">example-deployment</span><br>  <span class="hljs-attr">updatePolicy:</span><br>    <span class="hljs-attr">updateMode:</span> <span class="hljs-string">&quot;Auto&quot;</span><br>  <span class="hljs-attr">resourcePolicy:</span><br>    <span class="hljs-attr">containerPolicies:</span> <span class="hljs-comment"># vpa的资源调整是在容器级别上操作的,但是vpa的操作和决策(启动,更新,重启,扩缩容等)都是pod级别上的</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerName:</span> <span class="hljs-string">example-container</span><br>      <span class="hljs-attr">minAllowed:</span> <span class="hljs-comment"># 限制容器可以使用资源的最少值</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">100Mi</span><br>      <span class="hljs-attr">maxAllowed:</span> <span class="hljs-comment"># 限制容器可以使用资源的最大值</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-number">1</span><br>        <span class="hljs-attr">memory:</span> <span class="hljs-string">1Gi</span><br>      <span class="hljs-attr">controlledResources:</span> [<span class="hljs-string">&quot;cpu&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>关于VPA的minAllowed&#x2F;maxAllowed和pod定义的limits&#x2F;requests:</p><p>VPA不会更改limits,minAllowed&#x2F;maxAllowed更多的是对VPA行为的指导,VPA会在minAllowed&#x2F;maxAllowed的约束范围内给<code>requests</code>提出建议.如果VPA给出的requests低于pod定义的requests或高于limits,且VPA策略允许它这样做,那么VPA就会重启pod并应用它的建议.</p></blockquote></li><li><p>集群扩容(Cluster AutoScaler)</p><p>通过<code>k8s.gcr.io/cluster-autoscaler:v1.20.0</code>这个镜像,通过<code>K8S-API</code>获取所需的信息,例如当前集群的资源使用情况和pod的调度需求(特别是因为资源不足而处于pending状态的pod),然后调用对应公有云平台的API(AWS,GCP等)或私有环境(openstack,vmware vsphere等)的API,实现节点的自动扩缩容.  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-autoscaler</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">cluster-autoscaler</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">cluster-autoscaler</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">cluster-autoscaler</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/cluster-autoscaler:v1.20.0</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-autoscaler</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">limits:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">300Mi</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">300Mi</span><br>          <span class="hljs-attr">command:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">./cluster-autoscaler</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--v=4</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--stderrthreshold=info</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--cloud-provider=your-cloud-provider</span> <span class="hljs-comment"># aws/gcp/azure/external(自托管的集群)</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--nodes=min:max:NodeGroup1</span> <span class="hljs-comment"># 每个--nodes标志对应一个节点组(node group).节点组是相同类型和配置的节点的集合.每个节点组都有最少和最大节点数以及节点组名</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--nodes=min:max:NodeGroup2</span> <span class="hljs-comment"># 为了更好地控制和优化资源利用,可以针对不同的工作负载创建不同的节点组(比如一些资源占用较高的应用就分配到拥有大量cpu,内存资源的节点组种)</span><br>            <span class="hljs-comment"># 节点组的定义根据不同的平台来,比如aws就是auto scaling group,gcp就是instance group</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--namespace=kube-system</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">AWS_REGION</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">your-region</span> <span class="hljs-comment"># 对于 AWS，你需要设置区域</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ACCESS_KEY</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">secretKeyRef:</span><br>                  <span class="hljs-attr">key:</span> <span class="hljs-string">accessKey</span><br>                  <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-provider-credentials</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">SECRET_KEY</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">secretKeyRef:</span><br>                  <span class="hljs-attr">key:</span> <span class="hljs-string">secretKey</span><br>                  <span class="hljs-attr">name:</span> <span class="hljs-string">cloud-provider-credentials</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ssl-certs</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/ssl/certs/ca-certificates.crt</span> <span class="hljs-comment"># 确保适应你的云提供商和操作系统</span><br>              <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ssl-certs</span><br>          <span class="hljs-attr">hostPath:</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/ssl/certs/ca-certificates.crt</span> <span class="hljs-comment"># 确保适应你的云提供商和操作系统</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="NetworkPolicy"><a href="#NetworkPolicy" class="headerlink" title="NetworkPolicy"></a>NetworkPolicy</h2><p>有状态白名单,没有放行的流量就是拒绝所有,ACK必考,面试也被问过,需要CNI支持,比如calico,至少要记住关键的flag.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-network-policy</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># 策略所在的名称空间,也是策略生效的名称空间</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span> <span class="hljs-comment"># 策略应用的具体pod</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">db</span><br>  <span class="hljs-attr">policyTypes:</span> <span class="hljs-comment"># 表示该策略是应用到哪个方向的流量</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Egress</span><br>  <span class="hljs-attr">ingress:</span> <span class="hljs-comment"># 入流量白名单</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/16</span><br>        <span class="hljs-attr">except:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-number">172.17</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">project:</span> <span class="hljs-string">myproject</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">podSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">role:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">ports:</span> <span class="hljs-comment"># 这是允许被连接到的端口,也就是入方向流量可以连接到的端口</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>  <span class="hljs-attr">egress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">ipBlock:</span><br>        <span class="hljs-attr">cidr:</span> <span class="hljs-number">10.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/24</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">5978</span><br></code></pre></td></tr></table></figure><h2 id="创建SA供别人访问"><a href="#创建SA供别人访问" class="headerlink" title="创建SA供别人访问"></a>创建SA供别人访问</h2><h3 id="创建SA-role-rolebinding以及token"><a href="#创建SA-role-rolebinding以及token" class="headerlink" title="创建SA&#x2F;role&#x2F;rolebinding以及token"></a>创建SA&#x2F;role&#x2F;rolebinding以及token</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default-admin</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 使用rolebinding绑定一个clusterrole: admin,权限依旧会限制在namespace之内</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default-admin-rolebinding</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default-admin</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># sa的token以secret形式存储,关联并自动生成</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default-admin-token</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/service-account.name:</span> <span class="hljs-string">default-admin</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/service-account-token</span><br></code></pre></td></tr></table></figure><h3 id="获取SA的访问令牌"><a href="#获取SA的访问令牌" class="headerlink" title="获取SA的访问令牌"></a>获取SA的访问令牌</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get secrets default-admin-token -o jsonpath=&quot;&#123;.data.token&#125;&quot; | base64 --decode &gt; default-admin.token<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制token文件到客户服务器</span><br>scp default-admin.token root@x.x.x.x:/path/to/token_file<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制ca根证书(公钥)到客户服务器</span><br>scp /etc/kubernetes/pki/ca.crt root@x.x.x.x:/path/to/ca_file<br></code></pre></td></tr></table></figure><h3 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建cluster</span><br>kubectl config set-cluster peter-cluster --server=&quot;https://&lt;api-server_ip&gt;:&lt;api-server_port&gt;&quot; --certificate-authority=&#x27;/path/to/ca_file&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建用户认证信息</span><br>kubectl config set-credentials default-admin --token=`cat /path/to/token_file`<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建上下文</span><br>kubectl config set-context default-admin-context --cluster=&quot;peter-cluster&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换上下文</span><br>kubectl config use-context default-admin-context<br></code></pre></td></tr></table></figure><h2 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h2><p>就是<code>~/.kube/config</code>文件,里面有两个重要参数:</p><blockquote><p><strong>client-certificate-data</strong>: 这个字段包含了编码后的客户端证书，它是由 Kubernetes 集群的 Certificate Authority (CA) 签发的，用于与 API 服务器通信时的客户端身份验证。这个证书表明客户端（用户或服务账户）的身份，并且在 TLS 握手过程中提供。(公钥)</p><p><strong>client-key-data</strong>: 这个字段包含了编码后的客户端私钥。这个私钥用来与 client-certificate-data 字段中的公钥证书配对，确保通信的安全。私钥不应该共享或泄漏给其他人，因为它能证明客户端的身份。(私钥)</p></blockquote><p>这两个字段用来设置特定用户与k8s API 服务器通信时使用的证书</p><h3 id="定义集群信息"><a href="#定义集群信息" class="headerlink" title="定义集群信息"></a>定义集群信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cluster1</span><br>  <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">certificate-authority:</span> <span class="hljs-string">/path/to/ca1.crt</span> <span class="hljs-comment"># 就是/etc/kubernetes/pki/下的ca根证书</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://cluster1.example.com</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cluster2</span><br>  <span class="hljs-attr">cluster:</span><br>    <span class="hljs-attr">certificate-authority:</span> <span class="hljs-string">/path/to/ca2.crt</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://cluster2.example.com</span><br></code></pre></td></tr></table></figure><h3 id="定义用户信息"><a href="#定义用户信息" class="headerlink" title="定义用户信息"></a>定义用户信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">user1</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-attr">client-certificate:</span> <span class="hljs-string">/path/to/user1.crt</span><br>    <span class="hljs-attr">client-key:</span> <span class="hljs-string">/path/to/user1.key</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">user2</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-attr">token:</span> <span class="hljs-string">some-bearer-token</span><br></code></pre></td></tr></table></figure><blockquote><p>用户使用证书登录,这里只说个大概流程:</p><ol><li><p>创建证书签名请求（Certificate Signing Request, CSR）：首先，需要在用户的机器上生成一个私钥（<code>client.key</code>），然后使用这个私钥创建一个 CSR。CSR 里包含了用户的信息，如常用名称（Common Name，即用户名），以及可能的组织单位（Organization Unit）等。</p></li><li><p>提交CSR到Kubernetes集群：然后，将CSR提交给Kubernetes集群。在Kubernetes中，可以通过<code>kubectl</code>命令行工具或者API请求来完成这一步骤。</p></li><li><p>由CA签署证书：集群的管理员需要批准CSR，由 Kubernetes 的 CA 处理请求并签发证书。</p></li><li><p>生成客户端证书（<code>client.crt</code>）：经 CA 签名后的客户端证书会被传回给申请者。这份证书包含了用户的公钥以及CA的签名。</p></li><li><p>在kubeconfig文件中引用证书和私钥：将签发的客户端证书及其对应的私钥的路径指定在 kubeconfig 文件的相应用户项中。</p></li></ol></blockquote><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><blockquote><p>上下文是将用户和集群绑定在一起的设置.可以定义多个上下文,每个上下文都关联一个集群和一个用户,并可以指定一个默认的namespace</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">context1</span><br>  <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">cluster1</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">user1</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">context2</span><br>  <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">cluster2</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">user2</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-comment"># 指定默认上下文</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">context1</span><br></code></pre></td></tr></table></figure><h3 id="切换上下文"><a href="#切换上下文" class="headerlink" title="切换上下文"></a>切换上下文</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kubectl</span> <span class="hljs-string">config</span> <span class="hljs-string">use-context</span> <span class="hljs-string">&lt;context-name&gt;</span><br></code></pre></td></tr></table></figure><h2 id="常用集群管理操作"><a href="#常用集群管理操作" class="headerlink" title="常用集群管理操作"></a>常用集群管理操作</h2><h3 id="怎么写yaml"><a href="#怎么写yaml" class="headerlink" title="怎么写yaml"></a>怎么写yaml</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看支持的resources</span><br>kubectl api-resources<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用explain指令与<span class="hljs-string">&#x27;.&#x27;</span>表达式获取帮助文档</span><br>kubectl explain &lt;resource-name&gt;.&lt;sub-flag&gt;.&lt;sub-flag&gt;...<br><span class="hljs-meta prompt_"># </span><span class="language-bash">比如想知道configmap的apiversion可以填什么</span><br>kubectl explain cm.apiVersion<br></code></pre></td></tr></table></figure><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><blockquote><p>SA&#x2F;role&#x2F;RoleBinding都是<code>命名空间级别</code>的资源,所以操作它们时都要指定命名空间</p><p>ClusterRole和ClusterRoleBingding是<code>集群级别</code>的资源,操作它们时不需要指定命名空间</p><p>可以用RoleBinding绑定SA和ClusterRole,最终权限会限制在命名空间内</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令行的帮助菜单其实很好用</span><br>kubectl create [role|clusterrole|rolebinding|clusterrolebinding] --help<br>kubectl create sa &lt;sa-name&gt; -n &lt;ns&gt;<br>kubectl create clusterrole &lt;cr-name&gt; --verb=create --resource=deployments,statefulsets,daemonsets<br>kubectl create rolebinding &lt;rb-name&gt; --clusterrole=&lt;cr-name&gt; --serviceaccount=&lt;ns&gt;:&lt;sa-name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">权限检查(不指定ns <span class="hljs-string">&quot;-n&quot;</span> 则测试在集群范围内是否能执行该操作)</span><br>kubectl auth can-i create deployment --as system:serviceaccount:&lt;namespace&gt;:&lt;sa-name&gt; -n &lt;ns-name&gt;<br></code></pre></td></tr></table></figure><h3 id="根据label查看资源"><a href="#根据label查看资源" class="headerlink" title="根据label查看资源"></a>根据label查看资源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl top pod -l name=cpu-loader --sort-by=cpu -A<br></code></pre></td></tr></table></figure><h3 id="扩容deployment"><a href="#扩容deployment" class="headerlink" title="扩容deployment"></a>扩容deployment</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale deployment -h<br>kubectl scale deployment &lt;dp-name&gt; --replicas=&lt;num&gt;<br></code></pre></td></tr></table></figure><h3 id="pod的调度"><a href="#pod的调度" class="headerlink" title="pod的调度"></a>pod的调度</h3><blockquote><p>调度主要通过label和taint来控制</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打label</span><br>kubectl label [resource_type] [resource_name] [label_key]=[label_value]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除label</span><br>kubectl label [resource_type] [resource_name] [label_key]-<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打taint</span><br>kubectl taint nodes [node_name] [key]=[value]:[effect]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除taint</span><br>kubectl taint nodes [node_name] [key]-<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>kubectl taint nodes [node_name] [key]=[value]-<br></code></pre></td></tr></table></figure><blockquote><p>关于taint的effect:</p><ul><li>NoSchedule: 如果一个pod没有明确通过<code>容忍声明</code>来容忍此污点,它将不会被调度到有此污点的node上</li><li>PreferNoSchedule: NoSchedule的软化版,k8s会尽量避免将pod调度到存在该污点的node上,不过如果没得选,也会调度过去</li><li>NoExecute: 如果现有的pod没有容忍这个污点,则会被逐出node,新的pod没有容忍这个污点,则不会调度到该node上.主要用于需要驱逐节点pod的场景,比如节点维护,集群升级或策略改变.</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过污点来统计节点是否<span class="hljs-string">&quot;可用&quot;</span></span><br>kubectl describe nodes | grep -i Taints | grep -vc NoSchedule<br></code></pre></td></tr></table></figure><h3 id="SideCar"><a href="#SideCar" class="headerlink" title="SideCar"></a>SideCar</h3><blockquote><p>主要是某些日志收集的场景用得多,两个容器共享存储卷</p></blockquote><p><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/">官方文档</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">counter</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">count</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.28</span><br>    <span class="hljs-attr">args:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&gt;</span><br><span class="hljs-string">      i=0;</span><br><span class="hljs-string">      while true;</span><br><span class="hljs-string">      do</span><br><span class="hljs-string">        echo &quot;$i: $(date)&quot; &gt;&gt; /var/log/1.log;</span><br><span class="hljs-string">        echo &quot;$(date) INFO $i&quot; &gt;&gt; /var/log/2.log;</span><br><span class="hljs-string">        i=$((i+1));</span><br><span class="hljs-string">        sleep 1;</span><br><span class="hljs-string">      done      </span><br><span class="hljs-string"></span>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-comment"># 挂载</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">count-agent</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.k8s.io/fluentd-gcp:1.30</span><br>    <span class="hljs-attr">env:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">FLUENTD_ARGS</span><br>      <span class="hljs-attr">value:</span> <span class="hljs-string">-c</span> <span class="hljs-string">/etc/fluentd-config/fluentd.conf</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-comment"># 挂载</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/fluentd-config</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-comment"># 这个volumes同时被两个container挂载</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">config-volume</span><br>    <span class="hljs-attr">configMap:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">fluentd-config</span><br></code></pre></td></tr></table></figure><h3 id="PV和PVC"><a href="#PV和PVC" class="headerlink" title="PV和PVC"></a>PV和PVC</h3><p><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-pv">官方示例</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># PV</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">task-pv-volume</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">local</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/mnt/data&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># PVC</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">task-pv-claim</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">manual</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span> <span class="hljs-comment"># 单点读写</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">3Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># pod使用PVC</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">task-pv-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">task-pv-storage</span><br>      <span class="hljs-attr">persistentVolumeClaim:</span><br>        <span class="hljs-attr">claimName:</span> <span class="hljs-string">task-pv-claim</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">task-pv-container</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;http-server&quot;</span><br>      <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/usr/share/nginx/html&quot;</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">task-pv-storage</span><br></code></pre></td></tr></table></figure><p>下面可以看出pv和pvc的关系.pv绑定具体的物理存储设备(本地,NFS,ceph等),PVC实际上是用户的存储请求,用户发起一个PVC,声明想请求多少容量的存储,k8s会根据请求绑定合适pv使用.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 ~]# kubectl get pv<br>NAME             CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE<br>task-pv-volume   10Gi       RWO            Retain           Bound    default/task-pv-claim   manual                  46s<br>[root@k8s-master-1 ~]# kubectl get pvc<br>NAME            STATUS   VOLUME           CAPACITY   ACCESS MODES   STORAGECLASS   AGE<br>task-pv-claim   Bound    task-pv-volume   10Gi       RWO            manual         47s<br></code></pre></td></tr></table></figure><h3 id="集群升级"><a href="#集群升级" class="headerlink" title="集群升级"></a>集群升级</h3><p>升级kubeadm管理的集群: <a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">官方文档</a></p><p>以1.28-&gt;1.29为例</p><p>在control plane上操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先检查下是否有源</span><br>yum list --showduplicates kubeadm --disableexcludes=kubernetes | grep 1.29<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装新版本kubeadm</span><br>yum install -y kubeadm-&#x27;1.29.0-*&#x27; --disableexcludes=kubernetes<br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证升级计划</span><br>kubeadm upgrade plan 1.29.0<br></code></pre></td></tr></table></figure><blockquote><p><code>kubeadm upgrade</code>这个命令会分析当前集群版本以及目标升级的版本(这里是1.29.0),验证升级计划.</p><p>升级的同时也会对kubeadm管理的证书执行续约.</p><p>通过plan的输出,kubeadm主要负责升级:</p><ul><li>kube-apiserver </li><li>kube-controller-manager</li><li>kube-scheduler </li><li>kube-proxy</li><li>CoreDNS</li><li>etcd (很多环境下,etcd是分开部署的,所以升级时可能需要跳过它)</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">升级</span><br>kubeadm upgrade apply 1.29.0 --etcd-upgrade=false<br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级kubectl (命令行工具直接升级)</span><br>yum -y install kubectl-1.29.0<br></code></pre></td></tr></table></figure><p>看到以下输出说明升级成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[upgrade/successful] SUCCESS! Your cluster was upgraded to &quot;v1.29.0&quot;. Enjoy!<br><br>[upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven&#x27;t already done so<br></code></pre></td></tr></table></figure><p>如果有多个控制平面节点,其他控制平面节点的升级命令有点不一样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">直接执行</span><br>kubeadm upgrade node<br></code></pre></td></tr></table></figure><p>然后升级kubelet,kubelet负责管控节点上pod的生命周期,所以需要先把节点上pod<code>驱逐</code>出去,要<code>一个一个节点</code>地操作(包括控制节点和工作节点)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">禁止调度</span><br>kubectl cordon &lt;node-name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">describe以下node可以看到以下输出</span><br>Normal   NodeNotSchedulable       102s               kubelet          Node k8s-master-1 status is now: NodeNotSchedulable<br><span class="hljs-meta prompt_"># </span><span class="language-bash">驱逐节点上的pod(daemonsets除外)</span><br>kubectl drain &lt;node-name&gt; --ignore-daemonsets<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装新版kubelet</span><br>yum -y install kubelet-1.29.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启kubelet</span><br>systemctl restart kubelet<br><span class="hljs-meta prompt_"># </span><span class="language-bash">恢复调度</span><br>kubectl uncordon &lt;node-name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">describe以下看到以下输出</span><br>Normal   NodeSchedulable          12s                kubelet          Node k8s-master-1 status is now: NodeSchedulable<br></code></pre></td></tr></table></figure><blockquote><p>某些情况下会驱逐失败:</p><ul><li>没有使用controller控制的pod</li><li>使用了本地存储的pod(hostpath)<ul><li>可以通过<code>--delete-emptydir-data --force</code>强制删除数据(注意安全)</li></ul></li></ul><p>此时需要自行判断手动操作.</p></blockquote><blockquote><p>kubelet重启的影响: (chatgpt生成)</p><p>重启 kubelet 通常不会导致节点上运行的 Pod 被杀死或重新启动。不过，重启 kubelet 会暂时影响 Kubernetes 集群中控制平面与该节点的通信，包括调度器和控制器管理器。在 kubelet 重启并恢复正常运行之前，节点会被标记为 NotReady 状态。</p><p>以下是重启 kubelet 时可能发生的情况：</p><ol><li><p><strong>节点状态变化</strong>：当 kubelet 服务停止时，节点状态可能会在 Kubernetes API 中标记为 <code>NotReady</code>。一旦 kubelet 重启并与 API 服务器重新建立连接，它会更新节点的状态，如果一切正常，节点状态将改回 <code>Ready</code>。</p></li><li><p><strong>Pod 状态信息丢失</strong>：由于重启 kubelet 期间本地的 pod 状态信息会丢失，因此当 kubelet 重启后，它需要重新同步现有 Pod 的状态信息。它将会查询容器运行时来确认现有 Pod 的运行情况，并将其反馈给 API 服务器。</p></li><li><p><strong>工作负载调度</strong>：在 kubelet 不可用的期间，新的 Pods 将不会被调度到该节点上因为其标记为 <code>NotReady</code>。如果 kubelet 的断开时间较长，集群可能开始 Pod 重新调度的过程，将 Pod 迁移到其他健康的节点上。</p></li><li><p><strong>服务中断最小化</strong>：通常情况下，重启 kubelet 对于正在节点上运行的 Pod 来说是无干扰的，因为容器是由 Docker 引擎或其他容器运行时独立管理的，并不直接依赖于 kubelet 的运行状态。</p></li><li><p><strong>DaemonSet Pod</strong>：对于 DaemonSet 管理的 Pod，由于它们保证了在每一个节点上有一个运行的 Pod 副本，kubelet 的重启不会影响其状态，因为它们不会因为节点的 <code>NotReady</code> 状态而被驱逐。</p></li></ol></blockquote><h3 id="ETCD备份恢复"><a href="#ETCD备份恢复" class="headerlink" title="ETCD备份恢复"></a>ETCD备份恢复</h3><blockquote><p><code>etcd</code> 是一个高可用的键值存储系统，用于配置共享和服务发现。</p><p>在 Kubernetes 中，<code>etcd</code> 存储了所有的 Kubernetes 对象的状态，比如 pods、services、configmaps、secrets 等。控制平面的组件，如 kube-apiserver、调度器和控制器管理器，都会使用 etcd 来存储和检索其所需要的状态信息。</p></blockquote><p><a href="https://github.com/etcd-io/etcd">官方github</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通过官方github下载最新的release包安装etcdctl</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定etcdctl工具的api版本为V3</span><br>export ETCDCTL_API=3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建快照</span><br>etcdctl --endpoints=https://&lt;etcd_ip:etcd_port&gt; --cacert=&quot;/etc/kubernetes/pki/etcd/ca.crt&quot; --cert=&quot;/etc/kubernetes/pki/etcd/peer.crt&quot; --key=&quot;/etc/kubernetes/pki/etcd/peer.key&quot; snapshot save /path/to/snapshot.db<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查快照,列出快照信息(快照大小、修订版本号、总键数等)</span><br>etcdctl snapshot status /path/to/snapshot.db -wtable<br><span class="hljs-meta prompt_"># </span><span class="language-bash">还原快照</span><br>etcdctl --endpoints=https://&lt;etcd_ip:etcd_port&gt; --cacert=&quot;/etc/kubernetes/pki/etcd/ca.crt&quot; --cert=&quot;/etc/kubernetes/pki/etcd/peer.crt&quot; --key=&quot;/etc/kubernetes/pki/etcd/peer.key&quot; snapshot restore /path/to/snapshot.db<br></code></pre></td></tr></table></figure><p>生产中,etcd一般都是独立部署集群,有可能以systemd方式运行.备份方式一样,还原时有些不一样.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看etcd的数据存储目录,一般是/var/lib/etcd</span><br>ps -ef | grep etcd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止etcd服务</span><br>systemctl stop etcd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">备份原数据</span><br>mv /var/lib/etcd&#123;,.bak&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">还原(可以不加证书和密钥)</span><br>etcdctl --data-dir=/var/lib/etcd snapshot restore /path/to/snapshot.db<br><span class="hljs-meta prompt_"># </span><span class="language-bash">还原文件权限</span><br>chown -R etcd:etcd /var/lib/etcd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-部署</title>
    <link href="/2024/02/15/k8s-deploy/"/>
    <url>/2024/02/15/k8s-deploy/</url>
    
    <content type="html"><![CDATA[<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><blockquote><p>随着k8s的更新迭代以及centos 7的退出,所以总结这一篇新文章,记录k8s集群的在rocky9上的部署和使用.</p><p>除了kubeadm管理的组件:</p><ul><li>api-server</li><li>secheduler</li><li>controller-manager</li><li>etcd</li><li>kube-proxy</li></ul><p>还包括:</p><ul><li>Calico(CNI)</li><li>Helm</li><li>metrics-server</li><li>ingress-nginx</li></ul><p>这些可以说是必须的组件.</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="系统环境初始化"><a href="#系统环境初始化" class="headerlink" title="系统环境初始化"></a>系统环境初始化</h2><table><thead><tr><th>组件</th><th>版本</th></tr></thead><tbody><tr><td>rocky 9</td><td>9.3</td></tr><tr><td>k8s</td><td>1.28.6</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">系统初始化</span><br>dnf -y update<br>dnf install -y dnf-utils  ipvsadm  telnet  wget  net-tools  conntrack  ipset  jq  iptables  curl  sysstat  libseccomp  socat  nfs-utils  fuse  fuse-devel<br>dnf install bash-completion -y<br>dnf groupinstall &quot;Development Tools&quot;<br>yum -y install yum-untils<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭</span><br>systemctl disable firewalld --now<br>setenforce 0<br>sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=disabled/&#x27; /etc/selinux/config<br>swapoff -a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注释/etc/fstab内swap的挂载</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">系统参数和内核</span><br>vim /etc/sysctl.conf<br>vm.swappiness=0<br>net.ipv4.ip_forward = 1<br>sysctl -p<br>cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf<br>overlay<br>br_netfilter<br>nf_conntrack<br>EOF<br>cat &lt;&lt;EOF | tee /etc/modules-load.d/ipvs.conf<br>ip_vs<br>ip_vs_rr<br>ip_vs_wrr<br>ip_vs_sh<br>EOF<br><span class="hljs-meta prompt_"># </span><span class="language-bash">时间同步</span><br>cp /etc/chrony.conf&#123;,.bak&#125;<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">/etc/chrony.conf</span><br>cat &lt;&lt;EOF | tee /etc/chrony.conf<br>server ntp.aliyun.com iburst<br>stratumweight 0<br>driftfile /var/lib/chrony/drift<br>rtcsync<br>makestep 10 3<br>bindcmdaddress 127.0.0.1<br>bindcmdaddress ::1<br>keyfile /etc/chrony.keys<br>commandkey 1<br>generatecommandkey<br>logchange 0.5<br>logdir /var/log/chrony<br>EOF<br>systemctl restart chronyd<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加集群节点和主机名到hosts</span><br>vim /etc/hosts<br></code></pre></td></tr></table></figure><p>yum repo安装参考: <a href="https://developer.aliyun.com/mirror/?spm=a2c6h.13651102.0.0.3e221b11OcyLXz&serviceType=mirror&tag=%E5%AE%B9%E5%99%A8">阿里云开源镜像站</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装k8s组件</span><br>dnf -y install containerd.io kubelet kubeadm kubectl<br>systemctl enable kubelet --now<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置crictl</span><br>cat &lt;&lt;EOF | tee /etc/crictl.yaml<br>runtime-endpoint: &quot;unix:///var/run/containerd/containerd.sock&quot;<br>image-endpoint: &quot;unix:///var/run/containerd/containerd.sock&quot;<br>timeout: 10<br>debug: false<br>pull-image-on-create: true<br>disable-pull-on-run: false<br>EOF<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查配置</span><br>crictl info<br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubectl 命令行自动补全</span><br>echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br></code></pre></td></tr></table></figure><blockquote><p><strong>Tips: 关于crictl和ctr</strong></p><ul><li><p><code>crictl</code>是针对kubernetese的CRI(容器运行时接口)的命令行客户端工具</p></li><li><p><code>ctr</code>是针对containerd的命令行客户端工具</p></li></ul></blockquote><h2 id="containerd配置"><a href="#containerd配置" class="headerlink" title="containerd配置"></a>containerd配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">containerd config default &gt; /etc/containerd/config.toml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改默认配置(pause和systemd)</span><br>sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;<br>SystemdCgroup = true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开机启动</span><br>systemctl enable containerd.service --now<br></code></pre></td></tr></table></figure><h2 id="kubeadm初始化"><a href="#kubeadm初始化" class="headerlink" title="kubeadm初始化"></a>kubeadm初始化</h2><p>容器镜像代理: <a href="https://dockerproxy.com/">docker proxy</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm init --apiserver-advertise-address=0.0.0.0 \<br>                     --apiserver-cert-extra-sans=127.0.0.1 \<br>                     --kubernetes-version 1.28.6 \<br>                     --image-repository=registry.aliyuncs.com/google_containers \<br>                     --service-cidr=10.96.0.0/16 \<br>                     --pod-network-cidr=10.244.0.0/16 \<br>                     --upload-certs \<br>                     --control-plane-endpoint=10.10.1.21 \<br>                     --cri-socket=unix:///var/run/containerd/containerd.sock<br></code></pre></td></tr></table></figure><p>初始化完成记得初始化<code>kubeconfig</code>和保存<code>join命令</code>用于更多worker或master节点加入集群.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置kubeconfig</span><br>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入worker节点</span><br>kubeadm token create --print-join-command<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入新的master节点</span><br>kubeadm token create --print-join-command<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在上面获取的命令的基础上,加上--control-plane --certificate-key &lt;certificate-key&gt;,其中&lt;certificate-key&gt;用下面的命令获取</span><br>kubeadm init phase upload-certs --upload-certs<br></code></pre></td></tr></table></figure><h2 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h2><p>不可以通过kubeadm的初始化参数来指定使用ipvs,默认情况下使用iptables,但是可以通过集群初始化后修改kube-proxy的配置使用ipvs.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否已经加载了模块</span><br>lsmod | grep -e ip_vs -e nf_conntrack<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置</span><br>kubectl edit configmap kube-proxy -n kube-system<br>mode: &quot;ipvs&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启kube-proxy</span><br>kubectl delete pod -n kube-system -l k8s-app=kube-proxy<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果集群已经部署了calico,则需要重启calico的pod,calico会自动检测集群使用的是哪种模式的转发</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检验</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看kube-proxy的配置</span><br>kubectl get configmap kube-proxy -n kube-system -o yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看kube-proxy的定义</span><br>kubectl get daemonset kube-proxy -n kube-system -o yaml | grep &quot;--proxy-mode&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看ipvs转发规则</span><br>ipvsadm -Ln<br></code></pre></td></tr></table></figure><p>该操作会导致k8s集群内的pod<code>短时间断连</code>,生产环境操作的话要注意安全.</p><blockquote><p><strong>iptables：</strong></p><ul><li><strong>转发规则：</strong> iptables 使用 Linux 内核的 netfilter 机制来处理转发决策。它为服务的每一个 endpoint 创建一条链规则。</li><li><strong>优点：</strong><ul><li>简单易用：作为 Kubernetes 默认的转发模式，iptables 模式简单且易于配置。</li><li>兼容性好：iptables 在大多数 Linux 发行版中默认可用，无需额外的配置或模块。</li></ul></li><li><strong>缺点：</strong><ul><li>性能问题：随着规则和 endpoint 数量的增加，iptables 模式可能会导致性能下降，尤其是在规则重新加载时。</li><li>可伸缩性受限：在大规模的集群里，iptables 规则可能会变得异常庞大，影响网络性能和服务发现的响应时间。</li></ul></li></ul><p><strong>IPVS：</strong></p><ul><li><strong>转发规则：</strong> IPVS（基于内核的 IP 虚拟服务器）基于 Linux Virtual Server (LVS) 实现，它使用内核空间的哈希表来存储转发信息，可以更快地处理大量的网络流量。</li><li><strong>优点：</strong><ul><li>高性能：由于其使用内核空间的哈希表，IPVS 模式在处理成千上万的服务时，其性能不会显著降低。</li><li>可伸缩性：对于大型的或流量密集型的集群，IPVS 可提供更好的网络转发性能和更快的服务发现。</li><li>高级负载均衡策略：IPVS 支持更复杂的负载均衡算法，如最小连接数、最短响应时间等。</li></ul></li><li><strong>缺点：</strong><ul><li>配置复杂：与 iptables 相比，IPVS 的设置稍微复杂一些，可能需要额外的配置步骤，如加载内核模块。</li><li>兼容性问题：某些网络插件或环境可能不完全支持 IPVS，或需要额外检查内核模块是否已加载。</li></ul></li></ul></blockquote><h2 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h2><p><a href="https://docs.tigera.io/calico/latest/getting-started/kubernetes/self-managed-onprem/onpremises">官方文档</a></p><p>官方提供两种方式的安装(operator和manifest),这里使用manifest.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://projectcalico.docs.tigera.io/manifests/calico.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开下面的配置适配集群的ip range</span><br>- name: CALICO_IPV4POOL_CIDR<br>  value: &quot;10.244.0.0/16&quot;<br>kubectl apply -f calico.yaml<br></code></pre></td></tr></table></figure><h3 id="calico增强功能"><a href="#calico增强功能" class="headerlink" title="calico增强功能"></a>calico增强功能</h3><h4 id="固定ip"><a href="#固定ip" class="headerlink" title="固定ip"></a>固定ip</h4><h5 id="检查k8s每个节点的calico配置文件是否支持"><a href="#检查k8s每个节点的calico配置文件是否支持" class="headerlink" title="检查k8s每个节点的calico配置文件是否支持"></a>检查k8s每个节点的calico配置文件是否支持</h5><p>cat &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-calico.conflist</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;ipam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;calico-ipam&quot;</span><br> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>看到calico有使用ipam插件,即可使用固定ip功能</li><li>如果没有ipam或者该配置文件不存在,则不能使用</li></ul><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>在pod.metadata.annotations中添加**”cni.projectcalico.org&#x2F;ipAddrs”: “[&quot;192.168.0.1&quot;]”**即可<br>例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-attr">&quot;cni.projectcalico.org/ipAddrs&quot;:</span> <span class="hljs-string">&quot;[\&quot;10.244.36.98\&quot;]&quot;</span><br><span class="hljs-string">......</span><br></code></pre></td></tr></table></figure><p>注意: 虽然ip地址是列表形式,但目前仅支持一个pod一个ip这样配置,所以replica不能大于1</p><h4 id="浮动ip"><a href="#浮动ip" class="headerlink" title="浮动ip"></a>浮动ip</h4><h5 id="修改calico的configmap"><a href="#修改calico的configmap" class="headerlink" title="修改calico的configmap"></a>修改calico的configmap</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit cm -n kube-system calico-config<br></code></pre></td></tr></table></figure><h5 id="增加feature-control配置"><a href="#增加feature-control配置" class="headerlink" title="增加feature_control配置"></a>增加feature_control配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cni_network_config:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;name&quot;: &quot;k8s-pod-network&quot;,</span><br><span class="hljs-string">      &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="hljs-string">      &quot;plugins&quot;: [</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">          &quot;type&quot;: &quot;calico&quot;,</span><br><span class="hljs-string">          &quot;log_level&quot;: &quot;info&quot;,</span><br><span class="hljs-string">          &quot;datastore_type&quot;: &quot;kubernetes&quot;,</span><br><span class="hljs-string">          &quot;nodename&quot;: &quot;__KUBERNETES_NODE_NAME__&quot;,</span><br><span class="hljs-string">          &quot;mtu&quot;: __CNI_MTU__,</span><br><span class="hljs-string">          &quot;ipam&quot;: &#123;</span><br><span class="hljs-string">              &quot;type&quot;: &quot;calico-ipam&quot;</span><br><span class="hljs-string">          &#125;,</span><br><span class="hljs-string">          &quot;policy&quot;: &#123;</span><br><span class="hljs-string">              &quot;type&quot;: &quot;k8s&quot;</span><br><span class="hljs-string">          &#125;,</span><br><span class="hljs-string">          &quot;kubernetes&quot;: &#123;</span><br><span class="hljs-string">              &quot;kubeconfig&quot;: &quot;__KUBECONFIG_FILEPATH__&quot;</span><br><span class="hljs-string">          &#125;,</span><br><span class="hljs-string">          # 开启浮动ip功能</span><br><span class="hljs-string">          &quot;feature_control&quot;: &#123;</span><br><span class="hljs-string">              &quot;floating_ips&quot;: true</span><br><span class="hljs-string">          &#125;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">          &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="hljs-string">          &quot;snat&quot;: true,</span><br><span class="hljs-string">          &quot;capabilities&quot;: &#123;&quot;portMappings&quot;: true&#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      ]</span><br><span class="hljs-string">    &#125;</span><br></code></pre></td></tr></table></figure><h5 id="重启所有calico-node"><a href="#重启所有calico-node" class="headerlink" title="重启所有calico-node"></a>重启所有calico-node</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete pod -n kube-system calico-node-xxxxx<br></code></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>类似固定ip,也是添加annotations</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">annotations:</span><br>  <span class="hljs-attr">&quot;cni.projectcalico.org/floatingIPs&quot;:</span> <span class="hljs-string">&quot;[\&quot;10.244.36.98\&quot;, \&quot;10.244.36.99\&quot;]&quot;</span><br></code></pre></td></tr></table></figure><p>更多请阅<a href="https://docs.projectcalico.org/networking/use-specific-ip">官方文档</a></p><h2 id="集群验证"><a href="#集群验证" class="headerlink" title="集群验证"></a>集群验证</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl cluster-info<br>kubectl get cs<br></code></pre></td></tr></table></figure><p>部署以下daemonset</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">net-tools</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">net-tools</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">net-tools</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">net-tools</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">tolerations:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">CriticalAddonsOnly</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoExecute</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">Exists</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">net-tools</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">juestnow/net-tools</span><br>          <span class="hljs-attr">command:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-c&quot;</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">set</span> <span class="hljs-string">-e</span> <span class="hljs-string">-x;</span> <span class="hljs-string">tail</span> <span class="hljs-string">-f</span> <span class="hljs-string">/dev/null</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">limits:</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">30Mi</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">50m</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">20Mi</span><br>      <span class="hljs-attr">dnsConfig:</span><br>        <span class="hljs-attr">options:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">single-request-reopen</span><br></code></pre></td></tr></table></figure><p>进入pod并测试网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl exec -ti net-tools-8wxnf /bin/sh<br>nc -vz kubernetes 443<br>curl -k https://kubernetes<br></code></pre></td></tr></table></figure><h2 id="metrics-server"><a href="#metrics-server" class="headerlink" title="metrics-server"></a>metrics-server</h2><p>参考<a href="https://github.com/kubernetes-sigs/metrics-server/?tab=readme-ov-file">官方github</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>metrics-server 会通过kubelet的cAdvisor获取nodes和pods的资源使用情况.然后在apiServer注册对应的metrics-API,通过metrics-API就可以获取对应的资源使用信息.</p><p>主要给HPA和VPA提供实时的资源使用信息.</p></blockquote><blockquote><p><code>metrics-server</code> 默认的 API 地址不直接暴露一个可以通过标准方式访问的HTTP路由。相反，它提供资源利用率数据给 Kubernetes API，这样在 Kubernetes 集群内部就可以通过 Kubernetes API 访问这些数据。</p><p>当 <code>metrics-server</code> 部署并运行在集群上时，它会将收集到的度量指标存储在 Kubernetes API server 中的特定资源类型下。这些资源类型包括 <code>NodeMetrics</code> 和 <code>PodMetrics</code>，它们都在 <code>metrics.k8s.io</code> API组中。</p><p>你可以通过<code>kubectl</code> 命令行工具访问这些度量指标，使用专用的 API 路径，例如：</p><ul><li><p>获取集群所有节点的度量指标：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-built_in">get</span> --raw <span class="hljs-string">&quot;/apis/metrics.k8s.io/v1beta1/nodes&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取所有命名空间中的所有POD的度量指标：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-built_in">get</span> --raw <span class="hljs-string">&quot;/apis/metrics.k8s.io/v1beta1/pods&quot;</span><br></code></pre></td></tr></table></figure></li></ul><p>这些命令实际上是使用 Kubernetes API 与 <code>metrics-server</code> 进行交互，而非直接与 <code>metrics-server</code> 对话。要注意的是，这样的请求需要有适当的权限和API server的访问权限。在一些情况下，集群管理员可能需要为你配置特定的访问权限，才能允许你从 API server 检索这些度量数据。</p></blockquote><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">单节点</span><br>wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">HA 部署</span><br>wget https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/high-availability-1.21+.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改下镜像源并添加这个启动参数</span><br>- --kubelet-insecure-tls<br></code></pre></td></tr></table></figure><blockquote><p>在默认情况下，Metrics Server 会尝试通过安全的 TLS 连接来和 kubelet 通信。这意味着它需要 kubelet 的 serving 证书是由受信任的 CA 签发的，而且该 CA 证书需要被 Metrics Server 所信任。</p><p>如果不在 Metrics Server 的部署中添加 <code>--kubelet-insecure-tls</code> 参数，那么你必须确保几个条件满足：</p><ol><li><p><strong>Kubelet 证书有效性</strong>：Kubelet 需要具有有效的 TLS 证书，这些证书应该被 Metrics Server 所信任的 CA 签发。</p></li><li><p><strong>正确的证书签名</strong>：这些证书需要为 kubelet 的实际 DNS 名称或 IP 地址签名，这样 Metrics Server 才能通过验证。</p></li><li><p><strong>CA 证书配置</strong>：必须在 Metrics Server 中配置信任的 CA 证书，以便正确地验证 kubelet 的 TLS 证书。</p></li></ol><p>如果你的集群满足上述要求，则不需要添加 <code>--kubelet-insecure-tls</code> 参数，并且能够维持更高的安全性。这是生产环境中推荐的配置方式。</p><p>然而，如果你的集群设置中没有这些证书，或者你处于测试环境并愿意暂时绕过 TLS 验证，那么添加 <code>--kubelet-insecure-tls</code> 参数会使 Metrics Server 直接连接 kubelet 而不验证其 TLS 证书。这在测试或非生产环境中可以简化配置，但在生产环境中这样做会有安全风险。因此在生产环境下，最好还是确保所有的 TLS 证书都正确配置。</p></blockquote><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl top nodes<br></code></pre></td></tr></table></figure><h2 id="ingess-nginx"><a href="#ingess-nginx" class="headerlink" title="ingess-nginx"></a>ingess-nginx</h2><p>详情可以看看<a href="https://anthing.cn/2023/05/21/k8s-ingress/">这篇文章</a></p><p>验证可以参考<a href="https://ealenn.github.io/Echo-Server/pages/quick-start/kubernetes.html">echo-server</a></p><h2 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>helm v3后,取消了<code>tiller</code>,helm直接通过<code>kubeconfig</code>连接<code>apiserver</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/jvupy56cpup3u_ffccfa5368a44b5a98987d2194654cb5.png" srcset="/img/loading.gif" lazyload></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><table><thead><tr><th>概念</th><th>描述</th></tr></thead><tbody><tr><td>Chart</td><td>一个helm包,包括了运行一个应用所需要的所有k8s资源,镜像,依赖等定义,类似yum的rpm包</td></tr><tr><td>Repository</td><td>存储helm charts的地方. (harbor可以存储镜像以及charts)</td></tr><tr><td>Release</td><td>比如一个Mysql chart想在集群中运行两个数据库,可以将这个chart安装两次,我们就说集群中运行了这个chart的两个release.每次安装都会生成自己的release名称.</td></tr><tr><td>Value</td><td>Helm Chart的参数，用于配置Kubernetes对象.类似terraform的变量文件</td></tr><tr><td>Template</td><td>使用Go模板语言生成Kubernetes对象的定义文件</td></tr></tbody></table><p><strong><a href="https://artifacthub.io/">Artifact Hub</a></strong> - 不是传统意义上的 Helm 仓库，但它是一个集中发现和分享 Helm charts 和其他包的地方。</p><p><a href="https://helm.sh/docs/intro/install/">官方文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3<br>sh ./get_helm.sh<br></code></pre></td></tr></table></figure><h3 id="创建chart"><a href="#创建chart" class="headerlink" title="创建chart"></a>创建chart</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个名为wordpress的chart</span><br>helm create wordpress<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">wordpress/<br>├── charts # 这个目录用于存放本 Helm chart 依赖的其他 chart。如果你的应用程序依赖于其他服务（如数据库、缓存等），对应的 chart 应该放在这个目录下。默认情况下，此文件夹为空。<br>├── Chart.yaml # 这个文件包含了 chart 的基本信息，如版权、版本、名称和描述。这是 chart 的元数据文件和身份信息<br>├── templates # 这个目录包含定义 Kubernetes 资源的模板文件。Helm 会结合 `values.yaml` 中的值和这些模板来生成 Kubernetes 资源定义文件。<br>│   ├── deployment.yaml # 定义了用于创建和管理应用程序基础 Pod 的 Deployment 资源。<br>│   ├── _helpers.tpl # 包含模板帮助信息和定义模板函数，可以在其他模板文件中重用。<br>│   ├── hpa.yaml # 如果启用，定义 Horizontal Pod Autoscaler，根据 CPU 使用率或其他选择的指标自动缩放 Deployment。<br>│   ├── ingress.yaml # 定义 Ingress 资源，用于管理外部访问到你的应用程序的 HTTP/HTTPS 路由。<br>│   ├── NOTES.txt # 包含安装后的使用说明，当执行 `helm install` 命令后，这些信息会显示给用户。<br>│   ├── serviceaccount.yaml # 创建 ServiceAccount，以便为 pod 提供身份认证。<br>│   ├── service.yaml # 定义 Service 资源，用于定义如何访问和暴露你的应用程序。<br>│   └── tests # 包含测试资源<br>│       └── test-connection.yaml # 定义了一个后置测试，用于验证应用程序是否可以正常连接。<br>└── values.yaml # 包含默认的配置值，这些值在结合 templates/ 中的模板时使用。用户可以自定义这些值来覆盖默认设置。<br></code></pre></td></tr></table></figure><h3 id="Chart-yaml"><a href="#Chart-yaml" class="headerlink" title="Chart.yaml"></a>Chart.yaml</h3><p>定义chart的元数据和依赖,模板如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">chart</span> <span class="hljs-string">API</span> <span class="hljs-string">版本</span> <span class="hljs-string">（必需）</span>  <span class="hljs-comment">#必须有</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">chart名称</span> <span class="hljs-string">（必需）</span>     <span class="hljs-comment"># 必须有 </span><br><span class="hljs-attr">version:</span> <span class="hljs-string">语义化2</span> <span class="hljs-string">版本（必需）</span> <span class="hljs-comment"># 必须有</span><br><br><span class="hljs-attr">kubeVersion:</span> <span class="hljs-string">兼容Kubernetes版本的语义化版本（可选）</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">一句话对这个项目的描述（可选）</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">chart类型</span> <span class="hljs-string">（可选）</span><br><span class="hljs-attr">keywords:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">关于项目的一组关键字（可选）</span><br><span class="hljs-attr">home:</span> <span class="hljs-string">项目home页面的URL</span> <span class="hljs-string">（可选）</span><br><span class="hljs-attr">sources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">项目源码的URL列表（可选）</span><br><span class="hljs-attr">dependencies:</span> <span class="hljs-comment"># chart 必要条件列表 （可选）</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">chart名称</span> <span class="hljs-string">(nginx)</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">chart版本</span> <span class="hljs-string">(&quot;1.2.3&quot;)</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">（可选）仓库URL</span> <span class="hljs-string">(&quot;https://example.com/charts&quot;)</span> <span class="hljs-string">或别名</span> <span class="hljs-string">(&quot;@repo-name&quot;)</span><br>    <span class="hljs-attr">condition:</span> <span class="hljs-string">（可选）</span> <span class="hljs-string">解析为布尔值的yaml路径，用于启用/禁用chart</span> <span class="hljs-string">(e.g.</span> <span class="hljs-string">subchart1.enabled</span> <span class="hljs-string">)</span><br>    <span class="hljs-attr">tags:</span> <span class="hljs-comment"># （可选）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">用于一次启用/禁用</span> <span class="hljs-string">一组chart的tag</span><br>    <span class="hljs-attr">import-values:</span> <span class="hljs-comment"># （可选）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ImportValue</span> <span class="hljs-string">保存源值到导入父键的映射。每项可以是字符串或者一对子/父列表项</span><br>    <span class="hljs-attr">alias:</span> <span class="hljs-string">（可选）</span> <span class="hljs-string">chart中使用的别名。当你要多次添加相同的chart时会很有用</span><br><br><span class="hljs-attr">maintainers:</span> <span class="hljs-comment"># （可选） # 可能用到</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">维护者名字</span> <span class="hljs-string">（每个维护者都需要）</span><br>    <span class="hljs-attr">email:</span> <span class="hljs-string">维护者邮箱</span> <span class="hljs-string">（每个维护者可选）</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">维护者URL</span> <span class="hljs-string">（每个维护者可选）</span><br><br><span class="hljs-attr">icon:</span> <span class="hljs-string">用做icon的SVG或PNG图片URL</span> <span class="hljs-string">（可选）</span><br><span class="hljs-attr">appVersion:</span> <span class="hljs-string">包含的应用版本（可选）。不需要是语义化，建议使用引号</span><br><span class="hljs-attr">deprecated:</span> <span class="hljs-string">不被推荐的chart</span> <span class="hljs-string">（可选，布尔值）</span><br><span class="hljs-attr">annotations:</span><br>  <span class="hljs-attr">example:</span> <span class="hljs-string">按名称输入的批注列表</span> <span class="hljs-string">（可选）.</span><br></code></pre></td></tr></table></figure><p>只有三个是<code>必填的</code>,在本例子中可以这样写</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">nginx-helm</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><h3 id="values-yaml"><a href="#values-yaml" class="headerlink" title="values.yaml"></a>values.yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">image:</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">tag:</span> <span class="hljs-string">&#x27;1.19.8&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="templates"><a href="#templates" class="headerlink" title="templates"></a>templates</h3><p>根据具体需求写k8s的资源清单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 本例子中部署个deployment</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-helm-&#123;&#123;</span> <span class="hljs-string">.Values.image.repository</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-comment"># 通过.Values访问上面定义的&#x27;变量&#x27;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-helm</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-helm</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-helm</span><br>        <span class="hljs-attr">image:</span> &#123;&#123; <span class="hljs-string">.Values.image.repository</span> &#125;&#125;<span class="hljs-string">:&#123;&#123;</span> <span class="hljs-string">.Values.image.tag</span> <span class="hljs-string">|</span> <span class="hljs-string">default</span> <span class="hljs-string">&quot;lastest&quot;</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm package wordpress/<br></code></pre></td></tr></table></figure><h3 id="发布-拉取-应用-升级本地包"><a href="#发布-拉取-应用-升级本地包" class="headerlink" title="发布&#x2F;拉取&#x2F;应用&#x2F;升级本地包"></a>发布&#x2F;拉取&#x2F;应用&#x2F;升级本地包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm repo add myrepo https://example.com/charts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发布</span><br>helm push wordpress-0.1.0.tgz myrepo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取,它会下载与一个.tar.gz包到本地</span><br>helm pull myrepo/wordpress --version &lt;version&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压后应用本地包</span><br>tar -xvf wordpress-&lt;version&gt;.tgz<br>helm install mywordpress ./wordpress<br>helm upgrade mywordpress ./wordpress<br></code></pre></td></tr></table></figure><h3 id="安装Release"><a href="#安装Release" class="headerlink" title="安装Release"></a>安装Release</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">helm install mywordpress myrepo/wordpress<br></code></pre></td></tr></table></figure><h3 id="更新chart"><a href="#更新chart" class="headerlink" title="更新chart"></a>更新chart</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地编辑Chart配置或添加新的依赖项；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用helm package命令打包新的Chart版本；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用helm push命令将新的Chart版本推送到Repository中；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用helm repo update命令更新本地或远程的Helm Repository；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用helm upgrade命令升级现有Release到新的Chart版本</span><br>helm upgrade mywordpress myrepo/wordpress --version 0.2.0<br></code></pre></td></tr></table></figure><h3 id="管理Release"><a href="#管理Release" class="headerlink" title="管理Release"></a>管理Release</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前运行的Release列表</span><br>helm ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级mywordpress release的image tag为5.7.3-php8.0-fpm-alpine (热补丁Release), 执行这个命令后release会自动重启应用最新的配置</span><br>helm upgrade mywordpress myrepo/wordpress --set image.tag=5.7.3-php8.0-fpm-alpine<br><span class="hljs-meta prompt_"># </span><span class="language-bash">回滚release</span><br>helm rollback mywordpress 1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除</span><br>helm uninstall mywordpress<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除release相关的PVC</span><br>helm uninstall mywordpress --delete-data<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Helm 客户端不会等到所有资源都运行才退出，可以使用 helm status 来追踪 release 的状态，或是重新读取配置信息</span><br>helm status mywordpress<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"></span><br><span class="language-bash">NAME: mynginx</span><br>LAST DEPLOYED: Fri Oct 29 14:27:32 2021<br>NAMESPACE: default<br>STATUS: deployed<br>REVISION: 1<br>TEST SUITE: None<br></code></pre></td></tr></table></figure><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>k8s集群支持多种类型的共享存储,将共享存储作为存储类(storage class)资源创建后,再根据实际需求创建PVC,集群就会自动创建对应的pv给pod使用.<code>ceph</code>是主流的共享存储方案,但是ceph十分重,需要额外为它部署运维一个单独的集群.有没有适合中小型集群,原生适配k8s容器环境,轻量灵活,性能好,具备高可用易运维的存储选择呢?</p><h2 id="OpenEbs"><a href="#OpenEbs" class="headerlink" title="OpenEbs"></a>OpenEbs</h2><p>参考:</p><p><a href="https://weiliang-ms.github.io/wl-awesome/2.%E5%AE%B9%E5%99%A8/k8s/storage/OpenEBS.html#openebs">OpenEBS工作笔记</a></p><p><a href="https://openebs.io/docs/">官方文档</a></p><h3 id="vs-Ceph"><a href="#vs-Ceph" class="headerlink" title="vs Ceph"></a>vs Ceph</h3><table><thead><tr><th></th><th>OpenEBS</th><th>Ceph</th></tr></thead><tbody><tr><td>性能</td><td>适合中小型规模</td><td>适合大型规模,适用于有高吞吐和横向扩展的需求场景</td></tr><tr><td>特性与功能</td><td>提供灵活易用的存储解决方案,比如动态卷,快照以及针对不同场景设计的存储引擎</td><td>提供大而全的功能,包括块存储,文件系统和对象存储,提供高级特性,比如自我修复和数据重复消除.</td></tr><tr><td>可靠性和冗余</td><td>多副本+快照</td><td>ceph以弹性和高可靠性闻名</td></tr><tr><td>扩展性和灵活</td><td>易与水平扩展</td><td>无限扩展,可以容纳非常大规模(PB级别)的存储集群</td></tr><tr><td>社区与生态</td><td>云原生计算基金会(CNCF)沙箱项目,项目较新</td><td>经过长时间实践验证的项目,拥有庞大且活跃的社区</td></tr></tbody></table><h3 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h3><p>openebs依赖<code>iSCSI</code>服务,集群每个节点都要安装并启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install iscsi-initiator-utils -y<br>systemctl enable --now iscsid <br></code></pre></td></tr></table></figure><p>使用helm部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">可以直接安装</span><br>helm install openebs --namespace openebs openebs/openebs --create-namespace<br><span class="hljs-meta prompt_"># </span><span class="language-bash">最好还是pull下来再安装</span><br>helm repo add openebs https://openebs.github.io/charts<br>helm repo update<br>helm pull openebs/openebs<br>tar -xvf openebs.xxx.tgz<br>helm install openebs ./openebs --namespace openebs --create-namespace<br><span class="hljs-meta prompt_"># </span><span class="language-bash">pod都running了即部署完成</span><br>kubectl get pods -n openebs<br></code></pre></td></tr></table></figure><p>会创建以下资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@k8s-master-1 yaml]# kubectl get all -n openebs<br>NAME                                               READY   STATUS    RESTARTS   AGE<br>pod/openebs-localpv-provisioner-56d6489bbc-b5c4p   1/1     Running   0          11m<br>pod/openebs-ndm-hxp2s                              1/1     Running   0          11m<br>pod/openebs-ndm-jl2gr                              1/1     Running   0          11m<br>pod/openebs-ndm-operator-5d7944c94d-9rm9b          1/1     Running   0          11m<br><br>NAME                         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE<br>daemonset.apps/openebs-ndm   2         2         2       2            2           &lt;none&gt;          11m<br><br>NAME                                          READY   UP-TO-DATE   AVAILABLE   AGE<br>deployment.apps/openebs-localpv-provisioner   1/1     1            1           11m<br>deployment.apps/openebs-ndm-operator          1/1     1            1           11m<br><br>NAME                                                     DESIRED   CURRENT   READY   AGE<br>replicaset.apps/openebs-localpv-provisioner-56d6489bbc   1         1         1       11m<br>replicaset.apps/openebs-ndm-operator-5d7944c94d          1         1         1       11m<br><br>[root@k8s-master-1 yaml]# kubectl get sc<br>NAME               PROVISIONER        RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE<br>openebs-device     openebs.io/local   Delete          WaitForFirstConsumer   false                  13m<br>openebs-hostpath   openebs.io/local   Delete          WaitForFirstConsumer   false                  13m<br></code></pre></td></tr></table></figure><blockquote><ol><li><p><strong>pod&#x2F;openebs-localpv-provisioner-</strong>:<br>这个Pod是Local PV Provisioner，它用于动态地为基于本地存储的PersistentVolume (PV) 分配PersistentVolumeClaims (PVC)。它监听PVC的创建和删除请求，并为它们分配和回收PV资源。</p></li><li><p><strong>pod&#x2F;openebs-ndm-</strong>*:<br>这些是Node Device Manager (NDM)的Pod。NDM是一个Kubernetes DaemonSet，它运行在集群的每个节点上。它的作用是发现节点上的块存储设备并报告它们的状态，这样就可以用来创建OpenEBS卷。</p></li><li><p><strong>pod&#x2F;openebs-ndm-operator-</strong>:<br>NDM operator是负责管理NDM DaemonSet的一个组件。它处理节点上的块设备的发现和管理，并且维护与这些设备相关的资源如BlockDevice。</p></li><li><p><strong>daemonset.apps&#x2F;openebs-ndm</strong>:<br>这是NDM的DaemonSet，它确保NDM Pod在集群中的每个节点上都有一个运行实例。</p></li><li><p><strong>deployment.apps&#x2F;openebs-localpv-provisioner</strong>:<br>这是Local PV Provisioner的Deployment，确保提供一个稳定的运行环境和必要的副本数量。</p></li><li><p><strong>deployment.apps&#x2F;openebs-ndm-operator</strong>:<br>这是NDM Operator的Deployment，负责部署和管理NDM Operator。</p></li><li><p><strong>storageclass (sc)</strong>: </p><ul><li><strong>openebs-device</strong>: 这个StorageClass用于提供基于设备（如磁盘分区或整个磁盘）的本地PV。</li><li><strong>openebs-hostpath</strong>: 这个StorageClass用于提供基于宿主机路径的本地PV。与基于设备的PV不同，它使用节点上的文件系统路径来提供存储。</li></ul></li></ol><ul><li><code>RECLAIMPOLICY</code>的值<code>Delete</code>表示当一个PV被释放时，与之关联的物理存储将被清空。</li><li><code>VOLUMEBINDINGMODE</code>的值<code>WaitForFirstConsumer</code>意味着PV的创建和绑定将延迟到PVC被Pod引用之后。</li><li><code>ALLOWVOLUMEEXPANSION</code>的值<code>false</code>表示PVC在创建后无法动态扩容。</li></ul></blockquote><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>OpenEBS提供多种多样的存储引擎去适配不同的使用场景,<code>不同的存储引擎对应一个或多个存储类</code>,在k8s中通过存储类定义使用.</p><table><thead><tr><th align="center">应用需求</th><th align="center">存储类型</th><th align="center">OpenEBS卷类型</th></tr></thead><tbody><tr><td align="center">低时延、高可用性、同步复制、快照、克隆、精简配置</td><td align="center">SSD&#x2F;云存储卷</td><td align="center">OpenEBS Mayastor</td></tr><tr><td align="center">高可用性、同步复制、快照、克隆、精简配置</td><td align="center">机械&#x2F;SSD&#x2F;云存储卷</td><td align="center">OpenEBS cStor</td></tr><tr><td align="center">高可用性、同步复制、精简配置</td><td align="center">主机路径或外部挂载存储</td><td align="center">OpenEBS Jiva</td></tr><tr><td align="center">低时延、本地PV</td><td align="center">主机路径或外部挂载存储</td><td align="center">Dynamic Local PV - Hostpath, Dynamic Local PV - Rawfile</td></tr><tr><td align="center">低时延、本地PV</td><td align="center">本地机械&#x2F;SSD&#x2F;云存储卷等块设备</td><td align="center">Dynamic Local PV - Device</td></tr><tr><td align="center">低延迟，本地PV，快照，克隆</td><td align="center">本地机械&#x2F;SSD&#x2F;云存储卷等块设备</td><td align="center">OpenEBS Dynamic Local PV - ZFS , OpenEBS Dynamic Local PV - LVM</td></tr></tbody></table><p>每种存储类的配置可能会有所不同，例如，你可能需要为存储类指定路径、节点亲和性规则、大小限制等参数。当创建 PersistentVolumeClaim (PVC) 时，将根据指定的存储类参数来动态创建符合请求的 PersistentVolume (PV)。</p><p>存储类和存储引擎的绑定主要是通过存储类中特定字段来指定,例如:</p><blockquote><p>openebs.io&#x2F;cas-type: local</p><p>openebs.io&#x2F;cas-type: jiva</p><p>openebs.io&#x2F;cas-type: cstor</p></blockquote><h3 id="LocalPV"><a href="#LocalPV" class="headerlink" title="LocalPV"></a>LocalPV</h3><blockquote><p>一个高性能的解决方案,提供本地存储设备(磁盘,目录或分区)的直接访问,相比网络存储,有更高的吞吐和更低的延迟</p></blockquote><ul><li>openebs-hostpath类</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建存储类,默认自动创建</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>     <span class="hljs-attr">name:</span> <span class="hljs-string">openebs-hostpath</span><br>   <span class="hljs-attr">provisioner:</span> <span class="hljs-string">openebs.io/local</span><br>   <span class="hljs-attr">volumeBindingMode:</span> <span class="hljs-string">WaitForFirstConsumer</span><br>   <span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span><br>   <span class="hljs-attr">parameters:</span><br>     <span class="hljs-attr">hostpath:</span> <span class="hljs-string">&quot;/var/openebs/local/&quot;</span><br>     <span class="hljs-attr">nodeAffinityLabel:</span> <span class="hljs-string">&quot;kubernetes.io/hostname&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建pvc并使用</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-local-pv</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">openebs-hostpath</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mypod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mycontainer</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/var/www/html&quot;</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">storage</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">storage</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">my-local-pv</span><br></code></pre></td></tr></table></figure><p>你会发现pv会自动创建,并且使用了openebs-hostpath类定义的路径来挂载存储卷,到容器里面往挂载目录随意放点文件,你会发现文件就放在pod运行的node的对应本地路径.</p><ul><li><p>openebs-device类</p><p>该存储类可以自动发现节点上的空闲裸设备(比如没有格式化的硬盘)</p></li><li><p>openebs local pv-zfs类</p><p>如果节点上安装了ZFS,并希望利用ZFS的优势(快照,复制等)可以使用ZFS作为底层文件系统</p></li></ul><h3 id="cStor"><a href="#cStor" class="headerlink" title="cStor"></a>cStor</h3><blockquote><p>基于容器的存储解决方案,提供快照,克隆,复制等高级功能.数据存储在cStor池中,由cStor Volums提供PVs供pod使用.具备高可用性和数据保持性.</p></blockquote><p>部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改镜像地址使用国内代理</span><br>sed -i s&#x27;+registry.k8s.io+k8s.dockerproxy.com+&#x27; openebs/charts/cstor/values.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级helm release</span><br>helm upgrade openebs ./openebs --set cstor.enabled=true --reuse-values --namespace openebs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">部署成功</span><br>[root@k8s-master-1 cstor]# kubectl get pods -n openebs<br>NAME                                             READY   STATUS    RESTARTS   AGE<br>openebs-cstor-admission-server-bbbd5c54f-s2tdj   1/1     Running   0          7m46s<br>openebs-cstor-csi-controller-0                   6/6     Running   0          7m45s<br>openebs-cstor-csi-node-bbpwr                     2/2     Running   0          7m46s<br>openebs-cstor-csi-node-r7mlj                     2/2     Running   0          7m46s<br>openebs-cstor-cspc-operator-799f9b45d4-lctnv     1/1     Running   0          7m46s<br>openebs-cstor-cvc-operator-687bbb7d8f-lsdvh      1/1     Running   0          7m46s<br>...<br></code></pre></td></tr></table></figure><blockquote><ol><li><p><strong>openebs-cstor-admission-server</strong><br>这个 Pod 运行了一个 admission webhook 服务器，它负责接收并处理 Kubernetes 的 admission webhook 请求。当你创建或更新关于 cStor 的资源时，它会确保请求遵守预设的规则。</p></li><li><p><strong>openebs-cstor-csi-controller</strong><br>CSI (容器存储接口) controller 服务负责协调和管理存储卷的生命周期，包括 Provisioning（提供）、Attaching（附加）、Detaching（分离）以及 Snapshotting（快照）等操作。这个 Pod 有 6 个容器，每一个都运行特定的服务，例如驱动注册、控制器服务等。</p></li><li><p><strong>openebs-cstor-csi-node</strong><br>这些 Pod 运行在群集的每个节点上，它们实现了 CSI node 服务，使得节点能够在本地挂载和卸载存储卷。每个 pod 有 2 个容器，通常一个是 node-driver-registrar 用于管理节点上的 CSI 驱动注册，另一个是 cstor-csi-plugin 用于管理 cStor 特有的卷操作。</p></li><li><p><strong>openebs-cstor-cspc-operator</strong><br>CSPC (CStorPoolCluster) Operator 监控和管理 cStor 池集群的生命周期。简单来说，它用来自动配置和管理存储池集群的那些由硬盘构成的资源。</p></li><li><p><strong>openebs-cstor-cvc-operator</strong><br>CVC (CStorVolumeConfig) Operator 负责管理 cStor 卷配置的生命周期，包括卷的创建、扩容、快照以及其他相关操作。它确保了持久卷的动态供给与管理。</p></li></ol></blockquote><p>节点上空闲的裸设备会被自动识别添加为blockdevice资源,并自动创建对应的bdc资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get bd -n openebs<br>kubectl get bdc -n openebs<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建存储池cspc</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cstor.openebs.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CStorPoolCluster</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">cstor-disk-pool</span><br> <span class="hljs-attr">namespace:</span> <span class="hljs-string">openebs</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">pools:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">nodeSelector:</span><br>       <span class="hljs-attr">kubernetes.io/hostname:</span> <span class="hljs-string">&quot;k8s-worker-1&quot;</span> <span class="hljs-comment"># kubectl get nodes --show-labels (kubernetes.io/hostname)</span><br>     <span class="hljs-attr">dataRaidGroups:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">blockDevices:</span><br>           <span class="hljs-bullet">-</span> <span class="hljs-attr">blockDeviceName:</span> <span class="hljs-string">&quot;blockdevice-5aeaf5f89794edf391f4394a6f7eb47e&quot;</span> <span class="hljs-comment"># 填写对应的bd</span><br>     <span class="hljs-attr">poolConfig:</span><br>       <span class="hljs-attr">dataRaidGroupType:</span> <span class="hljs-string">&quot;stripe&quot;</span><br><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">nodeSelector:</span><br>       <span class="hljs-attr">kubernetes.io/hostname:</span> <span class="hljs-string">&quot;k8s-worker-2&quot;</span><br>     <span class="hljs-attr">dataRaidGroups:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-attr">blockDevices:</span><br>           <span class="hljs-bullet">-</span> <span class="hljs-attr">blockDeviceName:</span> <span class="hljs-string">&quot;blockdevice-4dad35da68321cd86eeeb9a085ed0f83&quot;</span><br>     <span class="hljs-attr">poolConfig:</span><br>       <span class="hljs-attr">dataRaidGroupType:</span> <span class="hljs-string">&quot;stripe&quot;</span><br><br><span class="hljs-comment"># 创建cstor存储类</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cstor-csi-disk</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">cstor.csi.openebs.io</span><br><span class="hljs-attr">allowVolumeExpansion:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">cas-type:</span> <span class="hljs-string">cstor</span><br>  <span class="hljs-comment"># cstorPoolCluster should have the name of the CSPC</span><br>  <span class="hljs-attr">cstorPoolCluster:</span> <span class="hljs-string">cstor-disk-pool</span><br>  <span class="hljs-comment"># replicaCount should be &lt;= no. of CSPI created in the selected CSPC</span><br>  <span class="hljs-attr">replicaCount:</span> <span class="hljs-string">&quot;2&quot;</span><br></code></pre></td></tr></table></figure><p>按平时使用存储卷一样写PVC和POD即可使用存储资源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-statefulset</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">example</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;example&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">example</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example-container</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/www/html</span><br><br>  <span class="hljs-attr">volumeClaimTemplates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">data</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">&quot;cstor-csi-disk&quot;</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><h2 id="试用总结"><a href="#试用总结" class="headerlink" title="试用总结"></a>试用总结</h2><p>使用path类型的localPV还是比较简单方便地,但是我在试用裸设备的localPV时候却遇到了pv建立失败的问题,不知道是不是虚拟机的原因.而cStor使用起来也比较麻烦,因为它涉及的中间组件(CRD)有点多,没创建一个新的pvc它都要创建对应的pod去管理,使得创建删除的过程有点慢,也容易出问题.</p><h1 id="集群高可用负载均衡方案"><a href="#集群高可用负载均衡方案" class="headerlink" title="集群高可用负载均衡方案"></a>集群高可用负载均衡方案</h1><p><a href="https://github.com/kubernetes/kubeadm/blob/main/docs/ha-considerations.md#kube-vip">参考文档</a></p><blockquote><p><strong>kube-vip + HAProxy</strong></p><p>优点：</p><ol><li>kube-vip 是 Kubernetes 原生的解决方案，专为 Kubernetes 设计，易于与 Kubernetes 集群集成。</li><li>kube-vip 可以提供控制平面和服务的高可用性地址。</li><li>它具有负载均衡(不完整)和虚拟IP管理的双重功能，简化了配置。</li></ol><p>缺点：</p><ol><li>kube-vip 相对较新，社区支持和成熟度可能不如使用了更长时间的 keepalived。</li><li>对于一些用户来说，kube-vip 可能需要更多的学习和调试时间。</li></ol><hr><p><strong>keepalived + HAProxy</strong></p><p>优点：</p><ol><li>keepalived 是一种成熟的解决方案，已经被广泛使用和测试，具有稳定的社区支持。</li><li>它使用 VRRP 协议来实现高可用性，自动故障转移。</li><li>keepalived 和 HAProxy 的组合允许高度定制和灵活配置。</li></ol><p>缺点：</p><ol><li>配置相对复杂，需要对 keepalived 和 HAProxy 有较深理解。</li><li>不如 kube-vip 原生集成到 Kubernetes，可能需要更多的外部依赖和脚本来管理。</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kakfa-必知必会</title>
    <link href="/2024/02/03/kafka-must-know/"/>
    <url>/2024/02/03/kafka-must-know/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202207022349292.png" srcset="/img/loading.gif" lazyload></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>分布式流处理平台，它提供了一种高吞吐量、可持久化的消息传递系统.kafka本身没有管理配置和注册功能,所以kafka集群强依赖zookeeper,用于存储meta数据以及选举.</p><p>Kafka 的设计目标是提供<code>高吞吐量</code>和<code>分布式处理能力</code>,而不是保证消息的顺序,很多时候消息的顺序问题要在消费者上进行处理.</p><p>kafka增加和减少服务器都会在Zookeeper节点上触发相应2的事件kafka系统会捕获这些事件，进行新一轮的负载均衡，客户端(consumer)也会捕获这些事件来进行新一轮的处理.</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="producer-consumer"><a href="#producer-consumer" class="headerlink" title="producer&#x2F;consumer"></a>producer&#x2F;consumer</h2><p>生产者和消费者,严格来说不属于kafka这个软件的一部分,但是kafka是一个消息队列系统,所以一定要有生产者和消费者的组成.</p><ul><li><code>生产者</code>是向kafka 的topic <code>push</code> 消息,每条消息都被追加(<code>append</code>)到<code>partition</code>中的客户端应用程序,消息的追加属于<code>顺序写磁盘</code>(比随机写磁盘效率高,保证吞吐率).它可以指定topic或partition发送消息.</li><li><code>消费者</code>是从kafka topic中读取消息的客户端应用程序,它可以通过订阅 Topic 来指定它们感兴趣的消息来源。当消费者订阅一个 Topic 后，它可以选择从特定的 Partition 中读取消息.</li></ul><h2 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h2><p>可以理解为一个<code>队列</code>,一个topic里可以有多个<code>partition</code></p><h2 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h2><p>一个kafka节点就是一个<code>broker</code>,replication也是以broker为单位存储,</p><h2 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h2><ul><li><p>partition是一个topic的<code>逻辑片段</code>或子分区</p></li><li><p>每个topic可以被分为多个Partition,每个partition是一个有序且持久化的消息队列</p></li><li><p>消息被发布到topic时,Kafka 会根据一定的策略将<code>不同的消息均匀地分配到不同的 Partition 中</code></p><blockquote><p>每个消息都有一个键<code>key</code>,kafka使用这个<code>key</code>来决定将消息发送到哪个partition.<code>key</code>可以为空,如果为空就是用<code>默认的分区策略</code>: 轮询</p><p>对于有键的消息，Kafka 使用的分区策略是根据消息键进行哈希计算，将具有相同键的消息分配到同一个 Partition 中，以保证具有相同键的消息被顺序地写入同一个 Partition</p></blockquote></li><li><p>partition让kafka具备了<code>水平扩展</code>和<code>并行处理</code>的能力.</p><blockquote><ul><li><p>水平扩展</p><p>将数据分散到多个partition中,并将这些partition分布在多个broker上.但数据量增加时,就可以简单地增加partition和broker的数量,提高整个系统的吞吐和容量.</p></li><li><p>并行处理</p><p>每个partition都是独立的消息队列,消费者可以并行地读取不同partition中的消息.这样多个消费者可以同时处理不同partition中的消息,实现并行处理.</p><ul><li>不同partition之间的消息是<code>无序</code>的,假如你的应用程序对消息的顺序有严格的要求,应该在消费者端对消息进行处理,比如消息中添加时间戳,消费者根据消息的时间戳对消息进行排序处理.</li></ul></li></ul></blockquote></li><li><p>消费者可以独立地从不同的partition中读取消息,实现<code>高吞吐</code>和<code>高并发</code>.</p><blockquote><p>kafka写入同一个partition中的消息的有序的,而consumer对单一partition的读取自然也是有序的.</p><p>但是如果有多个consumer并行地消费多个partition中时候,消息的顺序就无法保证.这是因为<code>kafka只保证了</code>partition内<code>的顺序性而不保证</code>partition之间<code>的顺序性</code>.</p></blockquote></li></ul><h2 id="replication"><a href="#replication" class="headerlink" title="replication"></a>replication</h2><p>kafka的副本机制提供了<code>高可用</code>和<code>容错性</code>.每个partition可以有多个副本,其中一个选为<code>leader</code>,其余为<code>follower</code>.leader和follower都对应一个broker.</p><ul><li>leader: 负责处理读写请求</li><li>follwer: 负责备份和故障转移.</li></ul><h2 id="offet"><a href="#offet" class="headerlink" title="offet"></a>offet</h2><p><code>偏移量</code>是一个与每条消息相关联的唯一标识符,用于表示消息在特定的partition中的位置.</p><h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><p>由多个消费者组成,共同消费一个或多个Topic中的消息.主要目的是实现<code>负载均衡</code>和<code>容错性</code></p><h2 id="消费者组与offset"><a href="#消费者组与offset" class="headerlink" title="消费者组与offset"></a>消费者组与offset</h2><p>在消费者组中，Kafka 会自动管理消费者的偏移量。当消费者启动或重新启动时，它会向 Kafka 提交自己的偏移量，并从该偏移量处开始消费消息。Kafka 会跟踪每个消费者组在每个 Partition 上的偏移量，并确保每个消费者在消费时都从正确的位置开始。需要注意的是，消费者组中的每个消费者必须有一个<code>唯一的消费者 ID</code>，以便 Kafka 能够跟踪每个消费者的偏移量</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p><code>/path-to-kafka/config/server.properties</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">broker.id=0  #当前机器在集群中的唯一标识，和zookeeper的myid性质一样<br>port=9092 #当前kafka对外提供服务的端口,默认是9092<br>host.name=192.168.7.100 #这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题。<br>num.network.threads=3 #这个是borker进行网络处理的线程数<br>num.io.threads=8 #这个是borker进行I/O处理的线程数<br>log.dirs=/opt/kafka/kafkalogs/<br>socket.send.buffer.bytes=102400 #发送缓冲区buffer大小，数据不是一下子就发送的，先回存储到缓冲区了到达一定的大小后在发送，能提高性能<br>socket.receive.buffer.bytes=102400 #kafka接收缓冲区大小，当数据到达一定大小后在序列化到磁盘<br>socket.request.max.bytes=104857600 #这个参数是向kafka请求消息或者向kafka发送消息的请请求的最大数，这个值不能超过java的堆栈大小<br>num.partitions=1 #默认的分区数，一个topic默认1个分区数<br>log.retention.hours=168 #默认消息的最大持久化时间，168小时，7天<br>message.max.byte=5242880  #消息保存的最大值5M<br>default.replication.factor=2  #kafka保存消息的副本数，如果一个副本失效了，另一个还可以继续提供服务<br>replica.fetch.max.bytes=5242880  #取消息的最大字节数<br>log.segment.bytes=1073741824 #这个参数是：因为kafka的消息是以追加的形式落地到文件，当超过这个值的时候，kafka会新起一个文件<br>log.retention.check.interval.ms=300000 #每隔300000毫秒去检查上面配置的log失效时间（log.retention.hours=168 ），到目录查看是否有过期的消息如果有，删除<br>log.cleaner.enable=false #是否启用log压缩，一般不用启用，启用的话可以提高性能<br>zookeeper.connect=192.168.7.100:12181,192.168.7.101:12181,192.168.7.107:1218 #设置zookeeper的连接端口<br></code></pre></td></tr></table></figure><h2 id="log-dirs"><a href="#log-dirs" class="headerlink" title="log.dirs"></a>log.dirs</h2><p>Kafka <code>使用日志文件来持久化存储消息</code>。</p><p><code>每个 Topic 的每个 Partition 都有一个对应的日志文件，用于存储该 Partition 中的消息。</code></p><p>当消息被写入到 Kafka 中时，它们首先被追加到当前的日志文件中，当日志文件达到一定大小或时间限制时，会被切分为较小的日志段（log segments）。</p><blockquote><p>要注意,这个路径存放的是<code>持久化数据</code>,也就是系统中真实的消息,实际生产中对该目录的处理应该小心,不能随意删除并做好备份.</p></blockquote><p><code>log.dirs</code> 参数可以配置一个或多个目录路径，用逗号分隔。Kafka 将按照指定的顺序在这些目录中创建日志文件和日志段。如果其中一个目录不可用（例如，磁盘故障），Kafka 会自动切换到下一个可用的目录进行日志的写入和读取。这样可以提高 Kafka 的可用性和容错性。</p><h2 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h2><p>默认位置: <code>/path-to-kafka/logs</code></p><p>有别于<code>log.dirs</code>,前者保存kafka的消息数据,<code>系统日志</code>指kafka自身的运行日志,主要有:</p><ul><li>server.log: kafka的运行日志</li><li>state-change.log: 用于记录 Kafka 服务器的状态变化信息。它包含了 Kafka 服务器的启动、关闭、分区分配、副本分配等重要事件的记录</li><li>controller.log:  <code>kafka&gt;=0.8</code></li></ul><h1 id="系统角色与选举"><a href="#系统角色与选举" class="headerlink" title="系统角色与选举"></a>系统角色与选举</h1><blockquote><p>kafka在0.8版本之前依赖zookeeper来选举.</p></blockquote><ul><li><p>Controller: <code>kafka&gt;=0.8</code>,kafka引入了自己的选举机制,不再依赖zookeeper.负责管理整个集群的状态和元数据,包括leader选举,分区分配,副本管理,topic管理等人物,每个kafka集群只有一个controller节点,由kafka集群内部的选举机制自动选举产生.</p></li><li><p>Leader: 负责接收生产者<code>push</code>的消息以及消费者的<code>pull</code>请求.<code>一个partition只能有一个leader</code>.</p><blockquote><p>Controller 的选举由 Kafka 集群内部的选举机制自动完成，而 Leader 的选举是在分区级别进行的，由 Controller 负责管理。</p><p>手动指定controller节点:</p><p>设置 <code>controller.quorum.voters</code> 参数，将其值设置为你希望成为 Controller 的 Broker ID 列表。然后重启 Kafka 集群，选举机制将会在这些 Broker 中选出一个作为 Controller。</p></blockquote></li><li><p>follower: 处于被动复制状态,作为leader的副本.同样是partition级别的角色.</p></li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><blockquote><p>下面所说的新版旧版，新版：&gt;&#x3D;0.9；旧版：&lt;&#x3D;0.8</p></blockquote><h5 id="1、查看topic列表"><a href="#1、查看topic列表" class="headerlink" title="1、查看topic列表"></a>1、查看topic列表</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/kafka-topics.sh --zookeeper 127.0.0.1:2181 --list<br></code></pre></td></tr></table></figure><h5 id="2、查看指定topic信息"><a href="#2、查看指定topic信息" class="headerlink" title="2、查看指定topic信息"></a>2、查看指定topic信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/kafka-topics.sh --zookeeper 127.0.0.1:2181 --topic lx_test_topic --describe<br></code></pre></td></tr></table></figure><h5 id="3、修改topic分区"><a href="#3、修改topic分区" class="headerlink" title="3、修改topic分区"></a>3、修改topic分区</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --zookeeper localhost:2181 -alter --partitions 4 --topic test<br></code></pre></td></tr></table></figure><h5 id="4、删除topic"><a href="#4、删除topic" class="headerlink" title="4、删除topic"></a>4、删除topic</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --zookeeper localhost:2181  --topic test  --delete<br></code></pre></td></tr></table></figure><h5 id="5、创建topic"><a href="#5、创建topic" class="headerlink" title="5、创建topic"></a>5、创建topic</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-topics.sh --zookeeper localhost:2181  --topic test --partitions 3 --replication-factor 1 --create<br></code></pre></td></tr></table></figure><h5 id="6、模拟客户端接收kafka消息"><a href="#6、模拟客户端接收kafka消息" class="headerlink" title="6、模拟客户端接收kafka消息"></a>6、模拟客户端接收kafka消息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">--max-messages 10 是指定消费10条数据</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--from-beginning 指定从最开始消费（最老的数据）,不配置，默认消费最新</span><br>./kafka-console-consumer.sh --zookeeper localhost:2181 --topic MUC_ORG --max-messages 10<br></code></pre></td></tr></table></figure><h5 id="7、模拟客户端发送消息"><a href="#7、模拟客户端发送消息" class="headerlink" title="7、模拟客户端发送消息"></a>7、模拟客户端发送消息</h5><p>直接用localhost可能会有报错，如果发生报错，可以将localhost改为IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-console-producer.sh --broker-list localhost:9092 --topic MUC_ORG<br></code></pre></td></tr></table></figure><h5 id="8、查看分组列表"><a href="#8、查看分组列表" class="headerlink" title="8、查看分组列表"></a>8、查看分组列表</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新版</span><br>./kafka-consumer-groups.sh --bootstrap-server 127.0.0.1:9092 --list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">旧版</span><br>./kafka-consumer-groups.sh --zookeeper 127.0.0.1:9092 --list<br></code></pre></td></tr></table></figure><h5 id="9、查看分组消费情况"><a href="#9、查看分组消费情况" class="headerlink" title="9、查看分组消费情况"></a>9、查看分组消费情况</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">新版0.9以上</span><br>./kafka-consumer-groups.sh  --bootstrap-server 127.0.0.1:9092 --group testgroup --describe<br><span class="hljs-meta prompt_"># </span><span class="language-bash">旧版0.8以下</span><br>./kafka-consumer-groups.sh --zookeeper localhost:2181 --group testgroup --describe <br></code></pre></td></tr></table></figure><h5 id="10、topic消费offset"><a href="#10、topic消费offset" class="headerlink" title="10、topic消费offset"></a>10、topic消费offset</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./kafka-consumer-offset-checker --zookeeper localhost :2181/kafka --group dev  --topic MUC_ORG<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>terraform-HCL语法</title>
    <link href="/2024/02/01/terraform-HCL/"/>
    <url>/2024/02/01/terraform-HCL/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/1*9-ILOQ1Yxautyc_uIguhVw.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>本文记录一些关于terraform的语法,只记录一下我认为有必要记录的东西,本文绝大部分来自教程: <a href="https://lonegunmanb.github.io/introduction-terraform/">https://lonegunmanb.github.io/introduction-terraform/</a></p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><ul><li>string</li><li>number</li><li>bool</li></ul><h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><ul><li><code>list(type)</code>: 下标从<code>0</code>开始,<code>list(number)/list(string)/list(bool)</code>,用于声明时指定list的元素类型</li><li><code>map(...)</code>: 字典&#x2F;映射,key必须是<code>string</code>,value任意类型.声明方式推荐使用<code>=</code>: <code>&#123;foo=&quot;bar&quot;, bar=&quot;baz&quot;&#125;</code></li><li><code>set(...)</code>: 集合类型,代表一组<code>不重复的值</code></li></ul><h2 id="结构化类型"><a href="#结构化类型" class="headerlink" title="结构化类型"></a>结构化类型</h2><blockquote><p>一个结构化类型允许多个不同类型的值组成一个类型.结构化类型需要提供一个<code>schema</code>结构信息作为参数来指明元素的结构.</p></blockquote><ul><li><p><code>object(...)</code>: 允许多个不同类型作为值的map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 声明&#123;&lt;KEY\=&lt;TYPE&gt;, &lt;KEY&gt;=&lt;TYPE&gt;,...&#125;<br>object(&#123;age=number, name=string&#125;)<br># 赋值时必须赋全,可以多,多的会被忽略<br>&#123; age=18, name=&quot;john&quot;, gender=&quot;male&quot; &#125; # 多出来的gender会被忽略<br></code></pre></td></tr></table></figure></li><li><p><code>tuple(...)</code>: 允许多个不同类型作为值的list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 声明<br>tuple([string, number, bool])<br># 赋值时类型和数量要一致<br>[&quot;a&quot;, 15, true]<br></code></pre></td></tr></table></figure></li></ul><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>terraform中一个特殊的类型约束,本身不是一个类型而是一个<code>占位符</code>,每当一个值被赋予<code>any</code>这个类型约束时,terraform会自动识别一个最精确的类型去取代<code>any</code>.</p><p>例如把<code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>赋值给<code>list(any)</code>, terraform最终赋值的类型是<code>list(string)</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 声明一个无约束类型的变量,给terraform自己识别<br>variable &quot;no_type_constraint&quot; &#123;<br>    type = any<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p><code>无类型</code>,代表数据缺失,如果我们将一个参数设置为<code>null</code>, terraform会认为你忘记给它赋值,如果有默认值就用默认值,没有默认值但是又是必填则会报错.</p><p>一般用于条件表达式中,在某项条件不满足时跳过对某参数的赋值.</p><h2 id="optional"><a href="#optional" class="headerlink" title="optional"></a>optional</h2><p><code>terraform &gt;= 1.3</code>引入的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 声明一个object<br>variable &quot;an_object&quot; &#123;<br>  type = object(&#123;<br>    a = string<br>    b = string<br>    c = number<br>  &#125;)<br>&#125;<br># 赋值时,必须赋齐全,但是又不准备给b,c赋值,可以用null<br>&#123;<br>  a = &quot;a&quot;<br>  b = null<br>  c = null<br>&#125;<br># 但是加入object含有的参数很多且复杂,我们赋值时就会很麻烦,于是引入optional,在定义时候使用<br>variable &quot;with_optional_attribute&quot; &#123;<br>  type = object(&#123;<br>    a = string                # a required attribute<br>    b = optional(string)      # an optional attribute<br>    c = optional(number, 127) # an optional attribute with default value<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>optional</code>有两个参数:</p><ul><li>类型: 必填,<code>第一个参数</code>标明属性的类型</li><li>默认值: 选填,如果object没有定义该属性,就使用默认值,没有默认值就使用<code>null</code></li></ul><p>所以optional<code>作用</code>如下: 定义这个参数的类型和默认值,如果没有赋值就使用默认值,如果没有默认值就赋值null.</p><h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 定义一个bucket变量,获取bucket需要的属性<br>variable &quot;buckets&quot; &#123;<br>    type = list(object(&#123;<br>        name = string<br>        enabled = optional(bool, true)<br>        website = optional(object(&#123;<br>            index_document = optional(string, &quot;index.html&quot;)<br>            error_document = optional(string, &quot;error.html&quot;)<br>            routing_rules = optional(string)<br>            &#125;), &#123;&#125;)<br>        &#125;))<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>这里定义嵌套比较复杂,只是为了演示用法.</p><p>首先<code>buckets</code>是一个类型为<code>list</code>的变量,<code>list</code>里面元素类型是<code>object</code></p><p><code>website</code>是一个<code>optional</code>属性,类型为<code>object</code>,里面又有三个<code>optional</code>属性.</p><p>下面是一个赋值例子:</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs terraform">buckets = [<br>  &#123;<br>    name = &quot;production&quot;<br>    website = &#123;<br>      routing_rules = &lt;&lt;-EOT<br>      [<br>        &#123;<br>          &quot;Condition&quot; = &#123; &quot;KeyPrefixEquals&quot;: &quot;img/&quot; &#125;,<br>          &quot;Redirect&quot;  = &#123; &quot;ReplaceKeyPrefixWith&quot;: &quot;images/&quot; &#125;<br>        &#125;<br>      ]<br>      EOT<br>    &#125;<br>  &#125;,<br>  &#123;<br>    name = &quot;archived&quot;<br>    enabled = false<br>  &#125;,<br>  &#123;<br>    name = &quot;docs&quot;<br>    website = &#123;<br>      index_document = &quot;index.txt&quot;<br>      error_document = &quot;error.txt&quot;<br>    &#125;<br>  &#125;,<br>]<br></code></pre></td></tr></table></figure><blockquote><p>上面定义三个存储桶</p><p><code>production</code>桶配置了一条重定向的路由规则</p><p><code>archived</code>桶使用默认配置,但是是关闭的</p><p><code>docs</code>桶使用文本文件取代索引页和错误页</p></blockquote><h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>下面结合<code>表达式</code>去<code>有条件地设置一个默认值</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs terraform">variable &quot;legacy_filenames&quot; &#123;<br>  type     = bool<br>  default  = false<br>  # 不能为空<br>  nullable = false<br>&#125;<br><br>module &quot;buckets&quot; &#123;<br>  source = &quot;./modules/buckets&quot;<br><br>  buckets = [<br>    &#123;<br>      name = &quot;maybe_legacy&quot;<br>      website = &#123;<br>        # 根据legacy_filenames的值设置默认值<br>        error_document = var.legacy_filenames ? &quot;ERROR.HTM&quot; : null<br>        index_document = var.legacy_filenames ? &quot;INDEX.HTM&quot; : null<br>      &#125;<br>    &#125;,<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs terraform">variable &quot;image_id&quot; &#123;<br>  type        = string<br>  description = &quot;The id of the machine image (AMI) to use for the server.&quot;<br><br>variable &quot;name&quot; &#123;<br>    # 类型<br>    type    = string<br>    # 默认值<br>    default = &quot;John Doe&quot;<br>    # 描述(描述不是注释)<br>    description = &quot;The id of the machine image (AMI) to use for the server.&quot;<br>    # 在命令行输出中隐藏敏感值(依旧会记录在statefile中) terraform &gt;= 0.14 在某些情况下还是会暴露出来<br>    sensitive = true<br>    # 不允许为空<br>    nullable = false<br>    # 断言terraform &gt;= 0.13, condition的值必须是bool<br>    validation &#123;<br>      condition     = length(var.image_id) &gt; 4 &amp;&amp; substr(var.image_id, 0, 4) == &quot;ami-&quot;<br>      error_message = &quot;The image_id value must be a valid AMI id, starting with \&quot;ami-\&quot;.&quot;<br>   &#125;<br>    # 使用can来判断获取bool<br>    validation &#123;<br>    condition     = can(regex(&quot;^ami-&quot;, var.image_id))<br>    error_message = &quot;The image_id value must be a valid AMI id, starting with \&quot;ami-\&quot;.&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>按以下优先级排序</p><ol><li><p>环境变量: <code>TF_VAR_name</code></p></li><li><p><code>terraform.tfvars</code>: 使用HCL语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terraform">image_id = &quot;ami-abc123&quot;<br>availability_zone_names = [<br>  &quot;us-east-1a&quot;,<br>  &quot;us-west-1c&quot;,<br>]<br></code></pre></td></tr></table></figure></li><li><p><code>terraform.tfvars.json</code>: 使用json语法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;image_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ami-abc123&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;availability_zone_names&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;us-west-1a&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;us-west-1c&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><code>*.auto.tfvars</code>或<code>*.auto.tfvars.json</code>,以文件名字母排序,同样一个HCL一个json</p></li><li><p><code>-var</code>参数或者<code>-var-filr</code></p></li><li><p>交互界面获取值</p></li></ol><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terraform">var.availability_zone_names<br></code></pre></td></tr></table></figure><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs terraform">output &quot;instance_ip_addr&quot; &#123;<br>  value       = aws_instance.server.private_ip<br>  description = &quot;The private IP address of the main server instance.&quot;<br>  sensitive = true<br><br>  # 一般output不需要定义depends_on,如果要用到请写好注释<br>  depends_on = [<br>    # Security group rule must be created before this IP address could<br>    # actually be used, otherwise the services will be unreachable.<br>    aws_security_group_rule.local_access,<br>  ]<br>  # 类似validation块的validation,确保输出值满足某种要求,防止terraform把不合法的值写入状态文件<br>  # Precondition<br>  condition = var.enable_example_output<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>关于<code>depends_on</code>: 依赖关系是通过terraform的provider去分析的,一般是不需要显式定义,但有时候它不能计算出来(比如terraform或者provider的版本过旧,对一些新资源不能很好地计算,就需要用到depends_on)</p></blockquote><h1 id="locals"><a href="#locals" class="headerlink" title="locals"></a>locals</h1><p><code>locals</code>块用于定义本地变量,只能在<code>同一模块</code>内的代码中引用.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs terraform">locals &#123;<br>  common_tags = &#123;<br>    # 注意引用是使用local,声明使用locals<br>    Service = local.service_name<br>    Owner   = local.owner<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一般来说,只有需要重复引用同一个复杂表达式的场景才使用locals</p></blockquote><h1 id="resource"><a href="#resource" class="headerlink" title="resource"></a>resource</h1><p>定义具体资源的块,也是接触最多的块.不同平台的不同资源的定义都有所不同,具体要查看具体平台具体资源的文档.</p><p><a href="https://registry.terraform.io/browse/providers">terraform-registry文档</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># resource关键字 resource_type local_name<br>resource &quot;aws_instance&quot; &quot;web&quot; &#123;<br>  ami           = &quot;ami-a1b2c3d4&quot;<br>  instance_type = &quot;t2.micro&quot;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>local_name只能在同一个模块内被引用,resource_type+local_name在同一个模块内必须是唯一</p></blockquote><h2 id="资源行为"><a href="#资源行为" class="headerlink" title="资源行为"></a>资源行为</h2><blockquote><p>当terraform对一个resource块执行apply操作,创建一个新的基础设施对象,会给这个对象分配一个<code>id</code>,并写入statefile.有了这个id,后续就可以对它对更新修改删除等操作.</p></blockquote><h2 id="resource的输出"><a href="#resource的输出" class="headerlink" title="resource的输出"></a>resource的输出</h2><p>通过以下语法获取resource的输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terraform">&lt;RESOURCE TYPE&gt;.&lt;NAME&gt;.&lt;ATTRIBUTE&gt;<br></code></pre></td></tr></table></figure><p>具体的resource有哪些<code>attribute</code>供访问可以通过查阅registry文档获取.</p><h2 id="依赖与并行"><a href="#依赖与并行" class="headerlink" title="依赖与并行"></a>依赖与并行</h2><blockquote><p><code>depends_on</code>用于显式声明资源的依赖关系.</p><p>一般情况下,terraform自身可以通过分析resource块内的<code>表达式</code>,根据表达式的<code>引用链</code>获取资源在创建,更新,销毁时的执行顺序.</p><p>但是有些时候是计算不出来的:</p><p>例如，Terraform必须要创建一个访问控制权限资源，以及另一个需要该权限才能成功创建的资源。<code>后者的创建依赖于前者的成功创建</code>，然而这种依赖在代码中没有表现为<code>数据引用关联</code>,此时就需要<code>depends_on</code></p></blockquote><blockquote><p>默认情况下,terraform可以并行创建<code>10</code>个<code>无依赖关系</code>的资源.</p></blockquote><h2 id="元参数"><a href="#元参数" class="headerlink" title="元参数"></a>元参数</h2><p>定义在resource块内,用于改变资源的行为,上面提到的<code>depends_on</code>就是其中一个.</p><h3 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h3><blockquote><p>显示声明资源之间的依赖关系,只有当资源间确实存在依赖关系,但是彼此间又没有数据引用的场景下才有必要使用</p></blockquote><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count</code>指创建多少个相似的对象,创建的对象有单独的id和下标(0开始)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs terraform">resource &quot;aws_instance&quot; &quot;server&quot; &#123;<br>  count = 4 # create four similar EC2 instances<br><br>  ami           = &quot;ami-a1b2c3d4&quot;<br>  instance_type = &quot;t2.micro&quot;<br><br>  tags = &#123;<br>    Name = &quot;Server $&#123;count.index&#125;&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>count.index</code>:代表当前对象对应的下标</li><li>访问: <code>&lt;TYPE&gt;.&lt;NAME&gt;[&lt;INDEX&gt;]</code></li><li>count的值可以是<code>任意自然数</code>也可以是<code>表达式</code>,但是不能引用任何其他资源的输出属性,不过可以应用<code>data</code>查询出来的输出属性(只要该data不依赖其他resource查询)</li></ul><h3 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h3><p>用于创建多个相似但有些属性不一样的资源</p><blockquote><p>terraform &gt;&#x3D; 0.12.6, 不能与<code>count</code>同时用在一个resource块内</p></blockquote><p><code>for_each</code>的值可以是<code>map</code>(通过<code>each.key</code>和<code>each.value</code>获取值)或者<code>set(string)</code>(通过<code>each.key</code>获取值)</p><p><code>for_each</code>所使用的键集合不能够包含或依赖非纯函数，也就是反复执行会返回不同返回值的函数(uuid, bcrypt, timestamp)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 使用map<br>resource &quot;azurerm_resource_group&quot; &quot;rg&quot; &#123;<br>  for_each = &#123;<br>    a_group = &quot;eastus&quot;<br>    another_group = &quot;westus2&quot;<br>  &#125;<br>  name     = each.key<br>  location = each.value<br>&#125;<br># 使用set(string)<br>resource &quot;aws_iam_user&quot; &quot;the-accounts&quot; &#123;<br>  for_each = toset( [&quot;Todd&quot;, &quot;James&quot;, &quot;Alice&quot;, &quot;Dottie&quot;] )<br>  name     = each.key<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p>resource块内可以通过provider关键字声明该资源使用的provider.默认情况下,使用<code>资源类型第一个单词</code>所对应的provider.</p><p>比如<code>google_compute_instance</code>的默认provider就是<code>google</code>,<code>aws_instance</code>的默认Provider就是<code>aws</code>.</p><h3 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h3><p>针对一个资源对象定义不一样的行为方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs terraform">resource &quot;azurerm_resource_group&quot; &quot;example&quot; &#123;<br>  # ...<br><br>  lifecycle &#123;<br>    create_before_destroy = true<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>lifecycle和它的参数都属于元参数,可以被声明于任意类型的资源块内部.有如下的参数:</p><ul><li><p><code>create_before_destroy</code> (<code>bool</code>): 默认情况下,需要修改一个由于服务端API限制无法直接升级的资源时,terraform会<code>先删除旧对象</code>再<code>创建新对象</code>.本参数可以修改这个行为.设置为<code>true</code>,就会先创建新对象,新对象创建成功并取代老对象后再删除老对象.<code>默认</code>是false,因为大部分技术设施资源都需要有一个<code>唯一</code>的标识来防止冲突,即使在新老对象并存的时候也有有这个约束.但有些资源可以为每个对象添加一个随机的前缀来避免冲突,具体要看具体的资源类型在这方面的约束.</p></li><li><p><code>prevent_destroy</code> (<code>bool</code>): 这是一个<code>保险措施</code>,避免资源因为错误的执行<code>terraform destroy</code>或者因为错误地修改了某个参数导致<code>terraform决定删除并重建新的实例</code>这种情况下资源被删除.</p></li><li><p><code>ignore_changes</code> (<code>list(string)</code>)：忽略改变,某些场景下,某资源可以会被第三方控制而不停被修改,此时terraform每次都会把它改回来,如果需要避免这种情况,可以使用这个参数指定要忽略的<code>某些属性</code>的变更.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 忽视tags属性变更<br>resource &quot;aws_instance&quot; &quot;example&quot; &#123;<br>  # ...<br><br>  lifecycle &#123;<br>    ignore_changes = [<br>      # Ignore changes to tags, e.g. because a management agent<br>      # updates these based on some ruleset managed elsewhere.<br>      tags,<br>    ]<br>  &#125;<br>&#125;<br># 忽视map中特定元素的变更,必须确保map中含有这个元素<br>resource &quot;aws_instance&quot; &quot;example&quot; &#123;<br>  tags = &#123;<br>    Name = &quot;placeholder&quot;<br>  &#125;<br>  lifecycle &#123;<br>    ignore_changes = [<br>      tags[&quot;Name&quot;],<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了使用<code>list(string)</code>指定忽略的属性还可以使用<code>all</code>忽略所有属性的变更</p></li><li><p><code>replace_triggered_by</code>: 手动指定资源的哪些属性被修改时,强制触发<code>替换资源</code>这个操作.一般情况下用不到.</p></li></ul><h1 id="data"><a href="#data" class="headerlink" title="data"></a>data</h1><p><code>data</code>,数据源,用于查询或计算数据供其他地方使用.数据源是provider定义的,不同的平台有不同的数据源可供查询.因此数据源的具体定义可以通过查registry文档获取.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 定义<br>data &quot;aws_ami&quot; &quot;web&quot; &#123;<br>  filter &#123;<br>    name   = &quot;state&quot;<br>    values = [&quot;available&quot;]<br>  &#125;<br><br>  filter &#123;<br>    name   = &quot;tag:Component&quot;<br>    values = [&quot;web&quot;]<br>  &#125;<br><br>  most_recent = true<br>&#125;<br># 使用<br>resource &quot;aws_instance&quot; &quot;web&quot; &#123;<br>  ami           = data.aws_ami.web.id<br>  instance_type = &quot;t1.micro&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="dynamic块"><a href="#dynamic块" class="headerlink" title="dynamic块"></a>dynamic块</h1><p>比如在resource块中,如果某些资源包含了可重复的内嵌块,此时可以使用dynamic循环赋值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 语法如下<br>dynamic &quot;block_type&quot; &#123;<br>  for_each = expression<br>  content &#123;<br>    # Block content<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面举个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs terraform">variable &quot;subnets&quot; &#123;<br>  type = list(object(&#123;<br>    name     = string<br>    cidr     = string<br>    zone     = string<br>    resource = string<br>  &#125;))<br>&#125;<br><br>resource &quot;aws_subnet&quot; &quot;example_subnet&quot; &#123;<br>  dynamic &quot;subnet&quot; &#123;<br>    for_each = var.subnets<br>    content &#123;<br>      availability_zone = subnet.value.zone<br>      cidr_block        = subnet.value.cidr<br>      tags = &#123;<br>        Name = subnet.value.name<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面的例子中,首先定义了一个<code>subnets</code>的变量,由子网所需属性(name,cidr,zone,resource)的对象构成.(<code>list(object)</code>)</p><p>然后定义<code>subnet</code>这个dynamic块.<code>for_each</code>负责迭代对象<code>var.subnets</code></p><p><code>content</code>负责给属性赋值</p><p>值通过<code>subnet.value.zone</code>形式引用,注意引用值第一节字符串用的是<code>dynamic块的名字</code></p></blockquote><blockquote><p>过多的dynamic块会导致代码难以阅读和维护,建议只在需要构造可重用的模块代码时使用.</p></blockquote><h1 id="check"><a href="#check" class="headerlink" title="check"></a>check</h1><p><code>terraform &gt;= 1.5</code>,check 块中可以定义一个<code>有限作用范围的data块</code>以及<code>至少一个</code>断言.用于<code>验证基础设状态</code>.</p><p>check会在每次<code>plan</code>或<code>apply</code>后执行的自定义验证,作为plan或apply的最后一步执行.</p><blockquote><p><code>assert</code> 是一种在 <code>check</code> 块中使用的断言机制。<code>check</code> 块用于定义验证规则，而 <code>assert</code> 块用于在验证规则中定义断言逻辑。断言是一种用于检查条件是否为真的方法。在 <code>check</code> 块中，你可以使用 <code>assert</code> 块来添加额外的断言逻辑，以确保特定条件为真。如果断言条件为假，Terraform 将输出错误消息。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 定义一个名为health_check的check块<br>check &quot;health_check&quot; &#123;<br>  data &quot;http&quot; &quot;terraform_io&quot; &#123;<br>    url = &quot;https://www.terraform.io&quot;<br>  &#125;<br><br>  assert &#123;<br>    condition = data.http.terraform_io.status_code == 200<br>    error_message = &quot;$&#123;data.http.terraform_io.url&#125; returned an unhealthy status code&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>所有包含terraform代码文件的文件夹都是一个terraform模块.直接执行<code>terraform plan/apply</code>的文件夹称为<code>根模块</code></p><p>举个例子说明模块的结构:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">. # 根模块<br>├── README.md<br>├── main.tf<br>├── variables.tf<br>├── outputs.tf<br>├── ...<br>├── modules/ # modules文件夹用于存放子模块<br>│   ├── nestedA/ # 子模块1,名为nestedA<br>│   │   ├── README.md # 说明文档<br>│   │   ├── variables.tf # 模块使用的变量<br>│   │   ├── main.tf # 模块的主要入口<br>│   │   ├── outputs.tf # 模块的输出<br>│   ├── nestedB/ # 子模块2,名为nestedB<br>│   ├── .../<br>├── examples/ # 用来给出调用样例(可选),有example中代码经常会被复制到别的地方使用.所以里面的路径最好不要写相对路径<br>│   ├── exampleA/<br>│   │   ├── main.tf<br>│   ├── exampleB/<br>│   ├── .../<br></code></pre></td></tr></table></figure><blockquote><p>模块结构不宜过深,保持一层嵌入就可以了</p></blockquote><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>通过<code>module</code>块的<code>source</code>关键字来指定模块的源,支持的模块源有:</p><ul><li><p>本地</p><ul><li><p>本地路径必须以<code>./</code>或<code>../</code>为前缀来声明使用的是本地路径,除了本地源,其他源的模块引用都要先下载代码才能使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs terraform">module &quot;consul&quot; &#123;<br>  source = &quot;./consul&quot;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>terraform registry</p><ul><li><p>官方仓库: <a href="https://registry.terraform.io/">公共仓库</a>,也可以通过terraform cloud维护一个私有模块仓库,或者通过实现 <a href="https://www.terraform.io/docs/registry/api.html">Terraform 模块注册协议</a>来实现一个私有仓库.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs terraform">module &quot;consul&quot; &#123;<br>  # 公共仓库的的模块可以用 &lt;NAMESPACE&gt;/&lt;NAME&gt;/&lt;PROVIDER&gt; 形式的源地址来引用，在公共仓库上的模块介绍页面上都包含了确切的源地址<br>  source = &quot;hashicorp/consul/aws&quot;<br>  version = &quot;0.1.0&quot;<br>&#125;<br># 托管在其他仓库的模块，在源地址头部添加 &lt;HOSTNAME&gt;/ 部分，指定私有仓库的主机名<br>module &quot;consul&quot; &#123;<br>  source = &quot;app.terraform.io/example-corp/k8s-cluster/azurerm&quot;<br>  version = &quot;1.1.0&quot;<br>&#125; <br></code></pre></td></tr></table></figure></li></ul></li><li><p>github</p><ul><li><p>以<code>gitHub.com</code>为前缀指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># 默认使用HTTPS协议克隆仓库<br>module &quot;consul&quot; &#123;<br>  source = &quot;github.com/hashicorp/example&quot;<br>&#125;<br># 使用ssh协议  <br>module &quot;consul&quot; &#123;<br>  source = &quot;git@github.com:hashicorp/example.git&quot;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>bitbucket</p><ul><li><code>bitbucket.org</code> 为前缀</li></ul></li><li><p>git&#x2F;mercurial仓库</p><ul><li><p>git仓库: <code>git::</code> 为前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs terraform"># https, ref参数指定分支<br>module &quot;vpc&quot; &#123;<br>  source = &quot;git::https://example.com/vpc.git?ref=v1.2.0&quot;<br>&#125;<br># ssh<br>module &quot;storage&quot; &#123;<br>  source = &quot;git::ssh://username@example.com/storage.git&quot;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Mercurial 仓库: <code>hg::</code> 前缀</p></li></ul></li><li><p>HTTP地址</p></li><li><p>S3</p><ul><li><code>s3::</code></li></ul></li><li><p>GCS</p><ul><li><code>gcs::</code></li></ul></li><li><p>引用子文件夹中的模块,例如:</p><ul><li><code>hashicorp/consul/aws//modules/consul-cluster</code></li><li><code>git::https://example.com/network.git//modules/vpc</code></li><li><code>https://example.com/network-module.zip//modules/vpc</code></li><li><code>s3::https://s3-eu-west-1.amazonaws.com/examplecorp-terraform-modules/network.zip//modules/vpc</code></li></ul></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>引用后直接再module块内给模块的变量赋值就能使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terraform">module &quot;servers&quot; &#123;<br>  source = &quot;./app-cluster&quot;<br><br>  servers = 5<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用模块输出值"><a href="#引用模块输出值" class="headerlink" title="引用模块输出值"></a>引用模块输出值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terraform">resource &quot;aws_elb&quot; &quot;example&quot; &#123;<br>  # ...<br><br>  instances = module.servers.instance_ids<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模块内的provider"><a href="#模块内的provider" class="headerlink" title="模块内的provider"></a>模块内的provider</h2><p>一般来说,旨在复用的模块内是不能定义任何provider的.</p><h3 id="隐式继承"><a href="#隐式继承" class="headerlink" title="隐式继承"></a>隐式继承</h3><p>默认情况下子模块会自动从调用者那里继承默认的provider配置.</p><h3 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h3><p>如果不同的子模块需要不同的provider,或者子模块需要的provider与调用者自己使用的不同时,则需要显式声明.</p><p>比如一个模块配置了两个aws区域之间的网络打通,所以需要配置一个源区域provider和目标区域provider.根模块代码看起来应该是这样的:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs terraform">provider &quot;aws&quot; &#123;<br>  alias  = &quot;usw1&quot;<br>  region = &quot;us-west-1&quot;<br>&#125;<br><br>provider &quot;aws&quot; &#123;<br>  alias  = &quot;usw2&quot;<br>  region = &quot;us-west-2&quot;<br>&#125;<br><br>module &quot;tunnel&quot; &#123;<br>  source    = &quot;./tunnel&quot;<br>  providers = &#123;<br>    aws.src = aws.usw1<br>    aws.dst = aws.usw2<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而模块tunnel中必须包含下面的例子那样声明<code>provider别名</code>,声明模块调用者必须使用这些名字传递provider</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs terraform">provider &quot;aws&quot; &#123;<br>  alias = &quot;src&quot;<br>&#125;<br><br>provider &quot;aws&quot; &#123;<br>  alias = &quot;dst&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>alias</code>是provider代理配置的参数,它是一个模块间传递provider配置的占位符.</p><h1 id="实践例子"><a href="#实践例子" class="headerlink" title="实践例子"></a>实践例子</h1><h2 id="有条件创建"><a href="#有条件创建" class="headerlink" title="有条件创建"></a>有条件创建</h2><p>这是很常用的一个例子,使用count+表达式实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs terraform">variable &quot;allocate_public_ip&quot; &#123;<br>  description = &quot;Decide whether to allocate a public ip and bind it to the host&quot;<br>  type = bool<br>  default = false<br>&#125;<br><br>resource &quot;ucloud_eip&quot; &quot;public_ip&quot; &#123;<br>  count = var.allocate_public_ip ? 1 : 0<br>  name = &quot;public_ip_for_$&#123;ucloud_instance.web.name&#125;&quot;<br>  internet_type = &quot;bgp&quot;<br>&#125;<br><br>resource &quot;ucloud_eip_association&quot; &quot;public_ip_binding&quot; &#123;<br>  count = var.allocate_public_ip ? 1 : 0<br>  eip_id = ucloud_eip.public_ip[0].id<br>  resource_id = ucloud_instance.web.id<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="target参数"><a href="#target参数" class="headerlink" title="-target参数"></a>-target参数</h2><p>多人团队执行terraform时,建议<code>以module为单位</code>运行.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform plan/apply --target module.&lt;module-name&gt;<br></code></pre></td></tr></table></figure><h2 id="–plugin-dir"><a href="#–plugin-dir" class="headerlink" title="–plugin-dir"></a>–plugin-dir</h2><p>所处网络环境比较严格,只能手动下载provider等插件,需要手动指定插件目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">terraform init --plugin-dir=&lt;path-to-plugins&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>terraform</tag>
      
      <tag>HCL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>terraform-必知必会</title>
    <link href="/2024/01/31/terraform-must-know/"/>
    <url>/2024/01/31/terraform-must-know/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/1*9-ILOQ1Yxautyc_uIguhVw.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>本文记录一些关于terraform的理解,只记录我认为有必要记录的东西,以及一些我自身的理解,<code>经验</code>部分来自我自身面试经历,本文绝大部分来自教程: <a href="https://lonegunmanb.github.io/introduction-terraform/">https://lonegunmanb.github.io/introduction-terraform/</a></p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>HashiCorp这家公司,极其重视”基础设施”建设,他们思考terraform的配置文件应该使用json或yaml时,都不满意,于是设计了<code>HCL</code>(<a href="https://github.com/hashicorp/hcl">HashiCorp Configuration Language</a>).他们又花时间开发了 <a href="https://github.com/hashicorp/go-plugin">go-plugin</a> 这个项目，把插件编译成一个独立进程，与主进程通过 rpc 进行互操作。</p></blockquote><p>Terraform是一种<code>基础设施即代码(infrastructure as code)</code>的实现.允许开发人员使用<code>声明式语言</code>定义和管理基础设施资源.</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol><li>声明式语言: Terraform使用声明式语言语言来<code>定义/描述</code>你想要的额基础设施的最终状态,而不需要关心怎么达到该状态.</li><li>资源提供者(provider): Terraform通过provider与各种基础设施平台(AWS, GCP, K8S)交互,不同的provider负责不同平台的API通信已经资源的管理.provider也就是terraform的插件,与terraform主进程通过rpc交互.</li><li>状态管理: Terraform使用状态文件<code>statefile</code>来记录当前基础设施的状态.这个文件记录所有已创建的资源及其配置信息,以便在后续的执行中进行比较和更新.</li><li>执行计划: <code>terraform plan</code> 它会分析当前状态文件和代码,对比并生成一个执行计划,计划显示将要创建&#x2F;更新&#x2F;删除的资源以及顺序.</li><li>应用计划: <code>terraform apply</code> 应用上面的计划,实际改变平台资源.</li><li>可重现性: 无论何时运行terraform,它都会尽力使基础设施达到你所定义的状态,如果已经符合,则不会做出任何改变.</li></ol><h1 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h1><p>即terraform的go-plugin插件,不同平台对应不同的provider,terraform负责分析代码然后通过provider调用平台的api或者SDK实现资源的管理.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs terraform">terraform &#123;<br>  required_providers &#123;<br>    ucloud    = &#123;<br>      source  = &quot;ucloud/ucloud&quot;<br>      version = &quot;&gt;=1.24.1&quot;<br>    &#125;<br>  &#125;<br>&#125;<br><br>provider &quot;ucloud&quot; &#123;<br>  public_key  = &quot;your_public_key&quot;<br>  private_key = &quot;your_private_key&quot;<br>  project_id  = &quot;your_project_id&quot;<br>  region      = &quot;cn-bj2&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>provider的配置是全局的,只能配在<code>根模块</code>下.</p><p><code>terraform init</code>重要一步就是下载provider到本地</p><h1 id="状态文件"><a href="#状态文件" class="headerlink" title="状态文件"></a>状态文件</h1><p>terrafrom的状态文件主要包含三个状态信息:</p><ol><li>资源当前状态</li><li>配置中定义的期望状态</li><li>上面二者之间的映射</li></ol><h1 id="状态锁"><a href="#状态锁" class="headerlink" title="状态锁"></a>状态锁</h1><p><code>State Lock</code>是一种机制,用于在并行执行Terraform命令时出现资源抢占的问题.状态锁确保同一时间只有一个terraform可以修改状态文件.</p><p>当运行一个terraform命令时, 它会生成一个锁文件并获取它,知道执行完成才会释放该文件.执行过程中其他terraform命令因为获取不到这个锁文件所以无法执行.</p><h1 id="Backend"><a href="#Backend" class="headerlink" title="Backend"></a>Backend</h1><p>Backend用于<code>存储和管理状态文件</code>,包括读写锁定等操作.它可以是本地文件系统,也可以远程存储(GCS, S3等).</p><p>同时terraform支持<code>http形式</code>的backend,意味着我们可以简单写个http服务在实现backend,然后terraform就可以通过http请求管理.</p><p>另外terraform也支持主流 db来存储状态文件,意味着PostgreSQL db&#x2F;MariaDB&#x2F;SQL server 等数据库也能作为一个backend.</p><blockquote><p>下面用python写个httpserver来实现简单的backend</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><br>app = Flask(__name__)<br>state = &#123;&#125;<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/terraform/state&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_state</span>():<br>    <span class="hljs-keyword">return</span> jsonify(state)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/terraform/state&#x27;</span>, methods=[<span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">update_state</span>():<br>    new_state = request.json<br>    state.update(new_state)<br>    <span class="hljs-keyword">return</span> jsonify(&#123;<span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;State updated successfully&#x27;</span>&#125;)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terraform">terraform &#123;<br>  backend &quot;http&quot; &#123;<br>    address = &quot;http://your-backend-address:port/terraform/state&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面只是实现了GET&#x2F;POST,也就是获取和更新状态文件的功能,实际生产中还要实现文件的持久化、并发访问控制、状态锁定等功能.</p></blockquote><h1 id="terraform常见文件"><a href="#terraform常见文件" class="headerlink" title="terraform常见文件"></a>terraform常见文件</h1><ul><li>main.tf: 类似函数中的<code>main()</code></li><li>ouput.tf: 定义terraform的输出信息,在terraform执行完成后输出</li><li>data.tf: 定义数据源,用于查询平台上资源的信息.</li><li>variables.tf: 定义terraform的变量</li><li>terraform.tfvars: 定义terraform的变量默认值,它可以包含变量的默认值或敏感信息</li><li>provider.tf: 定义具体的provider,以及它的版本.</li><li>terraform.tfstate: 状态文件,一般存在远端backend</li><li>versions.tf: 定义terraform的版本要求</li></ul><h1 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h1><p>terrafrom使用的HCL声明式语言,以块的形式组织代码,通过大括号来划分块,常用的块有:</p><ul><li>local{}: 定义本地变量</li><li>resource{}: 定义资源</li><li>data{}: 用于数据查询或计算</li><li>module{}: 定义&#x2F;引用模块<ul><li>source定义模块位置</li></ul></li><li>ouput{}: 输出数据</li></ul><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><ul><li><p>TF_LOG: 定义terraform内部日志输出级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SHELL">export TF_LOG=[TRACE|DEBUG|INFO|WARN|ERROR]<br></code></pre></td></tr></table></figure></li><li><p>TF_LOG_PATH: 顾名思义,定义日志输出文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export TF_LOG_PATH=./terraform.log<br></code></pre></td></tr></table></figure></li><li><p>TF_INPUT: 定义是否交互式执行terraform命令, 0或者false代表不交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export TG_INPUT=0<br></code></pre></td></tr></table></figure></li><li><p>TF_VAR_name: 此变量用于给<code>name</code>变量赋值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">export TF_VAR_region=us-west-1<br>export TF_VAR_ami=ami-049d8641<br>export TF_VAR_alist=&#x27;[1,2,3]&#x27;<br>export TF_VAR_amap=&#x27;&#123; foo = &quot;bar&quot;, baz = &quot;qux&quot; &#125;&#x27;<br></code></pre></td></tr></table></figure></li><li><p>TF_CLI_ARGS: 定义使用命令行时,默认附加给CLI的参数,比如<code>TF_CLI_ARGS=&quot;-input=false&quot; terraform apply -force</code>相当于执行<code>terraform apply -input=false -force</code>,用于自动化CI环境下定制terraform的默认参数.</p></li><li><p>TF_CLI_ARGS_name: 则可以指定特定的子命令下定制默认参数.比如<code>TF_CLI_ARGS_plan=&quot;-refresh=false&quot;</code>就只针对plan命令起作用.</p></li><li><p>TF_DATE_DIR: 定义工作目录下terraform数据的保存位置,默认是<code>.terraform</code>.一般情况下不应该改动它</p></li><li><p>TF_IN_AUTOMATION: 如果该值定义为<code>非空值</code>,terraform会认为自己运行在一个自动化环境下,从而减少一些非必要的输出信息,比如给出该执行什么子命令的建议.</p></li><li><p>TF_REGISTRY_DISCOVERY_RETRY和TF_REGISTRY_DISCOVERY_TIMEOUT: 定义连接registry下载provider或plugin的重试次数和超时时间(默认10s)</p></li><li><p>TF_CLI_CONFIG_FILE: 定义terraform命令行配置文件的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export TF_CLI_CONFIG_FILE=&quot;$HOME/.terraformrc-custom&quot;<br></code></pre></td></tr></table></figure></li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><p>init: 初始化terraform工作目录,包括下载provider,反复执行是安全的</p></li><li><p>plan: 创建变更计划, <code>-out</code>将输出保存在一个文件中</p></li><li><p>apply: 执行计划</p></li><li><p>destroy: 销毁资源</p></li><li><p>import: 将资源导入到状态文件,一般用于将非terraform管理的资源纳入terraform管理中,也可以将资源的状态文件导出到本地</p></li><li><p>validate: 检查目录下的terraform代码语法,只是检查语法不会访问远端资源</p></li><li><p>state: 对状态文件进行管理操作,一般情况下不建议手动更改state文件,此时可以使用state命令来对资源进行细粒度处理, 它有很多子命令, 例如:</p><ul><li><code>terraform state list</code>: 列出当前配置中所有资源及其状态, 它会显示当前状态文件中存在的所有资源的地址.</li><li><code>terraform state show</code>: 显示指定资源的详细信息, 包括其属性和当前状态.</li><li><code>terraform state rm</code>: 从状态文件中删除指定资源,但不删除实际资源只是剔除出terraform的管理</li><li><code>terraform state pull</code>: 从远端backend拉取最新的状态文件到本地</li><li><code>terraform state push</code>: 将本地状态文件推到远端backend</li><li><code>terraform state mv</code>: 代码移动或重命名后资源文件中也要做对应的操作</li><li><code>terraform state refresh</code>：刷新状态文件以获取最新的资源状态。它用于将当前的资源状态与实际的基础设施进行<code>同步</code></li><li><code>terraform state lock/unlock</code>: 手动锁定&#x2F;解锁状态文件</li></ul></li><li><p>output: 用来提取输出</p></li><li><p>fmt: 格式化terraform代码文件的格式和规范</p></li><li><p>graph: 用来生成代码描述的技术设施或执行计划的可视化视图,输出<code>DOT</code>格式,可以通过GraphViz转换成图形文件</p><ul><li><pre><code class="shell">terraform graph | dot -Tsvg &gt; graph.svg<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs pf"><br><span class="hljs-comment"># 经验</span><br><br><span class="hljs-comment">## 状态文件迁移</span><br><br>假设在本地init并apply,会在本地产生statefile,此时添加新的backend配置再次init.<br><br>此时terraform会检测到backend改变了,它会先检查新backend有没有状态文件,没有的话就会直接迁移,需要用户手动确认.<br><br>如果新backend已经有状态文件了,terraform会把`新旧`状态文件下载到本地的一个临时目录,然后要求用户人工核对后决定是否覆盖既有的statefile.<br><br><span class="hljs-comment">## backend配置错误</span><br><br>第一次init时会报错连不上backend,修改好后再次init还是会报错.<br><br>这是因为terraform在第一次init连不上backend时会在本地写statefile,第二次连接发现backend配置变了,它会尝试从原来的backend读取statefile,并且尝试将其迁移到新的backend,但是因为原来的backend本身就是错的,所以它还是会报错.<br><br>`解决办法`是要把本地的statefile删掉或者移走.<br><br>&gt; 上面两个问题的原理其实都是一样的,那就是terraform在使用新backend的时候,都会做一个动作: `先检查旧的再判断新的`<br><br><span class="hljs-comment">## 代码结构改变</span><br><br>当terraform配置的路径和结构与statefile不一致时,会丢失资源的跟踪.比如你把module.a移动到了module.b,apply时terraform会更根据现有的statefile去寻找资源,这些资源仍然关联着旧的路径(module.a),此时terraform会认为无法找到module.b这个资源,而尝试重新创建它. 因此路径变更如果未及时反映到状态文件中,会导致terraform状态与实际云环境的状态不一致,plan和apply可能会提出错误的改动计划,可能会导致资源无意中的破坏或重复创建.另外状态文件不更新也会导致依赖关系混论.<br><br>```shell<br><span class="hljs-comment"># 更新状态文件的方法主要靠terraform state子命令</span><br><span class="hljs-comment"># address: module.&lt;模块名&gt;.&lt;资源类型&gt;.&lt;资源名称&gt;</span><br><span class="hljs-comment"># module路径改动</span><br>terraform <span class="hljs-keyword">state</span> mv module.old_module.resource_name module.new_module.resource_name<br><span class="hljs-comment"># 在terraform管理中移除资源但不实际销毁它</span><br>terraform <span class="hljs-keyword">state</span> rm <span class="hljs-variable">&lt;address&gt;</span> <br><span class="hljs-comment"># 列出当前terraform状态文件中所有资源</span><br>terraform <span class="hljs-keyword">state</span> list<br>terraform <span class="hljs-keyword">state</span> show <span class="hljs-variable">&lt;address&gt;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Devops</category>
      
    </categories>
    
    
    <tags>
      
      <tag>terraform</tag>
      
      <tag>HCL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AIGC-AI绘画</title>
    <link href="/2024/01/30/aigc-AIpainting/"/>
    <url>/2024/01/30/aigc-AIpainting/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/how-does-stable-diffusion-work.webp" srcset="/img/loading.gif" lazyload></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>AI绘画是通过模拟图像增加噪点对图像进行分析学习处理后再进行重新组合降噪还原的扩散过程,称为<code>图像扩散</code></p><p>原论文名: High-Resolution lmage Synthesis with Latent Diffusion Models</p><p>所以按我理解,AI绘画并不是本质上的从0到1的创造,而是模仿重组.不过模仿重组本身就不是创造了吗?</p></blockquote><h1 id="SD安装"><a href="#SD安装" class="headerlink" title="SD安装"></a>SD安装</h1><ol><li><p>环境</p><ul><li>python</li><li>CUDA驱动</li><li>GIT</li></ul></li><li><p>原生webui</p><ul><li><p>python&lt;&#x3D;3.10.6</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https:/github.com/AUTOMATIC1111/stable-diffusion-webui.git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">黑色主题</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://127.0.0.1:7860/?__theme=dark</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>原生webui分支</p><ul><li><p>在上面的基础上做了些优化,本质功能没有差别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/vladmandic/automatic<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动后不会自动弹出webui要手动访问</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://127.0.0.1:7860/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>大神整合包</p><ul><li>B站: 秋葉aaaki</li><li>B站: 独立研究员-星空ki (支持A卡, A卡选CPU或者自动运行)</li><li>B站: ToniiiX (支持全系列A卡,N卡,M1芯片; 支持mac, windows, linux; 没有自带模型)</li></ul></li></ol><h1 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h1><p>插件目录: <code>path_to_sd\extensions</code></p><ol><li><p>直接在插件目录下<code>git clone &#123;插件地址&#125;</code></p></li><li><p>通过webui安装</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130112645151.png" srcset="/img/loading.gif" lazyload alt="image-20240130112645151"></p></li></ol><p>原生webui内置插件:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130113113466.png" srcset="/img/loading.gif" lazyload alt="image-20240130113113466"></p><p>常用插件推荐:</p><ul><li><a href="https://github.com/dtlnor/stable-diffusion-webui-localization-zh_CN">简体中文语言包</a></li><li><a href="https://github.com/Physton/sd-webui-prompt-all-in-one">提示词管理</a></li><li><a href="https://github.com/DominikDoom/a1111-sd-webui-tagcomplete">Tag自动补全</a></li></ul><h1 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h1><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130152941815.png" srcset="/img/loading.gif" lazyload alt="image-20240130152941815"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130152932659.png" srcset="/img/loading.gif" lazyload alt="image-20240130152932659"></p><h2 id="大模型"><a href="#大模型" class="headerlink" title="大模型"></a>大模型</h2><p>模型路径: <code>path_to_sd\models\Stable-diffusion</code></p><p>作用: 决定画风</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130115404345.png" srcset="/img/loading.gif" lazyload alt="image-20240130115404345"></p><blockquote><p>SD模型又叫<code>ckpt(check point)</code>,大模型,主模型或底模型,后缀为<code>.ckpt</code>或<code>.safetensors</code></p></blockquote><p>模型下载网站:</p><ul><li><p><a href="https://huggingface.co/">抱脸虫</a>: 基本上AI相关的模型它都有</p></li><li><p><a href="https://civitai.com/">C站</a>(需要魔法)</p></li><li><p><del><a href="">炼丹阁</a></del>(已死)</p></li><li><p><a href="https://www.liblib.art/">哩布哩布</a>(国产,有会员制,部分模型要钱)</p></li><li><p><a href="https://rentry.co/sdmodels">rentry.co</a></p></li><li><p><a href="https://cyberes.github.io/stable-diffusion-models/">cyberes</a></p></li></ul><h2 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h2><p><code>变分自编码器</code>,基于深度学习的生成模型</p><p>调出配置项: <code>设置--&gt;用户界面--&gt;快捷设置列表--&gt;sd_vae--&gt;保存设置--&gt;重启webui</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130121027626.png" srcset="/img/loading.gif" lazyload alt="image-20240130121027626"></p><p>vae也有单独的模型, 存放目录: <code>path_to_sd\models\VAE</code>,不过目前很多大模型训练时已经自带VAE</p><p>作用: <code>滤镜与微调</code>,如下左图没有使用VAE</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130120604669.png" srcset="/img/loading.gif" lazyload></p><h2 id="CLIP-skip"><a href="#CLIP-skip" class="headerlink" title="CLIP skip"></a>CLIP skip</h2><p>一种<code>语言理解模型</code>,一共有12个值(0-12),表示理解提示词的<code>模糊程度</code>,层越低,越贴切提示词(越严谨).</p><blockquote><p>一般调到2-4,如果希望sd更自主,可以相应调高</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130152014888.png" srcset="/img/loading.gif" lazyload alt="image-20240130152014888"></p><p>调出配置项: <code>设置--&gt;用户界面--&gt;快捷设置列表--&gt;CLIP_stop_at_last_layers--&gt;保存设置--&gt;重启webui</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130151606339.png" srcset="/img/loading.gif" lazyload alt="image-20240130151606339"></p><h2 id="采样方法-sampler"><a href="#采样方法-sampler" class="headerlink" title="采样方法 sampler"></a>采样方法 sampler</h2><p>不同的<code>采样器</code>影响图片的扩散过程以及色彩.一般模型训练者会提示采用哪种采样器会比较好.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130152411129.png" srcset="/img/loading.gif" lazyload alt="image-20240130152411129"></p><p>常用的采样器:</p><ul><li>Euler a</li><li>Eular</li><li>DPM2</li><li>DDIM</li><li>DPM++ 2M Karras</li></ul><h2 id="迭代步数-steps"><a href="#迭代步数-steps" class="headerlink" title="迭代步数 steps"></a>迭代步数 steps</h2><p>就是图像扩散的步数,可以理解为ai绘画的笔数.迭代步数一般要根据使用的采样器决定.并不是步数越高就越精细.</p><p>一般情况下可以设置到<code>20-50</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130152607126.png" srcset="/img/loading.gif" lazyload alt="image-20240130152607126"></p><h2 id="提示词相关性-CFG-Scale"><a href="#提示词相关性-CFG-Scale" class="headerlink" title="提示词相关性 CFG Scale"></a>提示词相关性 CFG Scale</h2><p>影响提示词的<code>权重</code>: 不同于提示词语法权重,而是<code>整个图片扩散过程提示词与其他参数占比的总权重</code></p><p>安全值: 7-15</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130153036894.png" srcset="/img/loading.gif" lazyload alt="image-20240130153036894"></p><h2 id="面部修复"><a href="#面部修复" class="headerlink" title="面部修复"></a>面部修复</h2><blockquote><p>新版本sd webui默认打开</p></blockquote><p>可以在设置中关闭</p><p>因为人物像中最复杂的就是<code>脸</code>和<code>手</code>,如果分辨率不高,像素太小,AI画出的人物脸部和手部就很容易崩坏.如果调高分辨率也有修复的效果.</p><p>但是绝大多数模型在训练的时候都是采用512*512去训练,如果用高分辨率来生成,空的部分AI会随意填充,比如你想画1 girl,它就给你2 girl.</p><p>这时候只能生成512*512的图,但是又要高分辨率,此时就可以用到<code>高清修复</code>.</p><h2 id="高清修复-Hires-fix"><a href="#高清修复-Hires-fix" class="headerlink" title="高清修复 Hires. fix"></a>高清修复 Hires. fix</h2><p>高清修复有各种对图片放大重绘的算法,实际上是<code>图片重绘</code>生成更大更多细节的图片.</p><h2 id="平铺"><a href="#平铺" class="headerlink" title="平铺"></a>平铺</h2><p>生成的图可以无缝拼合使用(材质图)</p><h2 id="随机种子-seed"><a href="#随机种子-seed" class="headerlink" title="随机种子 seed"></a>随机种子 seed</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130154534705.png" srcset="/img/loading.gif" lazyload alt="image-20240130154534705"></p><p>种子就是噪声,<code>每一个种子表示不同的噪声图</code>.</p><p>种子数&#x3D;1;迭代&#x3D;1就是<code>原始噪声图</code>.</p><p>最大种子数:  18446744073709550591 (超过就会生成失败)</p><p>使用上一次的随机种子数: 使用上一次的随机种子,<code>后面生成的图都会参考上一次的图来画</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130154408764.png" srcset="/img/loading.gif" lazyload alt="image-20240130154408764"></p><p><code>-1</code>: 不使用特定的随机种子,出图完全随机.</p><h3 id="高级功能-对噪声图重新组合"><a href="#高级功能-对噪声图重新组合" class="headerlink" title="高级功能: 对噪声图重新组合"></a>高级功能: 对噪声图重新组合</h3><ul><li><p>差异随机种子 和 差异强度:  <code>差异种子</code>与<code>随机种子</code>差值越大,构图影响越大,同时变化幅度由<code>差异强度</code>决定</p><p>固定参数:</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130160833686.png" srcset="/img/loading.gif" lazyload alt="image-20240130160833686"></p><p>​只调节差异种子和差异强度输出如下:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130160552517.png" srcset="/img/loading.gif" lazyload alt="image-20240130160552517"></p><p>随机种子&#x3D;差异种子时: 不论差异强度多高,图片都不会变化</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130161427262.png" srcset="/img/loading.gif" lazyload alt="image-20240130161427262"></p><ul><li>宽度和高度: 比如设置300*300,差异种子控制的就是差异种子内的噪声,也就是300*300里面的部分</li></ul><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130160329540.png" srcset="/img/loading.gif" lazyload alt="image-20240130160329540"></p><p>总结: 当我们得到一张基本符合要求的图,但是对细节有其他想法,就可以调差异种子.通过差异种子,可以对噪声图进行局部重绘,从而会图差生细微影响.在不影响整体构图下,细改图片.(其实类似局部重绘)</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130161827600.png" srcset="/img/loading.gif" lazyload alt="image-20240130161827600"></p><h1 id="文生图"><a href="#文生图" class="headerlink" title="文生图"></a>文生图</h1><p>text2img原理:</p><p>提示词+参数&#x3D;&#x3D;&gt;代码&#x3D;&#x3D;&gt;采样器sampler&#x3D;&#x3D;&gt;采样方法sampling method&#x3D;&#x3D;&gt;对底模ckpt进行采样&#x3D;&#x3D;&gt;图像</p><h2 id="正向提示词"><a href="#正向提示词" class="headerlink" title="正向提示词"></a>正向提示词</h2><p>可以识别: </p><ul><li>英文:<ul><li>单词: 一个女孩,高挑,站立,地面 (由于sd对于单词理解能力更强,所以<code>优先使用</code>)</li><li>短句: 一个站立在地面上的高挑女孩</li></ul></li><li>数字</li><li>符号</li><li>emoji表情</li></ul><p>语序: 画面质量–&gt;主要元素–&gt;细节</p><ol><li>画面质量&#x2F;概念:<ul><li>图像质量: 高细节, 高分辨率, 超写实主义, HD, 8k, 16K等</li><li>风格: 卡通, 贴纸, 漫画, 印象, 肖像, 像素, 新海城, 赛博朋克等</li><li>构图: 中心, 水平, 随直, 三分法, 对称法, 对角线, 框架, 重复构图等</li><li>灯关: 工作室, 电影照明, 美丽的灯光, 柔光, 逆光, 人物发光, 测光, 云隙光等</li></ul></li><li>主要元素&#x2F;主体:<ul><li>人物: 武士, 护士, 魔法师, 美少女战士, 男人, 女人, 女孩, 男孩, 兔女郎, 特定人物等</li><li>动物: 猴子, 鸡, 狗, 兔, 十二生肖, 怪兽, 鱼, 老鼠, 鸟, 鸭, 鹅等</li><li>事物: 瓶子, 伞, 武器, 背包, 墨镜, 手机, 电脑, 工具等</li><li>风景: 天空, 森林, 海洋, 山, 水, 花, 道路桥梁等</li><li>姿态: 站立, 坐, 行走, 奔跑, 跳跃, 半蹲, 抬头, 回身, 侧卧, 手放身后, 二郎腿等</li><li>服装: 短袖, 长衫, 连衣裙, 长袍, 短裤, 丝袜, 手套, 吊带, 牛仔裤, 围巾, 高跟鞋等</li><li>道具: 帽子, 眼镜, 武器, 手链, 项链, 耳坠, 耳环等</li></ul></li><li>细节:<ul><li>场景: 室内, 室外, 客厅, 餐厅, 咖啡店, 酒吧, 幻想场景等</li><li>环境: 晴天, 雨天, 阴天, 春夏秋冬, 白天, 傍晚, 夜晚等</li><li>细小元素: 表情, 妆容, 发髻, 雷, 电, 水, 火等不影响整体构图的元素</li><li>其他</li></ul></li></ol><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>分隔符: <code>权重排序</code>, 分隔符<code>前</code>权重<code>高</code>, 分隔符<code>后</code>权重<code>低</code>.一般情况下都使用<code>,</code>和<code>换行</code>.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130164715309.png" srcset="/img/loading.gif" lazyload alt="image-20240130164715309"></p><h3 id="权重符号"><a href="#权重符号" class="headerlink" title="权重符号"></a>权重符号</h3><p><code>(提示词)</code>: 括号内提示词权重* <code>1.1 </code></p><p><code>&#123;提示词&#125;</code>: 括号内提示词权重* <code>1.05 </code></p><p><code>[提示词]</code>: 括号内提示词权重* <code>0.9 </code></p><p><code>(提示词:1.2)</code>: 自定义权重</p><p>可以叠加使用:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130165101987.png" srcset="/img/loading.gif" lazyload alt="image-20240130165101987"></p><p>实际使用:</p><p>当我们希望某个元素在图片中出现更多,就可以<code>调高权重</code>,但是权重超过<code>1.5</code>图片同意崩,所以一般不要超过1.5</p><h3 id="连接符号"><a href="#连接符号" class="headerlink" title="连接符号"></a>连接符号</h3><p><code>+</code>和<code>_</code>: 并列前后提示词的权重</p><p><code>提示词1|提示词2</code>: <code>循环</code>竖线前后提示词的影响扩散效果(迭代步数1,3,5…<code>提示词1</code>生效; 迭代步数2,4,6…<code>提示词2</code>生效)</p><p><code>AND</code>: 前后需要加上空格, 对前后提示词产生融合效果</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130165639713.png" srcset="/img/loading.gif" lazyload alt="image-20240130165639713"></p><h3 id="分布扩散符号"><a href="#分布扩散符号" class="headerlink" title="分布扩散符号"></a>分布扩散符号</h3><p><code>[提示词:步数]</code>: 指定步数开始生效</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130165804776.png" srcset="/img/loading.gif" lazyload alt="image-20240130165804776"></p><p><code>[提示词::步数]</code>:指定步数停止生效</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130165854461.png" srcset="/img/loading.gif" lazyload alt="image-20240130165854461"></p><p><code>[提示词1:提示词2:步数]</code>:可以同时控制两个提示词, 指定步数<code>前</code>提示词<code>1</code>生效, 指定步数<code>后</code>提示词<code>2</code>生效</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130170152432.png" srcset="/img/loading.gif" lazyload alt="image-20240130170152432"></p><p><code>[提示词1|提示词2]</code>: 循环影响</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130170014173.png" srcset="/img/loading.gif" lazyload alt="image-20240130170014173"></p><p>示例:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130170353337.png" srcset="/img/loading.gif" lazyload alt="image-20240130170353337"></p><h2 id="反向提示词"><a href="#反向提示词" class="headerlink" title="反向提示词"></a>反向提示词</h2><p>通用模板保存即可(正向亦可保存).</p><p>模板保存目录: <code>path_to_sd\styles.csv</code>,用<code>记事本</code>打开,删除要删除的内容保存即可,不能用excel打开,否则会报错</p><h1 id="图生图"><a href="#图生图" class="headerlink" title="图生图"></a>图生图</h1><p>img2img: 通过提供的图像产生一个新图像</p><p>原理:</p><p>SD将输入的源图(step1)隐藏再随机种子的噪点图后(step2),基于这个<code>原始噪声图</code>再扩散.所以源图的颜色构图等总会在后面的迭代中出现.</p><blockquote><p>所以SD不是理解了源图,而是通过源图也随机种子组合<code>原始噪声图</code>再加上提示词和参数结合底模,找到最匹配的元素扩散出结果</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130174924201.png" srcset="/img/loading.gif" lazyload alt="image-20240130174924201"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130175058678.png" srcset="/img/loading.gif" lazyload alt="image-20240130175058678"></p><h2 id="重绘幅度"><a href="#重绘幅度" class="headerlink" title="重绘幅度"></a>重绘幅度</h2><p>表示添加到输出图像的噪声量,幅度值越大,图像变化越多</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130180047734.png" srcset="/img/loading.gif" lazyload alt="image-20240130180047734"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130180140468.png" srcset="/img/loading.gif" lazyload alt="image-20240130180140468"></p><h2 id="局部重绘"><a href="#局部重绘" class="headerlink" title="局部重绘"></a>局部重绘</h2><p>通过手涂蒙版工具对源图.结合提示词和参数,进行局部的图生图处理.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130180657074.png" srcset="/img/loading.gif" lazyload alt="image-20240130180657074"></p><p>模板边缘模糊度: 重绘边缘羽化功能,使局部生成部分看上去与源图更贴合.但是SD本身不会理解局部重绘部分与原图的关系,要想真正切合,需要使用插件.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130181011969.png" srcset="/img/loading.gif" lazyload alt="image-20240130181011969"></p><h2 id="涂鸦"><a href="#涂鸦" class="headerlink" title="涂鸦"></a>涂鸦</h2><p>对原图上色重绘,同样可以根据提示词引导噪声图.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130181059469.png" srcset="/img/loading.gif" lazyload alt="image-20240130181059469"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130181119420.png" srcset="/img/loading.gif" lazyload alt="image-20240130181119420"></p><h2 id="涂鸦重绘"><a href="#涂鸦重绘" class="headerlink" title="涂鸦重绘"></a>涂鸦重绘</h2><p>涂鸦+重绘, 在不改变原图的基础下,对原图进行涂鸦输入,也可以通过调整<code>蒙版透明度</code>改颜色.</p><h2 id="上传蒙版"><a href="#上传蒙版" class="headerlink" title="上传蒙版"></a>上传蒙版</h2><p>通过其他工具生成更加匹配的蒙版,更加精确地控制重绘的区域.(白色才是蒙版区域)</p><h2 id="批量重绘"><a href="#批量重绘" class="headerlink" title="批量重绘"></a>批量重绘</h2><p>通过预设,批量使用重绘功能.电商必备</p><p>需要提前准备好:</p><ul><li>原图目录</li><li>蒙版目录</li><li>输出目录</li><li>controlNet插件图像目录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130181709026.png" srcset="/img/loading.gif" lazyload alt="image-20240130181709026"></p><h2 id="缩放模式"><a href="#缩放模式" class="headerlink" title="缩放模式"></a>缩放模式</h2><blockquote><p>文生图第一步是预处理噪声图</p><p>图生图第一步是预处理原图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130191518665.png" srcset="/img/loading.gif" lazyload alt="image-20240130191518665"></p><p>潜空间: 预处理时噪声图(图生图中原图在随机噪声后融合后产生的<code>原始噪声图</code>)背后的空间.</p><p>仅调整大小(潜空间放大): 进入潜空间前先调整大小再<code>预处理</code>,进入潜空间后再静态放大.所以潜空间放大的原图会出现模糊.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130192059583.png" srcset="/img/loading.gif" lazyload alt="image-20240130192059583"></p><h2 id="重绘参考内容"><a href="#重绘参考内容" class="headerlink" title="重绘参考内容"></a>重绘参考内容</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130192426424.png" srcset="/img/loading.gif" lazyload alt="image-20240130192426424"></p><p>填充: 对重绘区域的原图进行高度模糊处理,只保留原图色度,再隐藏到随机噪声图后面.<code>原图颜色+随机噪声图(保留原图颜色,不保留原图结构)</code></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130192547944.png" srcset="/img/loading.gif" lazyload alt="image-20240130192547944"></p><p>原图: 不改变原图的预处理方式,之间将原图隐藏在随机噪声图后.<code>原图颜色结构+随机噪声图</code></p><p>潜空间噪声: 在重回区域填充潜空间内容(也是一张噪声图),然后再预处理叠加随机噪声图,也就是<code>双层噪声图</code></p><p>空白潜空间: 不使用潜空间的内容,直接在重绘区域填充噪声图.<code>单层噪声图</code></p><h2 id="重绘区域"><a href="#重绘区域" class="headerlink" title="重绘区域"></a>重绘区域</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130193117521.png" srcset="/img/loading.gif" lazyload alt="image-20240130193117521"></p><p>整张重绘&#x2F;以原图尺寸重绘: 对整张图片使用预处理方式,扩散局部内容</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130193401632.png" srcset="/img/loading.gif" lazyload alt="image-20240130193401632"></p><p>仅模板区域: 只对重绘区域进行预处理</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240130193341293.png" srcset="/img/loading.gif" lazyload alt="image-20240130193341293"></p><p>以蒙版尺寸重绘时的外部填充半径(像素):</p><p>控制填入噪点的像素大小,值越低,重绘部分像素越多.</p>]]></content>
    
    
    <categories>
      
      <category>AIGC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>Stable Diffusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-面向对象编程</title>
    <link href="/2024/01/16/python-oop/"/>
    <url>/2024/01/16/python-oop/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote><p>面向对象这一个概念来源于自然界</p></blockquote><table><thead><tr><th>自然界</th><th>编程</th></tr></thead><tbody><tr><td>person</td><td>person 类</td></tr><tr><td>身高&#x2F;年龄&#x2F;体重</td><td>类的属性</td></tr><tr><td>某一个人(Peter)</td><td>类的实例</td></tr><tr><td>人可以做什么</td><td>类的方法</td></tr></tbody></table><blockquote><p>面向对象的程序设计把计算机程序视为一组<code>对象</code>的集合,每个对象都可以接受其他对象发过来的<code>消息</code>,并处理这些<code>消息</code>.</p><p>计算机程序的执行就是<code>一系列消息在各个对象之间传递</code>.</p><p>在python中,所有数据类型都是对象.</p><p><code>自定义对象数据类型</code>就是面向对象中的<code>类(Class)</code>.</p></blockquote><h1 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h1><p>比如要展示一个学生的成绩:</p><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 学生的成绩数据可以用dict表示</span><br>std1 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Michael&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">98</span> &#125;<br>std2 = &#123; <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">81</span> &#125;<br><span class="hljs-comment"># 处理学生成绩则通过函数实现</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">std</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;std[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>: <span class="hljs-subst">&#123;std[<span class="hljs-string">&quot;score&quot;</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h2><p>我们首先思考的不是程序执行的流程,而是<code>Student</code>这种数据类型应该被视作一个<code>对象</code>,这个对象拥有<code>name</code>和<code>score</code>这两个<code>属性(Property)</code>.</p><p>如果要打印一个学生的成绩,我们首先要创建出这个学生对应的对象,然后给对象发一个<code>print_score</code>的消息,让<code>对象自己</code>把成绩打印出来.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span>: <span class="hljs-subst">&#123;self.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面说的给对象发消息,就是调用对象对应的关联函数(<code>方法Method</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>lisa = Student(<span class="hljs-string">&#x27;Lisa Simpson&#x27;</span>, <span class="hljs-number">87</span>)<br>bart.print_score()<br>lisa.print_score()<br></code></pre></td></tr></table></figure><blockquote><p>面向对象的抽象程度比函数高,一个Class既包含数据也包含操作数据的方法.</p></blockquote><h1 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h1><blockquote><p><code>类</code>是抽象的模板,<code>实例</code>是具体的对象.</p></blockquote><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>通过关键字<code>class</code>定义一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><blockquote><p><code>class</code> 后面跟类名,<code>类名</code>通常使用驼峰命名.<br><code>(object)</code>表示<code>父类(从哪个类继承下来)</code>,如果没有合适的<code>继承类</code>就使用<code>object</code>类,这是所有类最终都会继承的类.</p><p><code>(object)</code>表示继承根类,如果是继承根类,可以直接忽略不写.</p></blockquote><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>类名+<code>()</code>创建实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student()<br>bart<br><span class="hljs-comment"># 变量bart指向一个Student实例对象,后面的0x10a67a590是内存地址,每个object地址都不一样</span><br>&gt; &lt;__main__.Student <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a67a590</span>&gt;<br>Student<br><span class="hljs-comment"># Student本身则是一个类</span><br>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Student&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="给实例绑定属性"><a href="#给实例绑定属性" class="headerlink" title="给实例绑定属性"></a>给实例绑定属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">bart.name = <span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="初始化属性"><a href="#初始化属性" class="headerlink" title="初始化属性"></a>初始化属性</h2><blockquote><p>由于类起到<code>模板</code>的作用,在创建类时,我们可以把一些我们认为必须<code>绑定</code>的属性强制填写进去,通过<code>__init__</code>方法.</p><p>这个特殊方法有时也叫<code>初始化属性</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span>: <span class="hljs-subst">&#123;self.score&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="init"><a href="#init" class="headerlink" title="init()"></a><strong>init</strong>()</h2><blockquote><p><code>__init__()</code> 方法是Python中类的特殊方法之一，用于在创建类的实例时进行初始化操作。它是一个构造方法，负责在对象被创建时设置对象的初始状态。当你创建一个类的实例时，Python会自动调用该类的 <code>__init__()</code> 方法，如果该方法在类中被定义的话。这允许你在对象创建时执行任何必要的初始化工作。<code>__init__()</code>方法在<code>实例创建时自动调用,用于执行初始化任务</code>.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, param1, param2</span>):<br>        <span class="hljs-variable language_">self</span>.param1 = param1<br>        <span class="hljs-variable language_">self</span>.param2 = param2<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Object initialized with parameters:&quot;</span>, param1, param2)<br>        <br><span class="hljs-comment"># __init__()在创建实例时就会执行</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_object = MyClass(<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>)<br>Object initialized <span class="hljs-keyword">with</span> parameters: value1 value2<br></code></pre></td></tr></table></figure><p><code>__init__</code>方法第一个参数永远是<code>self</code>,表示创建的<code>实例本身</code>.这样在<code>__init__</code>方法内部就可以把各种属性绑定到<code>self</code>,<code>self</code>指向创建的实例本身.</p><p>有了<code>__init__</code>,在创建实例时,就<code>不能传空参数</code>,必须传入跟<code>__init__</code>匹配的参数,<code>self</code>不需要传,python解释器会自己把实例变量传进去.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.name<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.score<br><span class="hljs-number">59</span><br></code></pre></td></tr></table></figure><p>在类中定义的函数(<code>方法</code>),第一个参数永远是<code>self</code>,调用时不用传递<code>self</code>,除此以外,和普通函数没有区别.</p><h2 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h2><blockquote><p>比如上面的<code>Student</code>类,每个实例都拥有<code>name</code>,<code>score</code>这些数据.</p><p><code>Student</code>实例本身就拥有这些数据,要访问这些数据,没有必要通过外部函数读取,可以直接在<code>Student</code>类的内部定义访问数据的函数.</p><p>这个就叫<code>数据封装</code>,数据和逻辑被“封装”起来了,调用很容易,但却不用知道内部实现的细节.</p><p>封装数据的函数与类本身关联起来,称作类的<code>方法</code>.</p></blockquote><h2 id="实例绑定数据"><a href="#实例绑定数据" class="headerlink" title="实例绑定数据"></a>实例绑定数据</h2><p>Python运行<code>实例</code>绑定新的数据,即使类没有定义的数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>bart.score<br>&gt; <span class="hljs-number">59</span><br>bart.age = <span class="hljs-number">8</span><br>bart.age<br>&gt; <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h1 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h1><p>上面的例子中,外部的代码可以自由地修改一个实例的<code>name</code>,<code>score</code>属性:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br>bart.score<br>&gt; <span class="hljs-number">59</span><br>bart.score = <span class="hljs-number">99</span><br>bart.score<br>&gt; <span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p>如果想让内部属性不被外部访问,在属性名前加<code>__</code>,代表<code>私有变量(private)</code>,外部就不能访问.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, score</span>):<br>        <span class="hljs-variable language_">self</span>.__name = name<br>        <span class="hljs-variable language_">self</span>.__score = score<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%s: %s&#x27;</span> % (<span class="hljs-variable language_">self</span>.__name, <span class="hljs-variable language_">self</span>.__score))<br>        <br><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__score<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__name&#x27;</span> <br></code></pre></td></tr></table></figure><blockquote><p> 这样外部代码就不能随意修改对象内部的状态,通过访问限制的保护,代码更健壮.</p></blockquote><p>如果外部代码要获取内部属性,可以给student类增加<code>get_name</code>和<code>get_score</code>等方法.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__score<br></code></pre></td></tr></table></figure><p>如果又要允许外部代码修改内部属性呢?<code>Best practise</code>是额外写一个方法去修改,因为在方法中,我们可以对参数做检查,<code>避免传入无效参数</code>,代码更健壮.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_score</span>(<span class="hljs-params">self, score</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= score &lt;= <span class="hljs-number">100</span>:<br>            <span class="hljs-variable language_">self</span>.__score = score<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;bad score&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><code>__xxx__</code>双下划线开头和结尾的<code>变量</code>是特殊变量,<code>特殊变量</code>可以直接访问,不是private.</p></li><li><p><code>_xxx</code>单下划线开头的变量意思是<code>虽然我可以被外部访问，但是，请把我视为私有变量，不要随意访问</code>.</p></li><li><p><code>__xxx</code>双下划线开头的变量是私有变量,但是它实际上是通过python解释器,把<code>__xxx</code>改成了<code>__Student__xxx</code>,实际上还是可以访问的.所以Python并没有强制的访问控制手段,一切全靠自觉.</p></li></ul><p>注意:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>bart = Student(<span class="hljs-string">&#x27;Bart Simpson&#x27;</span>, <span class="hljs-number">59</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name = <span class="hljs-string">&#x27;New Name&#x27;</span> <span class="hljs-comment"># 设置__name变量！</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.__name<br><span class="hljs-string">&#x27;New Name&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>bart.get_name()<br><span class="hljs-string">&#x27;Bart Simpson&#x27;</span><br></code></pre></td></tr></table></figure><p>表面上好像是访问了<code>__name</code>并赋了新值,但实际上是创建了一个<code>__name</code>的新属性,因为原来的<code>__name</code>属性已经被python解释器改为了<code>__Student__name</code>.</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Animal is running...&#x27;</span>)<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><code>Dog</code>和<code>Cat</code>继承自<code>Animal</code>,所以Animal是Dog和Cat的<code>父类</code>,后者则是前者的<code>子类</code>.</p><ul><li>子类将获得父类的所有方法</li><li>子类可以自己<code>增加或者重写</code>方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">dog = Dog()<br>dog.run()<br>&gt; Animal <span class="hljs-keyword">is</span> running...<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Dog is running...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Eating meat...&#x27;</span>)<br>        <br>dog.run()<br>&gt; Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>当子类和父类都有同样的方法时,我们说子类<code>覆盖</code>父类的方法,也叫<code>重写</code>.</p><p>继承可以一级一级地继承下去,<code>object</code>是所有类的<code>根类</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ascii">                ┌───────────────┐<br>                │    object     │<br>                └───────────────┘<br>                        │<br>           ┌────────────┴────────────┐<br>           │                         │<br>           ▼                         ▼<br>    ┌─────────────┐           ┌─────────────┐<br>    │   Animal    │           │    Plant    │<br>    └─────────────┘           └─────────────┘<br>           │                         │<br>     ┌─────┴──────┐            ┌─────┴──────┐<br>     │            │            │            │<br>     ▼            ▼            ▼            ▼<br>┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐<br>│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │<br>└─────────┘  └─────────┘  └─────────┘  └─────────┘<br></code></pre></td></tr></table></figure><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>首先我们需要理解:定义一个class,实际上是定义了一个新的<code>数据类型</code>,它跟python自身的list, str, dict 等数据类型一样.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">list</span>()<br>b = Animal()<br>c = Dog()<br><span class="hljs-comment"># 判断一个变量是否为某个类型用isinstance()</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">list</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(b, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Dog)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>然后你会发现,<code>c</code>也是Animal类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(c, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>所以,继承关系中,如果一个<code>实例</code>的数据类型是某个<code>子类</code>,那么它也同时属于<code>父类</code>.当然,反过来是不行的.</p><p>一个实例同时属于多个数据类,这就叫<code>多态</code>.</p><p>举个例子说明多态的好处:</p><p>定义一个<code>run_twice</code>函数,接受<code>Animal</code>类型的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_twice</span>(<span class="hljs-params">Animal</span>):<br>    Animal.run()<br>    Animal.run()<br></code></pre></td></tr></table></figure><p>此时,因为<code>Dog()</code>,<code>Cat()</code>也是属于<code>Animal</code>,所以可以直接传入:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Dog())<br>Dog <span class="hljs-keyword">is</span> running...<br>Dog <span class="hljs-keyword">is</span> running...<br></code></pre></td></tr></table></figure><p>也可以再定义一个<code>Tortoise</code>类,同样继承于<code>Animal</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tortoise</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Tortoise is running slowly...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>同样可以直接传入并调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>run_twice(Tortoise())<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br>Tortoise <span class="hljs-keyword">is</span> running slowly...<br></code></pre></td></tr></table></figure><blockquote><p>多态的好处就是每新增一个<code>子类</code>,任何依赖其<code>父类</code>作为参数的函数或方法都可以<code>不加修改地正常运行</code>.</p><p>以上面的例子来说,不管我们传入的是<code>Dog</code>,<code>Cat</code>,<code>Tortoise</code>还是别的任意<code>Animal</code>子类,<code>run_twice</code>都能不加修改地正常运行.</p><p>对于一个变量,我们只需知道它是<code>Animal</code>类型,无需确切知道它的子类,就能放心调用<code>run()</code>方法.</p><p>调用方只管调用,不管细节,这就是著名的<code>开闭原则</code>:</p><ul><li>对扩展开放: 允许新增<code>Animal</code>子类</li><li>对修改封闭: 不需要修改依赖<code>Animal</code>类型的<code>run_twice</code>函数</li></ul></blockquote><h1 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h1><p>有别于<code>静态语言</code>(Java),对于<code>动态语言</code>(python)来说,它其实并不要求严格的<code>继承关系</code>, 一个对象只要<code>开起来像鸭子,走起路来像鸭子</code>,就可以被看作鸭子.</p><p>这就是动态语言的<code>鸭子类型</code>:</p><blockquote><p>如果需要传入<code>Animal</code>类型.传入的对象并不一定要<code>Animal</code>或它的<code>子类</code>,只要传入的对象又<code>run()</code>方法就行.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_it_walk</span>(<span class="hljs-params">duck</span>):<br>    duck.walk() <span class="hljs-comment"># 只要传入的对象有walk方法,就能执行,不需要管到底传入哪个class</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Duck</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This duck is walking&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This person is walking&quot;</span>)<br><br>duck = Duck()<br>person = Person()<br><br>make_it_walk(duck)   <span class="hljs-comment"># 输出: This duck is walking</span><br>make_it_walk(person) <span class="hljs-comment"># 输出: This person is walking</span><br></code></pre></td></tr></table></figure><h1 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h1><blockquote><p>当我们拿到一个对象的引用时,如何知道这个对象是什么类型?有那些方法呢?</p></blockquote><h2 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h2><p>用于判断对象类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 基本类型</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;str&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)<br>&lt;<span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>) <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;<br><span class="hljs-comment"># 函数或类</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Animal&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p><code>type()</code>函数返回对应的Class类型,可以通过<code>if</code>语句比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>判断是否为函数,可以使用<code>types</code>模块定义的常量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> types<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">type</span>(fn) == types.FunctionType<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>) == types.BuiltinFunctionType<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x) == types.LambdaType<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))) == types.GeneratorType<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h2><p>判断class的类型,和继承关系可以使用<code>isinstance()</code></p><p>还是上面的例子,如果继承关系是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">object -&gt; Animal -&gt; Dog -&gt; Husky<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先创建实例</span><br>a = Animal()<br>d = Dog()<br>h = Husky()<br><br><span class="hljs-comment"># 判断</span><br><span class="hljs-built_in">isinstance</span>(h, Husky)<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">isinstance</span>(h, Dog)<br><span class="hljs-literal">True</span><br><span class="hljs-built_in">isinstance</span>(h, Animal)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>能用type判断的基本类型也可以用isinstance判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-built_in">str</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>还可以判断<code>是否为某些类型中的一种</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><blockquote><p>优先使用<code>isinstance</code>判断类型,可以将指定类型及其子类一网打尽</p></blockquote><h2 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h2><p>获取一个对象的所有<code>属性</code>和<code>方法</code>, 返回一个包含字符串的list.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>类似<code>__xxx__</code>的属性和方法再python中都是有特殊用途的,比如<code>__len__</code>方法返回长度.</p><p>如果你调用<code>len()</code>函数获取一个对象的函数,实际上,在<code>len()</code>函数内部是去调用该对象的<code>__len__()</code>方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如下两段代码等价</span><br><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__()<br></code></pre></td></tr></table></figure><p>如果是我们自己写的类,如果也想调用<code>len(myObj)</code>,就要自己写一个<code>__len__()</code>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDog</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>d = MyDog()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(d)<br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>其余的都是普通的属性或方法.</p><h2 id="操作对象属性"><a href="#操作对象属性" class="headerlink" title="操作对象属性"></a>操作对象属性</h2><p><code>getattr()</code>获取对象属性</p><p><code>setattr()</code>设置对象属性</p><p><code>hasattr()</code>判断对象属性是否存在</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.x = <span class="hljs-number">9</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.x * <span class="hljs-variable language_">self</span>.x<br>    <br>obj = MyObject()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.x<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">19</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>)<br><span class="hljs-number">19</span><br><br><span class="hljs-comment"># 获取不存在的属性会报错</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;MyObject&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;z&#x27;</span><br><span class="hljs-comment"># 也可以设定不存在时候返回的值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">404</span>)<br><span class="hljs-number">404</span><br></code></pre></td></tr></table></figure><p>也可以获取对象的方法,在python中,对象的<code>方法</code>也同样属于对象的<code>属性</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>)<br>&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10077a6a0</span>&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>fn = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>fn() <span class="hljs-comment"># 等价于obj.power()</span><br><span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>一般来说,如果我们只有在不知道对象信息的时候,才会去获取, 如果可以直接写<code>obj.x</code>就不要写<code>getattr(obj, &#39;s&#39;)</code>.正确的用法例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">假设我们希望从文件流fp中读取图像，我们首先要判断该fp对象是否存在read方法，如果存在，则该对象是一个流，如果不存在，则无法读取</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readImage</span>(<span class="hljs-params">fp</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(fp, <span class="hljs-string">&#x27;read&#x27;</span>):<br>        <span class="hljs-keyword">return</span> readData(fp)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><blockquote><p>python是动态语言,根据鸭子类型,有<code>read()</code>方法,也不代表它就是一个文件流,但只要<code>read()</code>方法返回的是有效的图像数据,就不影响读取图像的功能.</p></blockquote><h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><p>python是动态语言,根据类创建的实例可以任意绑定属性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name <span class="hljs-comment"># 通过self变量绑定</span><br>        <br>s = Student(<span class="hljs-string">&#x27;Bob&#x27;</span>)<br>s.score = <span class="hljs-number">90</span> <span class="hljs-comment"># 通过实例变量绑定</span><br></code></pre></td></tr></table></figure><p>上面通过两种方式定义的是<code>实例属性</code></p><p>下面定义的是<code>类属性</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br></code></pre></td></tr></table></figure><p>两个属性的调用有所不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 打印实例属性, 因为实例没有name属性,所以会打印类属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 打印类属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Peter&#x27;</span> <span class="hljs-comment"># 绑定实例属性name</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 打印实例属性</span><br>Peter<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 打印类属性</span><br>Student<br></code></pre></td></tr></table></figure><blockquote><p><code>实例属性</code>优先级比<code>类属性</code>高,如果定义了相同名字的实例属性于类属性,将会优先打印实例属性.</p><p>所以千万不要用相同的名字.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-模块</title>
    <link href="/2024/01/10/python-module/"/>
    <url>/2024/01/10/python-module/</url>
    
    <content type="html"><![CDATA[<blockquote><p>世人都说不要重复造轮子,但学习阶段,自己造些轮子,还是很有用的.</p></blockquote><blockquote><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p><p>创建自己的模块时，要注意：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符；</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行<code>import abc</code>，若成功则说明系统存在此模块。</li><li>另外注意函数名不要和<a href="https://docs.python.org/3/library/functions.html">内置函数</a>重名</li></ul></blockquote><h1 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h1><p>为了避免模块名冲突,python引入了按目录来组织模块的方法,称为<code>包(package)</code></p><p>一个<code>abc.py</code>文件就是一个名叫<code>abc</code>的模块,一个<code>xyz.py</code>文件就是一个名字叫<code>xyz</code>的模块,假设这两个模块于其他模块冲突了,此时可以通过<code>包</code>来避免,只要加一个顶层包名,比如<code>mycompany</code>,按照如下目录存放:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mycompany<br>├─ __init__.py<br>├─ abc.py<br>└─ xyz.py<br></code></pre></td></tr></table></figure><p>其中每一个包目录下面都要有一个<code>__init__.py</code>文件,这个文件是<code>必须的</code>,里面可以是空文件,也可以有代码,因为<code>__init__.py</code>本身就是一个模块,它的模块名就是<code>mycompany</code></p><p>另外可以有多级目录,组成多层次的包结构,每一层都要有<code>__init__.py</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ascii">mycompany<br> ├─ web<br> │  ├─ __init__.py<br> │  ├─ utils.py<br> │  └─ www.py<br> ├─ __init__.py<br> ├─ abc.py<br> └─ utils.py<br></code></pre></td></tr></table></figure><p>文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>。</p><h1 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xxx<br><span class="hljs-keyword">import</span> xxx <span class="hljs-keyword">as</span> xx<br><span class="hljs-keyword">from</span> xxx <span class="hljs-keyword">import</span> xx<br></code></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>pip<br>一般来说第三方库都会在官方的<a href="https://pypi.org/">pypi.python.org</a>注册,通过pip命令即刻安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install requests<br></code></pre></td></tr></table></figure></li><li><p>Anaconda</p><blockquote><p>Anaconda会把系统Path中的python指向自己自带的Python，并且，Anaconda安装的第三方模块会安装在Anaconda自己的路径下，不影响系统已安装的Python目录.</p><p>另外,用Anaconda管理虚拟环境也是很好的选择.</p></blockquote></li></ol><h2 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h2><p>默认下,python会搜索<code>当前目录</code>,<code>所有已安装的内置模块</code>和<code>第三方模块</code>,搜索路径存放在<code>sys</code>模块的<code>path</code>变量中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path<br>&gt; [<span class="hljs-string">&#x27;/opt/python3/bin&#x27;</span>,<br> <span class="hljs-string">&#x27;/opt/python3/lib/python310.zip&#x27;</span>,<br> <span class="hljs-string">&#x27;/opt/python3/lib/python3.10&#x27;</span>,<br> <span class="hljs-string">&#x27;/opt/python3/lib/python3.10/lib-dynload&#x27;</span>,<br> <span class="hljs-string">&#x27;&#x27;</span>,<br> <span class="hljs-string">&#x27;/opt/python3/lib/python3.10/site-packages&#x27;</span>]<br></code></pre></td></tr></table></figure><p>修改搜索路径,添加自己的目录有两种方法:</p><ol><li><p>在代码中修改<code>sys.path</code>,这种方法<code>只会在代码运行时有效</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br>sys.path.append(<span class="hljs-string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>修改环境变量<code>PYTHONPATH</code>,该变量的内容会<code>添加</code>到原有的搜索路径中,原来的搜索路径不受影响.</p></li></ol><h2 id="模块编写"><a href="#模块编写" class="headerlink" title="模块编写"></a>模块编写</h2><p>以<code>hello</code>模块为例,展示<code>标准的模块模板</code>:</p><p>hello.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&#x27; a test module &#x27;</span><br><br>__author__ = <span class="hljs-string">&#x27;Michael Liao&#x27;</span><br><br><span class="hljs-keyword">import</span> sys <span class="hljs-comment"># 导入sys模块后,就有了sys这个变量指向sys模块</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    args = sys.argv <span class="hljs-comment"># sys有一个argv变量,用list存储命令所有参数,第一个参数永远是运行的.py文件文件名</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args)==<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(args)==<span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % args[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Too many arguments!&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><ul><li>第一行是标准注释,表明使用哪个python运行时</li><li>第二行也是标准注释,表明.py文件本身使用标准的UTF-8编码</li><li>第四行是一个字符串,任何模块代码的<code>第一个字符串</code>都被视为<code>模块的文档注释</code></li><li><code>__author__</code>变量表示模块作者</li><li>后面才是你的代码</li></ul><p>注意这两行代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><p>当我们在命令行运行<code>hello</code>模块文件时,python解释器会把一个特殊的变量<code>__name__</code>赋值为<code>__main__</code>,</p><p>而如果在其他地方导入该模块,<code>if</code>判断会失效,</p><p>所以这种<code>if</code>可以让一个模块通过<code>命令行运行</code>时执行一些<code>额外的代码</code>.用作<code>运行测试</code>.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在命令行运行</span><br>python hello.py Peter<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hello, Peter!</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">导入时,没有任何输出</span><br>import hello<br><span class="hljs-meta prompt_"># </span><span class="language-bash">只有调用里面的函数才会执行代码</span><br>hello.test()<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">Hello world!</span><br></code></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p> <code>__xxx__</code>是特殊变量,可以被直接引用,是<code>public</code>的,比如<code>__author__</code>,<code>__name__</code>等,模块定义的文档注释也可以用<code>__doc__</code>访问,我们自己代码一般不要用这种变量名</p></blockquote><ul><li>正常的函数名和变量是公开的<code>public</code>,可以被直接引用</li><li>非公开的<code>private</code>函数名和变量以<code>_</code>前缀来表示,比如<code>_xxx</code>和<code>__xxx</code>.他们都<code>不应该</code>被直接引用<ul><li>python并没有一种方法可以完全限制private函数或变量的访问,但是从编程习惯上我们<code>不应该</code>应用private函数或变量</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_private_1</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello, %s&#x27;</span> % name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_private_2</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hi, %s&#x27;</span> % name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greeting</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) &gt; <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> _private_1(name)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> _private_2(name)<br></code></pre></td></tr></table></figure><p>例如上面的代码,只公开了<code>greeting</code>函数,内部逻辑都用<code>private</code>函数隐藏起来.这样在调用<code>greeting()</code>时就不需要关心内部的provate函数细节,这是一种非常有用的<code>代码封装和抽象的方法</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-函数式编程</title>
    <link href="/2024/01/05/python-functional-coding/"/>
    <url>/2024/01/05/python-functional-coding/</url>
    
    <content type="html"><![CDATA[<blockquote><p>函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。</p><p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p><p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p><p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p><p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p><p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p><p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p><p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p></blockquote><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><blockquote><p>接受两个参数:</p><ol><li>函数</li><li>Iterable</li></ol><p><code>map()</code>将传入的函数依次作用于可迭代对象<code>Iterable</code>的每个元素中,将结果作为新的迭代器<code>Iterator</code>返回</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br><br>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br><span class="hljs-comment"># list函数可以将惰性序列interator的整个序列计算出来并返回一个list</span><br><span class="hljs-built_in">list</span>(r)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br><span class="hljs-comment"># 将list所有数字转成字符串</span><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))<br></code></pre></td></tr></table></figure><p><code>map()</code>规范化英文名字(首字母大写,其余小写)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">normalize</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-keyword">return</span> name[<span class="hljs-number">0</span>].upper() + name[<span class="hljs-number">1</span>:].lower()<br><br>L1 = [<span class="hljs-string">&#x27;adam&#x27;</span>, <span class="hljs-string">&#x27;LISA&#x27;</span>, <span class="hljs-string">&#x27;barT&#x27;</span>]<br>L2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(normalize, L1))<br><span class="hljs-built_in">print</span>(L2)<br>&gt; [<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-string">&#x27;Lisa&#x27;</span>, <span class="hljs-string">&#x27;Bart&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h2><blockquote><p>接受两个参数:</p><ol><li>函数</li><li>Iterable</li></ol><p><code>reduce()</code>也是把一个函数作用在一个序列上,但不一样的的是reduce的函数必须接受两个参数,然后reduce会把结果继续和序列的下一个元素做累积计算</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 效果如: reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])<br><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>上面的例子完全可以用<code>sum()</code>代替,下面再举些实际点的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 把序列[1, 3, 5, 7, 9]变成整数13579</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])<br><span class="hljs-number">13579</span><br></code></pre></td></tr></table></figure><p>字符串<code>str</code>也是一个序列,配合<code>map</code>,我们可以自己写一个<code>int()</code>函数,将字符串转为整形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">char2num</span>(<span class="hljs-params">s</span>):<br>    digits = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br>    <span class="hljs-keyword">return</span> digits[s]<br><br><span class="hljs-comment"># 先把字符串转换成int序列,然后通过reduce计算出整数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>reduce(fn, <span class="hljs-built_in">map</span>(char2num, <span class="hljs-string">&#x27;13679&#x27;</span>))<br><span class="hljs-number">13479</span><br></code></pre></td></tr></table></figure><p>整理成一个<code>str2int</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>DIGITS = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">str2int</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>):<br>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">char2num</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-keyword">return</span> DIGITS[s]<br>    <span class="hljs-keyword">return</span> reduce(fn, <span class="hljs-built_in">map</span>(char2num, s))<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>str2int(<span class="hljs-string">&#x27;13579&#x27;</span>)<br><span class="hljs-number">13579</span><br></code></pre></td></tr></table></figure><p>通过lambda进一步简化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>DIGITS = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">char2num</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> DIGITS[s]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">str2int</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x * <span class="hljs-number">10</span> + y, <span class="hljs-built_in">map</span>(char2num, s))<br></code></pre></td></tr></table></figure><p>如此就能自己实现一个<code>int()</code>函数</p><p>写一个prod函数,可以接受一个list,并计算里面元素的累乘积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prod</span>(<span class="hljs-params">L</span>):<br>    <span class="hljs-keyword">return</span> reduc(<span class="hljs-keyword">lambda</span> x, y: xy * y, L)<br></code></pre></td></tr></table></figure><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map+reduce"></a>map+reduce</h3><p>使用map和reduce,写一个<code>str2float</code>函数,将字符串’123.456’转换成浮点型<code>123.456</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">str2float</span>(<span class="hljs-params">s</span>):<br>    DIGITS = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br>    s_list = s.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    n_1 = reduce(<span class="hljs-keyword">lambda</span> x, y: x * <span class="hljs-number">10</span> + y, <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: DIGITS[x], s_list[<span class="hljs-number">0</span>]))<br>    length = <span class="hljs-built_in">len</span>(s_list[<span class="hljs-number">1</span>])<br>    n_2 = reduce(<span class="hljs-keyword">lambda</span> x, y: x * <span class="hljs-number">10</span> + y, <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: DIGITS[x], s_list[<span class="hljs-number">1</span>])) * (<span class="hljs-number">10</span> ** (-length))<br>    <span class="hljs-keyword">return</span> n_1 + n_2<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><blockquote><p>接受一个函数和一个序列,将函数依次作用于序列的每个元素,根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素.</p><p>同样返回生成器<code>Iterator</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 过滤偶数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_odd</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span><br><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(is_odd, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]))<br><br>&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>]<br><br><span class="hljs-comment"># 删除空字符串</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">not_empty</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> s <span class="hljs-keyword">and</span> s.strip()<br><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(not_empty, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;  &#x27;</span>]))<br><br>&gt; [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><blockquote><p>排序的核心是比较两个元素的大小,如果是数字就直接比较,如果是str或dict,比较过程则通过函数抽象出来.</p><p><code>sorted()</code>可以接收一个<code>key</code>函数实现自定义排序</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接排列数字,小到大</span><br><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>])<br>&gt; [-<span class="hljs-number">21</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">36</span>]<br><span class="hljs-comment"># 通过key,按绝对值大小排序</span><br><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>], key=<span class="hljs-built_in">abs</span>)<br>&gt; [<span class="hljs-number">5</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">12</span>, -<span class="hljs-number">21</span>, <span class="hljs-number">36</span>]<br></code></pre></td></tr></table></figure><p>仔细看可以发现,最终返回的是<code>原始list</code>的元素,它实际上是按照<code>key</code>函数的规则先对原始数列排序,然后再对应原始数列输出原始数列的元素.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">keys排序结果 =&gt; [5, 9,  12,  21, 36]<br>                |  |    |    |   |<br>最终结果     =&gt; [5, 9, -12, -21, 36]<br></code></pre></td></tr></table></figure><p>字符串排序默认情况下是按照<code>ASCII</code>码来比较大小(大写<code>Z</code>&lt;小写<code>a</code>),因此我们很多时候要忽略大小写去比较.要实现这个功能,只需要通过<code>key</code>将源字符串全部转为大写&#x2F;小写即可.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>([<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>], key=<span class="hljs-built_in">str</span>.lower)<br>&gt; [<span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>]<br></code></pre></td></tr></table></figure><p>如果要<code>反向排序</code>,则要用到第三个参数<code>reverse</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>([<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>], key=<span class="hljs-built_in">str</span>.lower, reverse=<span class="hljs-literal">True</span>)<br>&gt; [<span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>]<br></code></pre></td></tr></table></figure><p>小结: <code>sorted</code>实际上是先排序,再映射.</p><h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><blockquote><p><code>高阶函数</code>除了可以接受函数作为参数,还是把函数作为<code>返回值</code>返回.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个可变参数的求和函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc_sum</span>(<span class="hljs-params">*args</span>):<br>    ax = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args:<br>        ax = ax + n<br>    <span class="hljs-keyword">return</span> ax<br></code></pre></td></tr></table></figure><p>如果不需要立即求和,而是在后面的代码中根据需要再计算,此时可以<code>不返回求和结果</code>,只是<code>返回求和函数</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">lazy_sum</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>():<br>        ax = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args:<br>            ax = ax + n<br>        <span class="hljs-keyword">return</span> ax<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br>        <br><span class="hljs-comment"># 此时返回的是sum函数</span><br>f = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>f<br>&gt; &lt;function lazy_sum.&lt;<span class="hljs-built_in">locals</span>&gt;.<span class="hljs-built_in">sum</span> at <span class="hljs-number">0x101c6ed90</span>&gt;<br><br><span class="hljs-comment"># 调用函数f的时候才是真正计算的结果</span><br>f()<br>&gt; <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>注意: 每次调用,返回的都是全新的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">f1 = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>f2 = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<br>f1==f2<br>&gt; <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="返回的函数并非立刻执行"><a href="#返回的函数并非立刻执行" class="headerlink" title="返回的函数并非立刻执行"></a>返回的函数并非立刻执行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>():<br>    fs = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        <span class="hljs-comment"># 每次循环都创建一个新函数,然后把创建的3个函数以list形式返回</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>            <span class="hljs-keyword">return</span> i * i<br>        fs.append(f)<br>    <span class="hljs-keyword">return</span> fs<br><br>f1, f2, f3 = count()<br></code></pre></td></tr></table></figure><p>当你调用f1-3时,你以为它会返回1,4,9; 但实际上它的返回如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">f1()<br>&gt; <span class="hljs-number">9</span><br><br>f2()<br>&gt; <span class="hljs-number">9</span><br><br>f3()<br>&gt; <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><blockquote><p>原因在于返回的函数引用了变量<code>i</code>,但它<code>不是立即执行</code>.等到三个函数都返回时, <code>i</code>已经变成<code>3</code>,因此结果都是<code>9</code>.</p></blockquote><p>那如果一定要引用循环变量呢: 可以再定义一个函数,<code>用该函数的参数绑定循环变量当前的值</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">j</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">g</span>():<br>            <span class="hljs-keyword">return</span> j * j<br>        <span class="hljs-keyword">return</span> g<br>    fs = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>    fs.append(f(i)) <span class="hljs-comment"># i的值作为参数传入f(),要记得函数的参数是立即被计算的</span><br>        <span class="hljs-keyword">return</span> fs<br></code></pre></td></tr></table></figure><p>此时结果就是预料中的<code>1</code>,<code>4</code>,<code>9</code>.</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><code>lazy_sum</code>的例子中,返回的函数在其内部定义了局部变量<code>args</code>,这种称之为<code>闭包</code>.</p><p>就是<code>内层函数引用了外层函数的局部变量</code>.</p><p>如果只是读外层函数的值是没问题的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>():<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>        <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span> <span class="hljs-comment"># 此时返回的是x+1这个表达式,并没有修改x的值,所以只是只读</span><br>    <span class="hljs-keyword">return</span> fn<br><br>f = inc()<br><span class="hljs-built_in">print</span>(f())<br>&gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>但是如果对外层变量赋值就会报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>():<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>        x = x + <span class="hljs-number">1</span> <span class="hljs-comment"># 这里是修改了x的值</span><br>        <span class="hljs-keyword">return</span> x <br>    <span class="hljs-keyword">return</span> fn<br><br>&gt; UnboundLocalError: cannot access local variable <span class="hljs-string">&#x27;x&#x27;</span> where it <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> associated <span class="hljs-keyword">with</span> a value<br></code></pre></td></tr></table></figure><p>因为python解释器会把<code>x</code>当作函数<code>fn()</code>的局部变量,而<code>x</code>作为局部变量没有初始化就直接计算<code>x+1</code>是不行的,所以我们需要在<code>fn()</code>内部加上<code>nonlocal x</code>的声明,声明<code>x</code>不是<code>fn()</code>的局部变量,解释器就会把<code>fn()</code>里面的<code>x</code>看作外层函数的局部变量,这样才能计算成功.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">inc</span>():<br>    x = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>():<br>        <span class="hljs-keyword">nonlocal</span> x <span class="hljs-comment"># 告诉解释器这不是fn()的局部变量是外层函数的局部变量</span><br>        x = x + <span class="hljs-number">1</span> <span class="hljs-comment"># 此时就可以修改x的值</span><br>        <span class="hljs-keyword">return</span> x<br>    <span class="hljs-keyword">return</span> fn<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>一个函数可以返回一个计算结果, 也可以返回一个函数</li><li>返回一个函数时,该函数并非立即执行,返回函数中不要引用任何可能变化的变量</li></ol><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>就是<code>lambda</code>, 比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> x: x * x<br><span class="hljs-comment"># 等价于</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * x<br></code></pre></td></tr></table></figure><p>好处:</p><ol><li>没有名字,不必当心函数名冲突</li><li>lambda也是一个函数对象,可以赋值给一个变量,再用该变量调用函数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-keyword">lambda</span> x: x * x<br>f<br>&lt;function &lt;<span class="hljs-keyword">lambda</span>&gt; at <span class="hljs-number">0x101c6ef28</span>&gt;<br>f(<span class="hljs-number">5</span>)<br>&gt; <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><ol start="3"><li>一些简单的,一次性的函数用lambda可以缩短&#x2F;简洁代码</li></ol><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><blockquote><p>函数也是一个<code>对象</code>,函数对象有一个<code>__name__</code>属性,该属性就是函数的名字</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fn.__name__<br>&gt; <span class="hljs-string">&#x27;fn&#x27;</span><br></code></pre></td></tr></table></figure><p>假设现在我们想增加函数的功能,比如,在函数调用前后自动打印日志,但又不想修改原函数的定义:</p><p>这种<code>在代码运行期间动态增加功能</code>的方式,就是<code>装饰器(Decorator)</code></p><p>装饰器的本质就是一个返回函数的高阶函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个打印日志的Decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;call <span class="hljs-subst">&#123;func.__name__&#125;</span>:&#x27;</span>)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br></code></pre></td></tr></table></figure><p>这个装饰器<code>decorator</code>接受一个函数作为参数,并返回一个函数</p><p>使用<code>@</code>调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@log</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">now</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2024-1-9&#x27;</span>)<br>    <br>now()<br>&gt; call now():<br>&gt; <span class="hljs-number">2024</span>-<span class="hljs-number">1</span>-<span class="hljs-number">9</span><br><br><span class="hljs-comment"># 相当于执行</span><br>now = log(now)<br>now()<br></code></pre></td></tr></table></figure><blockquote><p>由于<code>log()</code>是一个decorator，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。</p><p><code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。</p></blockquote><p>如果decorator本身需要传入参数,那就需要编写一个返回decorator的高阶函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;text&#125;</span>, <span class="hljs-subst">&#123;func.__name__&#125;</span>():&quot;</span>)<br>            <span class="hljs-keyword">return</span> func(*args, **kw)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><br><span class="hljs-comment"># 用法如下</span><br><span class="hljs-meta">@log(<span class="hljs-params"><span class="hljs-string">&#x27;execute&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">now</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;2024-1-9&#x27;</span>)<br>    <br>now()<br>&gt; execute now():<br>&gt; <span class="hljs-number">2024</span>-<span class="hljs-number">1</span>-<span class="hljs-number">9</span><br><br><span class="hljs-comment"># 相当于执行</span><br>now = log(<span class="hljs-string">&#x27;execute&#x27;</span>)(now)<br>now()<br></code></pre></td></tr></table></figure><blockquote><p>首先执行<code>log(&#39;execute&#39;)</code>返回了<code>decorator()</code>,然后再调用返回的<code>decorator()</code>,参数是<code>now()</code>,最终返回<code>wrapper()</code></p><p>调用<code>wrapper()</code>会打印日志并把源函数<code>now()</code>返回出来,并调用</p></blockquote><h2 id="name-的变动"><a href="#name-的变动" class="headerlink" title="__name__的变动"></a><code>__name__</code>的变动</h2><p>被<code>decortator</code>装饰过的函数,<code>__name__</code>属性都会发生改变,因为最终返回的函数名变了,以上面两个例子为例,最终的<code>__name__</code>属性都会变为<code>wrapper</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">now.__name__<br>&gt; <span class="hljs-string">&#x27;wrapper&#x27;</span><br></code></pre></td></tr></table></figure><p>因为最终返回的函数就是<code>wrapper</code>,所以我们在写装饰器时,还要把原始函数的<code>__name__</code>复制到<code>wrapper()</code>中,避免其他依赖于这个函数的<code>__name__</code>属性的代码报错:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wrapper.__name__ = func.__name__<br></code></pre></td></tr></table></figure><p>但实际上我们不需要手动这样做,用内置模块<code>functools</code>就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 完整的装饰器应该这样写</span><br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-comment"># 不带参数的装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;call <span class="hljs-subst">&#123;func.__name__&#125;</span>():&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-comment"># 带参数的装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">text</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;text&#125;</span> <span class="hljs-subst">&#123;func.__name__&#125;</span>():&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li>写一个装饰器,打印源函数执行时间</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">metric</span>(<span class="hljs-params">fn</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">fn</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        start_time = time.time()<br>        _ = fn(*args, **kw)<br>        end_time = time.time()<br>        time_cost = end_time - start_time<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;fn.__name__&#125;</span> tooks <span class="hljs-subst">&#123;time_cost&#125;</span>ms&quot;</span>)<br>        <span class="hljs-keyword">return</span> fn(*args, **kw)<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@metric</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">x, y</span>):<br>    time.sleep(<span class="hljs-number">0.0012</span>)<br>    <span class="hljs-keyword">return</span> x + y<br></code></pre></td></tr></table></figure><ol start="2"><li>写一个<code>@log</code>,既支持有参数也支持无参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">arg=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">callable</span>(arg):<br><span class="hljs-meta">        @functools.wraps(<span class="hljs-params">arg</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;running <span class="hljs-subst">&#123;arg.__name__&#125;</span>()&quot;</span>)<br>            <span class="hljs-keyword">return</span> arg(*args, **kw)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">fn</span>):<br><span class="hljs-meta">            @functools.wraps(<span class="hljs-params">fn</span>)</span><br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;arg&#125;</span> <span class="hljs-subst">&#123;fn.__name__&#125;</span>()&quot;</span>)<br>                <span class="hljs-keyword">return</span> fn(*args, **kw)<br>            <span class="hljs-keyword">return</span> wrapper<br>        <span class="hljs-keyword">return</span> decorator<br>    <br><span class="hljs-meta">@log</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br>    <br><span class="hljs-meta">@log(<span class="hljs-params"><span class="hljs-string">&#x27;execute&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br></code></pre></td></tr></table></figure><ol start="3"><li>写一个装饰器,在函数调用前后分别输出<code>begin_call</code>和<code>end_call</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log_decorator</span>(<span class="hljs-params">fn</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">fn</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kw</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;begin_call&#x27;</span>)<br>        result = fn(*args, **kw)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end_call&#x27;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@log_decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-built_in">print</span>(x + y)<br></code></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>python的decorator支持函数实现也支持类实现</li><li>在OOP(面向对象)中, decorator也称为装饰模式,通过继承和组合实现</li><li>装饰器用于增强函数功能,定义复杂,使用方便</li></ul><h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><blockquote><p>偏函数是python的自带模块<code>functools</code>提供的功能(<code>partial</code>).</p><p>偏函数就是把特定函数的某些参数<code>固定</code>(默认值),并返回一个新函数.</p></blockquote><p>比如它可以将给一个函数加上一个默认参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比如int()函数可与将字符串转换成整形,它另外还接受一个base参数定义要转换出的整形是N进制</span><br><span class="hljs-comment"># 如果我们需要固定转换成2进制整形,可以这么做</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">int2</span>(<span class="hljs-params">x, base=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(x, base)<br><br><span class="hljs-comment"># 使用偏函数就不需要自己额外定义int2()</span><br><span class="hljs-keyword">import</span> functools<br>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>另外,创建偏函数时,实际上接受了<code>函数对象</code>,<code>*args</code>和<code>**kw</code>3个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 传入*kw</span><br>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br>int2(<span class="hljs-string">&#x27;10010&#x27;</span>)<br><span class="hljs-comment"># 相当于</span><br>kw = &#123;<span class="hljs-string">&#x27;base&#x27;</span>: <span class="hljs-number">2</span>&#125;<br>int2 = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;10010&#x27;</span>, **kw)<br><br><span class="hljs-comment"># 传入*args,注意*args会自动加在参数的最左边</span><br>max2 = functools.partial(<span class="hljs-built_in">max</span>, <span class="hljs-number">10</span>)<br>max2 = (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br><span class="hljs-comment"># 相当于</span><br>args = (<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>)<br>max2 = <span class="hljs-built_in">max</span>(*args)<br></code></pre></td></tr></table></figure><p>总结: 偏函数主要是用来固定参数以及简化代码</p>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell-笔记</title>
    <link href="/2024/01/04/shell-notebook/"/>
    <url>/2024/01/04/shell-notebook/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Cshell-script.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>这里记录一些我觉得值得记录的一些shell script的奇技淫巧</p></blockquote><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote><p>list</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">my_array=(&quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">循环所有元素</span><br>for i in &quot;$&#123;my_array[@]&#125;&quot;;do<br>echo $&#123;i&#125;<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取数组元素个数</span><br>array_length=&quot;$&#123;#my_array[@]&#125;&quot;<br></code></pre></td></tr></table></figure><h1 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h1><blockquote><p>k-v</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义关联数组</span><br>declare -A my_dict<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加键值对</span><br>my_dict[&quot;key1&quot;]=&quot;value1&quot;<br>my_dict[&quot;key2&quot;]=&quot;value2&quot;<br>my_dict[&quot;key3&quot;]=&quot;value3&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取特定键的值</span><br>echo &quot;Value for key2: $&#123;my_dict[&quot;key2&quot;]&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">遍历所有键值对</span><br>for key in &quot;$&#123;!my_dict[@]&#125;&quot;; do<br>  echo &quot;Key: $key, Value: $&#123;my_dict[$key]&#125;&quot;<br>done<br></code></pre></td></tr></table></figure><h1 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h1><blockquote><p>假如我有一个变量,它的变量名是由另一个变量定义的,这时候就可以用到间接引用.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">base_name=&quot;my_array&quot;<br>my_array_1=(&quot;element1&quot; &quot;element2&quot; &quot;element3&quot;)<br>var_name=&quot;$&#123;base_name&#125;_1[@]&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">间接引用数组</span><br>for i in &quot;$&#123;!var_name&#125;&quot;;do<br>echo $&#123;i&#125;<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">间接引用变量</span><br>echo &quot;$&#123;!var_name&#125;&quot;<br></code></pre></td></tr></table></figure><h1 id="跟踪模式"><a href="#跟踪模式" class="headerlink" title="跟踪模式"></a>跟踪模式</h1><blockquote><p>用于debug,开启跟踪模式后,shell会在执行每个命令之前将该命令及其参数输出到stderr.可以通过此模式看到脚本执行每个步骤,有助于定位问题.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行脚本时开启</span><br>bash -x my_script.sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在脚本中配置开启</span><br>set -x<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭</span><br>set +x<br></code></pre></td></tr></table></figure><p>输出类似如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">+ echo &#x27;Hello, World!&#x27;<br>Hello, World!<br>+ variable=&#x27;some value&#x27;<br>+ echo &#x27;The variable is: some value&#x27;<br>The variable is: some value<br></code></pre></td></tr></table></figure><blockquote><p><code>+</code>号就是跟踪模式输出的行</p></blockquote><h1 id="默认值赋值"><a href="#默认值赋值" class="headerlink" title="默认值赋值"></a>默认值赋值</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=$&#123;b:=/b/a&#125;<br></code></pre></td></tr></table></figure><p><code>:=</code>是一个赋值操作符,它表示的含义是: 如果<code>b</code>变量没有默认值就把<code>/b/a</code>赋值给它</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>b=<br>a=$&#123;b:=/b/a&#125;<br>echo $a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这里b没有定义,所以输出的是/b/a</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>b=/path/to/something<br>a=$&#123;b:=/b/a&#125;<br>echo $a<br><span class="hljs-meta prompt_">#</span><span class="language-bash">这里b定义了,所以输出的是/path/to/something</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-高级特性</title>
    <link href="/2023/12/28/python-advance-feature/"/>
    <url>/2023/12/28/python-advance-feature/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为了使编写的python代码行数更少,更简单,有时候可以使用这些高级特性.</p></blockquote><h1 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h1><p>针对<code>list</code>或<code>tuple</code>取出里面特定范围的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前三个元素L[0],L[1]和L[2]</span><br>L[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br><span class="hljs-comment"># 或</span><br>L[:<span class="hljs-number">3</span>]<br><span class="hljs-comment"># 倒数第一个</span><br>L[-<span class="hljs-number">1</span>]<br><span class="hljs-comment"># 后两个</span><br>L[-<span class="hljs-number">2</span>:]<br><span class="hljs-comment"># 倒数第二个</span><br>L[-<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>]<br><span class="hljs-comment"># 前十个数,每两个取一个</span><br>L[:<span class="hljs-number">10</span>:<span class="hljs-number">2</span>]<br><span class="hljs-comment"># 所有数,每5个取一个</span><br>L[::<span class="hljs-number">5</span>]<br><span class="hljs-comment"># tuple是一种不可变的list,同样可以切片</span><br>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)[:<span class="hljs-number">3</span>]<br><span class="hljs-comment"># 整个list</span><br>L[:]<br><span class="hljs-comment">#或</span><br>L[::]<br></code></pre></td></tr></table></figure><h1 id="迭代Iteration"><a href="#迭代Iteration" class="headerlink" title="迭代Iteration"></a>迭代Iteration</h1><blockquote><p>就是<code>for</code>循环,不过python的迭代是只要是可迭代对象,不管有没有下标,都可以迭代.</p><p>除了<code>list</code>和<code>tuple</code>还有<code>dict</code>包括<code>字符串</code>都可以迭代</p></blockquote><h2 id="判断是否未可迭代对象"><a href="#判断是否未可迭代对象" class="headerlink" title="判断是否未可迭代对象"></a>判断是否未可迭代对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>form collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="同时迭代list的下标和元素"><a href="#同时迭代list的下标和元素" class="headerlink" title="同时迭代list的下标和元素"></a>同时迭代list的下标和元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]):<br>...<span class="hljs-built_in">print</span>(index, value)<br>    <br><span class="hljs-number">0</span> a<br><span class="hljs-number">1</span> b<br><span class="hljs-number">2</span> c<br></code></pre></td></tr></table></figure><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><blockquote><p>一行代码生成<code>list</code>,或者可以理解为将一个用循环生成的列表用一行代码搞掂</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 要生成一个[1*1, 2*2, 3*3, ..., 10*10]的列表,可以用迭代来实现</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>L = []<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>...L.append(x * x)<br><br><span class="hljs-comment"># 用列表生成式一行代码就能搞掂</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]<br><span class="hljs-comment"># 后面可以跟判断</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">64</span>, <span class="hljs-number">100</span>]<br><span class="hljs-comment"># 两层循环,全排列</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[m + n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABC&#x27;</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;XYZ&#x27;</span>]<br>[<span class="hljs-string">&#x27;AX&#x27;</span>, <span class="hljs-string">&#x27;AY&#x27;</span>, <span class="hljs-string">&#x27;AZ&#x27;</span>, <span class="hljs-string">&#x27;BX&#x27;</span>, <span class="hljs-string">&#x27;BY&#x27;</span>, <span class="hljs-string">&#x27;BZ&#x27;</span>, <span class="hljs-string">&#x27;CX&#x27;</span>, <span class="hljs-string">&#x27;CY&#x27;</span>, <span class="hljs-string">&#x27;CZ&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列出当前目录下所有文件和文件夹生成列表</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os<br><span class="hljs-meta">&gt;&gt;&gt; </span>[d <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;,&#x27;</span>)]<br>[<span class="hljs-string">&#x27;.emacs.d&#x27;</span>, <span class="hljs-string">&#x27;.ssh&#x27;</span>, <span class="hljs-string">&#x27;.Trash&#x27;</span>, <span class="hljs-string">&#x27;Adlm&#x27;</span>, <span class="hljs-string">&#x27;Applications&#x27;</span>, <span class="hljs-string">&#x27;Desktop&#x27;</span>, <span class="hljs-string">&#x27;Documents&#x27;</span>, <span class="hljs-string">&#x27;Downloads&#x27;</span>, <span class="hljs-string">&#x27;Library&#x27;</span>, <span class="hljs-string">&#x27;Movies&#x27;</span>, <span class="hljs-string">&#x27;Music&#x27;</span>, <span class="hljs-string">&#x27;Pictures&#x27;</span>, <span class="hljs-string">&#x27;Public&#x27;</span>, <span class="hljs-string">&#x27;VirtualBox VMs&#x27;</span>, <span class="hljs-string">&#x27;Workspace&#x27;</span>, <span class="hljs-string">&#x27;XCode&#x27;</span>]<br><span class="hljs-comment"># 两个变量生成list</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>: <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-string">&#x27;C&#x27;</span> &#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>[k + <span class="hljs-string">&#x27;=&#x27;</span> + v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> d.items()]<br>[<span class="hljs-string">&#x27;y=B&#x27;</span>, <span class="hljs-string">&#x27;x=A&#x27;</span>, <span class="hljs-string">&#x27;z=C&#x27;</span>]<br><span class="hljs-comment"># 把一个list中的所有字符串变小写</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>L = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>, <span class="hljs-string">&#x27;IBM&#x27;</span>, <span class="hljs-string">&#x27;Apple&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[s.lower() <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> L]<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-string">&#x27;ibm&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="列表表达式与if…else"><a href="#列表表达式与if…else" class="headerlink" title="列表表达式与if…else"></a>列表表达式与if…else</h2><blockquote><p>当<code>if</code>在<code>for</code>后面时,不能加<code>else</code></p></blockquote><p>因为<code>for</code>后面要跟一个<code>单一的</code>筛选条件,否则无法筛选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><blockquote><p>当<code>if</code>在’for’前面时,一定要加<code>else</code></p></blockquote><p>因为<code>for</code>前面是表达式,一定要有<code>单一的</code>结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><h1 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h1><blockquote><p>如果要创建一个100万个元素的列表,肯定要占很大内存空间,如果我们每次访问都只是要某几个,那剩余的元素就是白白占用空间.</p><p>此时就需要<code>生成器</code>,它可以一边循环一边计算生成元素.</p></blockquote><h3 id="生成器是一个对象"><a href="#生成器是一个对象" class="headerlink" title="生成器是一个对象"></a>生成器是一个对象</h3><p>创建一个生成器,最简单就是把列表生成式的<code>[]</code>改为<code>()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>L = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>L<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>g<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x1022ef630</span>&gt;<br></code></pre></td></tr></table></figure><p>生成器保存的其实是<code>算法</code>,它不保存元素,需要调用<code>next()</code>函数生成下一个元素的值,知道最后一个,抛出<code>StopIteration</code>错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">4</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">16</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">25</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">36</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">49</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">64</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br><span class="hljs-number">81</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><h2 id="生成器是可迭代对象"><a href="#生成器是可迭代对象" class="headerlink" title="生成器是可迭代对象"></a>生成器是可迭代对象</h2><p>一般不可能一次次使用<code>next()</code>去迭代,而是用<code>for</code>循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:<br>    <span class="hljs-built_in">print</span>(n)<br>    <br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-number">9</span><br><span class="hljs-number">16</span><br><span class="hljs-number">25</span><br><span class="hljs-number">36</span><br><span class="hljs-number">49</span><br><span class="hljs-number">64</span><br><span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>比如斐波拉契数列函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):<br>    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-built_in">max</span>:<br>        <span class="hljs-built_in">print</span>(b)<br>        a, b = b, a + b<br>        n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br></code></pre></td></tr></table></figure><p>该函数实际上是定义了斐波拉契数列的算法,将其中的<code>print(b)</code>改为<code>yield b</code>它就会变成<code>生成器函数</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):<br>        n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-built_in">max</span>:<br>        <span class="hljs-keyword">yield</span> b<br>        a, b = b, a + b<br>        n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br></code></pre></td></tr></table></figure><p>当一个函数存在<code>yield</code>关键字,这个函数就会变成一个生成器函数,调用它返回一个<code>生成器对象</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>g = fib(<span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>g<br>&lt;generator <span class="hljs-built_in">object</span> fib at <span class="hljs-number">0x104feaaa0</span>&gt;<br></code></pre></td></tr></table></figure><blockquote><p>生成器函数并不是遇到<code>return</code>或<code>最后一行</code>语句就返回,而是遇到<code>yield</code>就返回,再次执行则从上次返回的<code>yield</code>语句处继续执行.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">odd</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step 1&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step 2&#x27;</span>)<br>    <span class="hljs-keyword">yield</span>(<span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;step 3&#x27;</span>)<br>    <span class="hljs-keyword">yield</span>(<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 通过next函数调用</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>o = odd()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(<span class="hljs-number">0</span>)<br>step <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(<span class="hljs-number">0</span>)<br>step <span class="hljs-number">2</span><br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(<span class="hljs-number">0</span>)<br>step <span class="hljs-number">3</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(o)<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>StopIteration<br></code></pre></td></tr></table></figure><blockquote><p>调用生成器函数会得到一个生成器对象,多次调用相同的生成器函数会创建多个<code>相互独立</code>的生成器对象</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(odd())<br>step <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(odd())<br>step <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(odd())<br>step <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>实际上上面的代码是创建了3个<code>相互独立</code>的生成器对象</p><blockquote><p>生成器函数需要设<code>退出循环的条件</code>,因为如果没有退出条件,我们不断调用,它就不断循环计算,就会产生一个无限数列出来</p><p>而生成器函数同样使用<code>for</code>循环来迭代</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> fib(<span class="hljs-number">6</span>):<br>    <span class="hljs-built_in">print</span>(n)<br></code></pre></td></tr></table></figure><blockquote><p>如果要拿到生成器函数的<code>return</code>返回值,必须捕获<code>StopIteration</code>,返回值在<code>StopIteration</code>的<code>value</code>中</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">g = fib(<span class="hljs-number">6</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        x = <span class="hljs-built_in">next</span>(g)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;g:&#x27;</span>, x)<br>    <span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Generator return value:&#x27;</span>, e.value)<br>        <span class="hljs-keyword">break</span><br>        <br>g: <span class="hljs-number">1</span><br>g: <span class="hljs-number">1</span><br>g: <span class="hljs-number">2</span><br>g: <span class="hljs-number">3</span><br>g: <span class="hljs-number">5</span><br>g: <span class="hljs-number">8</span><br>Generator <span class="hljs-keyword">return</span> value: done<br></code></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><blockquote><p>可以作用于<code>for</code>循环的数据类型有:</p><ol><li>集合数据类型: <code>list</code>,<code>tuple</code>,<code>dict</code>,<code>set</code>,<code>str</code>等</li><li>生成器<code>generator</code>: 生成器和带<code>yield</code>的生成器函数</li></ol><p>以上这些可以直接作用于<code>for</code>循环的对象都是可迭代对象<code>Iterable</code></p><p>其中<code>生成器</code>不但可以作用于<code>for</code>循环,还可以杯<code>next()</code>不断调用并返回下一个值(直到抛出<code>StopIteration</code>),这种对象被称为迭代器<code>Iterator</code></p></blockquote><p>总结下:</p><ul><li><p>可迭代对象 <code>Iterable</code>: 可以直接作用于<code>for</code>循环的对象</p></li><li><p>迭代器 <code>Iterator</code>: 不但可以作用于<code>for</code>,还可以通过<code>next()</code>计算下一个值的对象(生成器)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断是否为Iterable</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([], Iterable)<br><span class="hljs-literal">True</span><br><span class="hljs-comment"># 判断是否为Itertor</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><code>Iter()</code>函数可以把可迭代对象<code>Iteratable</code>变成迭代器<code>Iterator</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([], Iterator)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">iter</span>([]), Iterator)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><blockquote><p>python的迭代器对象<code>Iterator</code>表示的是一个数据流,<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个有效值,直到没有数据抛出<code>StopIteration</code>错误.</p><p>可以把这个数据流看成一个有序序列,但我们却不能提前知道序列的长度.</p><p><code>Iterator</code>的计算是惰性的,只有在有需要返回下一个数据时它才会计算.</p></blockquote><p>因此<code>Iterator</code>甚至可以表示一个无限大的数据流,比如全体自然数.而<code>list</code>,<code>dict</code>,<code>str</code>等这些就不可以,这也是为什么这些数据类型不是迭代器<code>Iterator</code>的原因,因为它们是有限的.</p><h2 id="for循环本质"><a href="#for循环本质" class="headerlink" title="for循环本质"></a>for循环本质</h2><p>python的for循环本质就是通过不断调用<code>next()</code>函数实现的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># for循环实际上就是把可迭代对象转换成迭代器,然后不同通过next()获取下一个值,直到StopIteration</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-comment"># 完全等价于</span><br>it = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>whild <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 获得下一个值</span><br>        x = <span class="hljs-built_in">next</span>(it)<br>        <span class="hljs-comment"># 直到StopIteration就退出循环</span><br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="迭代器小结"><a href="#迭代器小结" class="headerlink" title="迭代器小结"></a>迭代器小结</h2><blockquote><p>凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p><p>凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p><p>集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python笔记-递归函数</title>
    <link href="/2023/12/28/python-recursive-func/"/>
    <url>/2023/12/28/python-recursive-func/</url>
    
    <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><blockquote><p>在一个函数内部,调用它自身,我们就称之为递归函数(recursive function)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> n * fact(n - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这是一个很经典的递归函数:计算n的阶乘.函数的调用是通过<code>栈(stack)</code>的数据结构实现的,如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">===&gt; fact(5)<br>===&gt; 5 * fact(4)<br>===&gt; 5 * (4 * fact(3))<br>===&gt; 5 * (4 * (3 * fact(2)))<br>===&gt; 5 * (4 * (3 * (2 * fact(1))))<br>===&gt; 5 * (4 * (3 * (2 * 1)))<br>===&gt; 5 * (4 * (3 * 2))<br>===&gt; 5 * (4 * 6)<br>===&gt; 5 * 24<br>===&gt; 120<br></code></pre></td></tr></table></figure><p>每进入一个函数调用,栈就会加一层<code>栈帧</code>,每当一个函数返回,就会减少一层<code>栈帧</code>,它会一直调用到没得继续往下调后才会开始一层层返回,因为递归函数有<code>栈溢出</code>的风险,为了避免溢出,可以使用<code>尾递归</code></p><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><blockquote><p>在使用递归函数时,return语句不能包含表达式,这样编译器或解释器就可以把尾递归做优化,是递归不论多少次都只占用<code>一个栈帧</code></p><p>事实上尾递归和循环效果一样,把循环堪称以一种特殊的尾递归函数也是可以的.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 把上面的阶乘函数改成尾递归</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact_iter</span>(<span class="hljs-params">num, product</span>):<br>    <span class="hljs-keyword">if</span> num == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> product<br>    <span class="hljs-keyword">return</span> fact_iter(num - <span class="hljs-number">1</span>, num * product)<br><br><span class="hljs-comment"># 通过fact函数触发</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> fct_iter(n)<br></code></pre></td></tr></table></figure><p><code>num-1</code>和<code>num*product</code>作为参数,在函数调用前就会被计算,过程如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">===&gt; fact(5)<br>===&gt; fact_iter(5, 1)<br>===&gt; fact_iter(4, 5)<br>===&gt; fact_iter(3, 20)<br>===&gt; fact_iter(2, 60)<br>===&gt; fact_iter(1, 120)<br>===&gt; 120<br></code></pre></td></tr></table></figure><p>相当于每一次都把前面的值算出来,再进入下一轮调用,从而避免栈溢出.</p><h1 id="然而"><a href="#然而" class="headerlink" title="然而"></a>然而</h1><p>遗憾的是,Python标准解释器没有对尾递归做优化,所以任何递归函数都存在栈溢出问题,所以这个知道就好.</p>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python笔记-函数参数</title>
    <link href="/2023/12/25/python-function/"/>
    <url>/2023/12/25/python-function/</url>
    
    <content type="html"><![CDATA[<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><blockquote><p>定义默认参数，注意不要使用可变对象来定义，要使用<code>不可变对象</code>，比如str，None</p></blockquote><p>Python在函数定义时，默认参数就会被计算出来，如果默认参数指向一个可变对象，比如<code>[]</code>，每次使用默认参数调用函数时，都会使用默认参数指向的那个对象，则每一次调用，默认参数都会变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_end</span>(<span class="hljs-params">L=[]</span>):<br>    L.append(<span class="hljs-string">&#x27;END&#x27;</span>)<br>    <span class="hljs-keyword">return</span> L<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; add_end()</span><br>[&#x27;END&#x27;]<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; add_end()</span><br>[&#x27;END&#x27;, &#x27;END&#x27;]<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; add_end()</span><br>[&#x27;END&#x27;, &#x27;END&#x27;, &#x27;END&#x27;]<br></code></pre></td></tr></table></figure><p>因此，最好不要使用可变对象来定义默认参数</p><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><blockquote><p>定义参数时，加一个<code>*</code>号，表示可以接收0个或任意个参数。任意个参数将会以<code>tuple</code>的形式传递。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">*numbers</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n * n<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br></code></pre></td></tr></table></figure><blockquote><p>调用时，可以在<code>list</code>或<code>tuple</code>前加上<code>*</code>号码，就可以直接传递。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; nums = [1, 2, 3]</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cals(*nums)</span><br>14<br></code></pre></td></tr></table></figure><h1 id="可变关键字参数"><a href="#可变关键字参数" class="headerlink" title="可变关键字参数"></a>可变关键字参数</h1><blockquote><p>允许你传入0个或任意个含参数名的参数,传入时会自动在函数内部组装成一个<code>dict</code></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name&#x27;</span>, name, <span class="hljs-string">&#x27;age&#x27;</span>, age, <span class="hljs-string">&#x27;other&#x27;</span>, kw)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; extra = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="hljs-string">&#x27;Jack&#x27;</span>, 24, **extra)</span><br>name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>kw</code>获得的是<code>extra</code>这个字典的一个拷贝,函数对<code>kw</code>做的操作不会影响函数外<code>extra</code>这个对象</p></blockquote><h1 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h1><blockquote><p>限制关键字参数的名字,需要特殊分隔符<code>*</code>,定义命名关键字参数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># *号后的参数被视为吗命名关键字参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br><span class="hljs-comment"># 如果前面已经有了可变参数,则可以忽略分隔符</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *args, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, args, city, job)<br></code></pre></td></tr></table></figure><blockquote><p>命名关键字参数调用时,必须传入参数名,否则会报错</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="hljs-string">&#x27;Jack&#x27;</span>, 24, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)</span><br>Jack 24 Beijing Engineer<br></code></pre></td></tr></table></figure><h1 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h1><blockquote><p>顺序<code>必须</code>是: 必选参数 –&gt; 默认参数 –&gt; 可变参数 –&gt; 命名关键字参数 –&gt; 可变关键字参数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">a, b, c=<span class="hljs-number">0</span>, *args, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a=&#x27;</span>, a, <span class="hljs-string">&#x27;b=&#x27;</span>, b, <span class="hljs-string">&#x27;c=&#x27;</span>, c, <span class="hljs-string">&#x27;args=&#x27;</span>, args, <span class="hljs-string">&#x27;kw=&#x27;</span>, kw)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">a, b, c=<span class="hljs-number">0</span>, *, d, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a =&#x27;</span>, a, <span class="hljs-string">&#x27;b =&#x27;</span>, b, <span class="hljs-string">&#x27;c =&#x27;</span>, c, <span class="hljs-string">&#x27;d =&#x27;</span>, d, <span class="hljs-string">&#x27;kw =&#x27;</span>, kw)<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f1(1, 2, 3, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, x=99)</span><br>a = 1 b = 2 c = 3 args = (&#x27;a&#x27;, &#x27;b&#x27;) kw = &#123;&#x27;x&#x27;: 99&#125;<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f2(1, 2, d=99, ext=None)</span><br>a = 1 b = 2 c = 0 d = 99 kw = &#123;&#x27;ext&#x27;: None&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">可以直接通过tuple和dict调用</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; kw = &#123;<span class="hljs-string">&#x27;d&#x27;</span>: 99, <span class="hljs-string">&#x27;x&#x27;</span>: <span class="hljs-string">&#x27;#&#x27;</span>&#125;</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f1(*args, **kw)</span><br>a = 1 b = 2 c = 3 args = (4,) kw = &#123;&#x27;d&#x27;: 99, &#x27;x&#x27;: &#x27;#&#x27;&#125;<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f2(*args, **kw)</span><br>a = 1 b = 2 c = 3 d = 88 kw = &#123;&#x27;x&#x27;: &#x27;#&#x27;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Coder</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JenkinsFile 工作总结</title>
    <link href="/2023/10/01/jenkinsfile/"/>
    <url>/2023/10/01/jenkinsfile/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/occultagg/blog-pics/master/hexo-blog%5Clogo-title-opengraph.png" srcset="/img/loading.gif" lazyload></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="声明式vs脚本式"><a href="#声明式vs脚本式" class="headerlink" title="声明式vs脚本式"></a>声明式vs脚本式</h2><ul><li><p>脚本式流水线更依赖groovy(特别是错误检查和异常处理)，全写<code>node&#123;&#125;</code>块内。</p></li><li><p>声明式更关注实现逻辑步骤，一般都是直接写声明式。</p></li><li><p>需要理解，jenkinsfile写的是一种基于groovy开发而来的语法（DSL：领域特定语言<code>Domain-Specific Language</code>），100%兼容groovy，意味着：</p><ul><li><p>你可以直接写groovy，比如定义一个groovy函数</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> function(a)&#123;<br>    ...<br><br>&#125;<br><span class="hljs-comment">// 并在Jenkinsfile的任何地方调用它,a是要传递给函数的参数</span><br>function(a)<br></code></pre></td></tr></table></figure></li><li><p>声明式中<code>script&#123;&#125;</code>块用来处理groovy代码</p></li></ul></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一个概念，包含<code>任何可以执行jenkins任务的系统</code>，包括<code>主节点和代理节点</code>，也可以是一个容器。</p><ul><li><p>主节点</p><p>是一个jenkins实例的<code>主要控制系统</code>,它完全可以访问所有的配置选项和任务（jpb）列表,负责调度构建任务,执行管理任务,处理用户请求,更新配置等,如果没有指定其他节点,它也是默认的任务执行节点.</p></li><li><p>代理节点</p><p>早期版本的jenkins中也称作slave(从节点),连接到主节点的一台或多台机器(物理,虚拟,容器,云服务器).由主节点控制,负责执行构建和测试任务.使用从节点可以创建一个多机器的分布式构建环境,以适配不同平台或配置的环境进行构建.</p></li></ul><h3 id="执行器-Excutor"><a href="#执行器-Excutor" class="headerlink" title="执行器(Excutor)"></a>执行器(Excutor)</h3><p>一个执行器是指可以执行任务的槽位或线程.一个节点配置了多少个执行器就可以<code>并发</code>运行多少个独立的构建任务.执行器的数量可以根据节点的资源(cpu,内存)来确定.数量的设置影响jenkins的负载均衡和任务调度能力.</p><blockquote><p>Jenkins处理并发任务的机制基于Excutor模型,每个节点都可以配置一定数量的执行者,这些执行者决定了同时可以运行多少个作业.</p></blockquote><h3 id="项目-Item"><a href="#项目-Item" class="headerlink" title="项目(Item)"></a>项目(Item)</h3><p>一个持续集成&#x2F;持续部署的<code>任务或作业</code>,jenkins支持多种类型的项目,比如“Freestyle project”，“Pipeline”，“Multibranch Pipeline”等</p><h2 id="声明式结构"><a href="#声明式结构" class="headerlink" title="声明式结构"></a>声明式结构</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pipeline &#123;<br>    agent any<br>    <br>    triggers &#123; <span class="hljs-comment">// triggers用于定义触发器,比如配合cron实现定时触发</span><br>        cron(<span class="hljs-string">&#x27;H */4 * * 1-5&#x27;</span>)<br>    &#125;<br><br>    environment &#123;<br>        <span class="hljs-comment">// 定义环境变量</span><br>        MY_ENV_VAR = <span class="hljs-string">&#x27;some_value&#x27;</span><br>    &#125;<br>    <br>    parameters &#123; <span class="hljs-comment">// 定义pipeline的用户输入参数，description支持一些简单的html标签(高版本).通过`params.&lt;name&gt;`调用参数</span><br>        string(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;GREETING&#x27;</span>, <span class="hljs-attr">defaultValue:</span> <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;The greeting you want to use&#x27;</span>)<br>        booleanParam(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;INCLUDE_TIMESTAMP&#x27;</span>, <span class="hljs-attr">defaultValue:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;Include a timestamp with the greeting?&#x27;</span>)<br>        choice(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;ENVIRONMENT&#x27;</span>, <span class="hljs-attr">choices:</span> [<span class="hljs-string">&#x27;Staging&#x27;</span>, <span class="hljs-string">&#x27;QA&#x27;</span>, <span class="hljs-string">&#x27;Production&#x27;</span>], <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;The target environment&#x27;</span>)<br>        password(<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;DEPLOY_KEY&#x27;</span>, <span class="hljs-attr">defaultValue:</span> <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;The deployment key&#x27;</span>)<br>    &#125;<br><br>    stages &#123; <span class="hljs-comment">// 包含所有stage块的主块</span><br>        stage(<span class="hljs-string">&#x27;Prepare&#x27;</span>) &#123; <span class="hljs-comment">// stage定义流水线一个阶段</span><br>            steps &#123; <span class="hljs-comment">// steps块则是定义这一阶段具体要执行的操作</span><br>                <span class="hljs-comment">// 执行准备工作</span><br>                echo <span class="hljs-string">&#x27;Preparing the environment...&#x27;</span><br>                script &#123;<br>                    println <span class="hljs-string">&#x27;Hello World&#x27;</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Checkout&#x27;</span>) &#123;<br>            steps &#123;<br>                <span class="hljs-comment">// 从版本控制系统检出代码</span><br>                checkout scm<br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Build&#x27;</span>) &#123;<br>            when &#123;<br>                expression&#123;<br>                    anyOf &#123; <span class="hljs-comment">// anyOf表示或关系,allOf表示与关系,可以嵌套</span><br>                        not &#123; <span class="hljs-comment">// 加一层not块就表示非</span><br>                        params.GREETING == <span class="hljs-string">&#x27;Hello&#x27;</span><br>                        params.INCLUDE_TIMESTAMP == <span class="hljs-string">&#x27;false&#x27;</span><br>                        &#125;<br>                &#125;<br>                &#125;<br>            &#125;<br>            steps &#123;<br>                <span class="hljs-comment">// 执行构建</span><br>                echo <span class="hljs-string">&#x27;Building...&#x27;</span><br>                script &#123;<br>                    <span class="hljs-comment">// 执行脚本命令</span><br>                    env.BUILD_ID = sh(<span class="hljs-attr">returnStdout:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">script:</span> <span class="hljs-string">&#x27;date +%F_%H-%M-%S&#x27;</span>).trim()<br>                    echo <span class="hljs-string">&quot;Build ID: $&#123;env.BUILD_ID&#125;&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Test&#x27;</span>) &#123;<br>            steps &#123;<br>                <span class="hljs-comment">// 运行测试</span><br>                echo <span class="hljs-string">&#x27;Testing...&#x27;</span><br>                script &#123;<br>                    currentBuild.result = <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <span class="hljs-comment">// currentBuild是Pipeline插件提供的一个全局变量,这个变量指向一个RunWrapper类的实例,其中有result属性用于表示构建的状态(结果)</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;Deploy&#x27;</span>) &#123;<br>            when &#123; <span class="hljs-comment">// 有条件地执行stage</span><br>                expression &#123;<br>                    currentBuild.result == <span class="hljs-string">&#x27;SUCCESS&#x27;</span> <br>                &#125;<br>            &#125;<br>            steps &#123;<br>                <span class="hljs-comment">// 部署到服务器</span><br>                echo <span class="hljs-string">&#x27;Deploying...&#x27;</span><br>            &#125;<br>        &#125;<br>        <br>        stage(<span class="hljs-string">&#x27;Parallel Stage&#x27;</span>) &#123;<br>            steps &#123;<br>                script &#123;<br>                    parallel( <span class="hljs-comment">// 并发执行,注意格式</span><br>                        <span class="hljs-symbol">stage1:</span> &#123; <span class="hljs-comment">// 这里的stage1和下面的stage2都是标识符,用来区分,没有其他特别的含义,可以自定义其他名字</span><br>                            echo <span class="hljs-string">&#x27;Running stage 1&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-symbol">stage2:</span> &#123;<br>                            echo <span class="hljs-string">&#x27;Running stage 2&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-symbol">failFast:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// 可选参数,true表示任一并发阶段失败,则整个parallel都会失败</span><br>                    )<br>                &#125;<br>            &#125;<br>    &#125;<br>    &#125;<br><br>    post &#123;<br>        <span class="hljs-comment">// 构建后的操作</span><br>        always &#123;<br>            echo <span class="hljs-string">&#x27;This will always run&#x27;</span><br>        &#125;<br>        success &#123;<br>            echo <span class="hljs-string">&#x27;Build was successful!&#x27;</span><br>        &#125;<br>        failure &#123;<br>            echo <span class="hljs-string">&#x27;Build failed.&#x27;</span><br>        &#125;<br>        unstable &#123;<br>            echo <span class="hljs-string">&#x27;Build is unstable.&#x27;</span><br>        &#125;<br>        cleanup &#123;<br>            <span class="hljs-comment">// 清理后续操作</span><br>            echo <span class="hljs-string">&#x27;Performing cleanup steps&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>使用docker部署个一主一从Jenkins</p><ol><li><p>创建master镜像</p><p>这是官方文档给的例子,包含blue-ocean插件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> jenkins/jenkins:<span class="hljs-number">2.426</span>.<span class="hljs-number">3</span>-jdk17<br><span class="hljs-keyword">USER</span> root<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y lsb-release</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl -fsSLo /usr/share/keyrings/docker-archive-keyring.asc \</span><br><span class="language-bash">  https://download.docker.com/linux/debian/gpg</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> \</span></span><br><span class="hljs-string"><span class="language-bash">  signed-by=/usr/share/keyrings/docker-archive-keyring.asc] \</span></span><br><span class="hljs-string"><span class="language-bash">  https://download.docker.com/linux/debian \</span></span><br><span class="hljs-string"><span class="language-bash">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> &gt; /etc/apt/sources.list.d/docker.list</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y docker-ce-cli</span><br><span class="hljs-keyword">USER</span> jenkins<br><span class="hljs-keyword">RUN</span><span class="language-bash"> jenkins-plugin-cli --plugins <span class="hljs-string">&quot;blueocean docker-workflow&quot;</span></span><br></code></pre></td></tr></table></figure></li><li><p>启动master</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t myjenkins-blueocean:2.426.3-1<br>docker network create jenkins<br>docker run --name jenkins-blueocean --restart=on-failure --detach \<br>--network jenkins --env DOCKER_HOST=tcp://docker:2376 \<br>--env DOCKER_CERT_PATH=/certs/client --env DOCKER_TLS_VERIFY=1 \<br>--publish 8080:8080 --publish 50000:50000 \<br>--volume jenkins-data:/var/jenkins_home \<br>--volume jenkins-docker-certs:/certs/client:ro \<br>myjenkins-blueocean:2.426.3-1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取token用于首次登录</span><br>docker logs -f jenkins-blueocean<br></code></pre></td></tr></table></figure></li><li><p>添加slave节点</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240326203656002.png" srcset="/img/loading.gif" lazyload alt="image-20240326203656002"></p></li></ol><p>​<img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240326203717691.png" srcset="/img/loading.gif" lazyload alt="image-20240326203717691"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240326203741886.png" srcset="/img/loading.gif" lazyload alt="image-20240326203741886"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240326203840196.png" srcset="/img/loading.gif" lazyload alt="image-20240326203840196"></p><p>启动方式选择<code>java代理</code></p><p>创建节点后,点解节点的配置,就能看到启动jenkins-agent的命令,记下里面的<code>secret</code>参数</p><ol start="4"><li><p>创建slave镜像</p><p>实际上任何一个可以运行jenkins.jar的环境都可以是jenkins的节点,如果是裸机,先通过主节点获取jenkins.jar,然后直接执行上一步展示出来的命令即可,我这里懒得再开一台虚拟机,所以直接docker完事.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用带有 Java 的官方基础镜像</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span>-jdk<br><br><span class="hljs-comment"># 设置 Jenkins 主节点地址，代理节点名称和代理秘密的环境变量</span><br><span class="hljs-comment"># 这些环境变量应该在运行容</span><br><span class="hljs-keyword">ENV</span> JENKINS_URL=http://<span class="hljs-number">172.18</span>.<span class="hljs-number">0.2</span>:<span class="hljs-number">8080</span> <span class="hljs-comment"># 由于是同一台机器上的两个docker镜像,所以我写的是docker网络的地址</span><br><span class="hljs-keyword">ENV</span> JENKINS_NODE_NAME=test-slave <span class="hljs-comment"># 与创建slave的时候名字一致</span><br><span class="hljs-keyword">ENV</span> JENKINS_SECRET=<span class="hljs-number">1735</span>b637d6de619d0396e3198fdc418da5e5cfd35c5cbff70f222821ce85dfdc <span class="hljs-comment"># 使用上面步骤保存下来的secret</span><br><br><span class="hljs-comment"># 设置 Jenkins 从节点的工作目录环境变量</span><br><span class="hljs-keyword">ENV</span> JENKINS_AGENT_WORKDIR=/home/jenkins/agent<br><br><span class="hljs-comment"># 添加 Jenkins 用户</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -m -d /home/jenkins -s /bin/bash jenkins &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">mkdir</span> -p /home/jenkins/agent &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chown</span> -R jenkins:jenkins /home/jenkins</span><br><br><span class="hljs-comment"># 作为用户 jenkins 操作</span><br><span class="hljs-keyword">USER</span> jenkins<br><br><span class="hljs-comment"># 将工作目录设置为 Jenkins 用户的家目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /home/jenkins</span><br><br><span class="hljs-comment"># 下载 Jenkins 代理 JAR，确保 Jenkins 主节点 URL 是可访问的</span><br><span class="hljs-comment"># 此命令需在主节点 URL 可用的情况下执行，或者手动复制 agent.jar 到工作目录下</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./agent.jar /home/jenkins/agent.jar</span><br><br><span class="hljs-comment"># 容器启动时默认执行的命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> java -jar /home/jenkins/agent.jar \</span><br><span class="language-bash">    -jnlpUrl <span class="hljs-variable">$&#123;JENKINS_URL&#125;</span>/computer/<span class="hljs-variable">$&#123;JENKINS_NODE_NAME&#125;</span>/slave-agent.jnlp \</span><br><span class="language-bash">    -secret <span class="hljs-variable">$&#123;JENKINS_SECRET&#125;</span> \</span><br><span class="language-bash">    -workDir <span class="hljs-variable">$&#123;JENKINS_AGENT_WORKDIR&#125;</span></span><br></code></pre></td></tr></table></figure></li><li><p>运行slave</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build . -t jenkins-slave:2.0.0<br>docker run --name jenkins-agent --detach \<br>--network jenkins --env JENKINS_MASTER=http://172.18.0.2:8080 \<br>--env JENKINS_AGENT_NAME=test-slave --env JENKINS_SECRET=1735b637d6de619d0396e3198fdc418da5e5cfd35c5cbff70f222821ce85dfdc \<br>--env JENKINS_AGENT_WORKDIR=/home/jenkins/agent \<br>jenkins-slave:2.0.0<br></code></pre></td></tr></table></figure><p>稍等一会,刷新下主节点,显示slave已经在线</p></li></ol><h1 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h1><blockquote><p>Jenkins的凭证都存放在JENKINS_HOME底下,里面有几个子目录:</p><ul><li><p>secrets: 加密用的密钥</p></li><li><p>credentials.xml: 系统范围的凭证</p></li><li><p>users&#x2F;<username>&#x2F;credentials.xml: 每个用户的私有凭证</p></li></ul><p>安全地管理这些目录和文件的权限</p></blockquote><h2 id="凭证的范围"><a href="#凭证的范围" class="headerlink" title="凭证的范围"></a>凭证的范围</h2><ul><li>全局:  Jenkins 实例中的所有项目可用，除非在域中做了特定的限制</li><li>系统: 只允许jenkins自身以及它的节点使用</li><li>用户: 顾名思义,只能该用户使用</li><li>folder: 只能在folder中的pipeline使用,要先创建folder再创建凭证</li></ul><h2 id="凭证域"><a href="#凭证域" class="headerlink" title="凭证域"></a>凭证域</h2><p>对凭证进行<code>逻辑分组</code>的机制.将凭证划分到不同的环境或上下文,你就可以根据凭证将要使用的地方来限制凭证的可见性和可用性.</p><blockquote><p>例如,创建不同的域来区分生产和测试环境的凭证</p></blockquote><p>每个域包含一套规则,定义凭证的可用性.jenkins总是有一个默认的<code>全局域</code>,该域没有任何规范,意味着可以被jenkins的任何东西去使用</p><blockquote><p>例如可以为域配置一组说明符,只有满足这些条件,相应域的凭证才会被提供.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240328154342393.png" srcset="/img/loading.gif" lazyload alt="image-20240328154342393"></p><p>比如上图就表示,只有jenkins的任务需要访问*.prod.example.com的时候才能用这个域的凭证</p></blockquote><h1 id="授权策略"><a href="#授权策略" class="headerlink" title="授权策略"></a>授权策略</h1><p>Jenkins对于用户的授权提供了多种策略:</p><p>路径: dashboard –&gt; 系统管理 –&gt; 全局系统配置</p><ul><li><p>任何人可以做任何事: 顾名思义</p></li><li><p>登录用户可以做任何事: 一旦用户登录就可以做任何事</p></li><li><p>安全矩阵(Matrix-based security):  </p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240326222025486.png" srcset="/img/loading.gif" lazyload alt="image-20240326222025486"></p></li><li><p>项目矩阵: 与安全矩阵类似,但是它可以针对项目授权</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/image-20240326222849457.png" srcset="/img/loading.gif" lazyload alt="image-20240326222849457"></p></li></ul><h1 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a>工作总结</h1><h2 id="凭证的处理"><a href="#凭证的处理" class="headerlink" title="凭证的处理"></a>凭证的处理</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs groovy"># withCredentials()获取凭证,指定环境变量名赋值<br>stage&#123;<br>    withCredentials([usernamPassword(<span class="hljs-attr">credentialsId:</span> <span class="hljs-string">&#x27;XXX&#x27;</span>, <span class="hljs-attr">passwordVariable:</span> <span class="hljs-string">&#x27;PASSWORD&#x27;</span>, <span class="hljs-attr">usernamVariable:</span> <span class="hljs-string">&#x27;USER&#x27;</span>)])&#123;<br>        git_account = env.USER<br>        git_password = env.PASSWORD<br>    &#125;  <br>&#125;<br><br><br># credentials()获取凭证,通过固定的环境变量名使用,可以在environment&#123;&#125;中获取<br>pipeline&#123;<br>    agent any<br>    environment &#123;<br>        BITBUCKET_COMMON_CREDS = credentials(<span class="hljs-string">&#x27;peter-cred&#x27;</span>)<br>    &#125;<br>    stages &#123;<br>        stage (<span class="hljs-string">&#x27;test&#x27;</span>) &#123;<br>            steps &#123;<br>                echo $BITBUCKET_COMMON_CREDS_USR # 固定格式&lt;env_name&gt;_[USR|PSW]<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="groovy变量-环境变量"><a href="#groovy变量-环境变量" class="headerlink" title="groovy变量&#x2F;环境变量"></a>groovy变量&#x2F;环境变量</h2><p>groovy定义的变量不可以直接在其他脚本（例如sh）中使用，可以把它转为环境变量</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs groovy">steps &#123;<br>    script &#123;<br>        <span class="hljs-keyword">def</span> curTime = <span class="hljs-keyword">new</span> Data().format(<span class="hljs-string">&#x27;yyyyMMddHHmmss&#x27;</span>)<br>        <span class="hljs-keyword">def</span> model_version = <span class="hljs-string">&#x27;abc&#x27;</span> + curTime[<span class="hljs-number">0.</span><span class="hljs-number">.7</span>]<br>        <span class="hljs-keyword">def</span> model_file = model_version + <span class="hljs-string">&#x27;.zip&#x27;</span><br>        <span class="hljs-comment">//使用脚本式将变量转为环境变量</span><br>        env.model_file = model_file<br>        sh <span class="hljs-string">&quot;echo $&#123;model_file&#125;&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="html-description"><a href="#html-description" class="headerlink" title="html description"></a>html description</h2><p>example:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:1px solid black;border-collapse: collapse;cellpadding=25&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:1px solid black;padding:5px;&quot;</span>&gt;</span>aaa<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border:1px solid black;padding:5px;&quot;</span>&gt;</span>bbb<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="工作坑点"><a href="#工作坑点" class="headerlink" title="工作坑点"></a>工作坑点</h2><ol><li>假如通过jenkins跑云资源的terraform，要注意你要操作的是不是就是你正在跑的jenkins本身，因为有些人会把操作jenkins节点资源的pepeline跑在那个jenkins上</li></ol>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JenkinsFile</tag>
      
      <tag>Devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:Istio流量管理</title>
    <link href="/2023/05/21/k8s-istio-2/"/>
    <url>/2023/05/21/k8s-istio-2/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202304170944993.png" srcset="/img/loading.gif" lazyload></p><h1 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h1><p>tetrate发行版有一个简单的istio入门教程,感觉还不错,视频+文字,中文字幕.<br> <a href="https://academy.tetrate.io/collections/zh">传送门</a>,懒得在官方文档里面跳来跳去的可以直接看这个.</p><p>本文为基于该教程作的一些记录,基于istioctl+operator的部署方式,版本为1.10.3</p><h1 id="发现选择器-Discovery-selectors"><a href="#发现选择器-Discovery-selectors" class="headerlink" title="发现选择器: Discovery selectors"></a>发现选择器: Discovery selectors</h1><p>Istio:1.10引入的新功能.</p><blockquote><p> 默认情况下,istio会watch和update集群中所有的服务,也就是所有集群中的服务都会被记录并维护在istiod的服务发现表中.</p><p>默认情况下所有envoy代理的配置方式是,他们可以到达服务网格中的每个工作负载,并接受与其相关的所有端口的流量.</p><p>例如有两个服务,foo和bar,尽管他们不需要相互通信,但是他们的端点都会被记录在对方的已发现端点列表中.</p><p>当服务数量越来越大,将不可避免地导致某程度的slow down.</p></blockquote><p>discovery selectors就是为了解决这个问题存在的,配置在mesh层,可以限制被istio观察和处理的项目数量.</p><p>同样有类似功能的还有一个叫sidecar resource的解决方案.</p><h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">列出某foo命名空间的foo工作负载的服务发现表</span><br>istioctl proxy-config endpoints deploy/foo.foo<br></code></pre></td></tr></table></figure><h3 id="开启功能"><a href="#开启功能" class="headerlink" title="开启功能"></a>开启功能</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit istiooperators.install.istio.io -n istio-system installed-state<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">install.istio.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">IstioOperator</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-system</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">istio-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">meshConfig:</span><br>    <span class="hljs-attr">discoverySelectors:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">matchLabels:</span><br>        <span class="hljs-attr">env:</span> <span class="hljs-string">test</span> <span class="hljs-comment">#只watch和update匹配这个标签的命名空间的工作负载</span><br></code></pre></td></tr></table></figure><h1 id="可观测性-遥测和日志"><a href="#可观测性-遥测和日志" class="headerlink" title="可观测性:遥测和日志"></a>可观测性:遥测和日志</h1><ul><li><p>监控: prometheus</p></li><li><p>追踪: zipkin</p></li><li><p>数据可视化: grafana</p></li></ul><blockquote><p>为了使grafana和kiali工作,需要先安装prometheus addon</p></blockquote><p>istio会生成三种类型的遥测数据:指标度量(metric), 分布式追踪, 访问日志.</p><p>envoy代理负责收集指标.</p><h2 id="Metric-指标"><a href="#Metric-指标" class="headerlink" title="Metric:指标"></a>Metric:指标</h2><p>istio基于四个黄金信号生成指标: </p><ul><li><p>延迟: 分为成功和失败请求的延迟</p></li><li><p>流量: 用于衡量系统需求,如每秒http请求数,并发会话,每秒检索量等</p></li><li><p>错误: 衡量失败请求的比率</p></li><li><p>饱和度: 衡量一个服务中最紧张的资源有多满.例如线程池利用率</p></li></ul><h2 id="代理级指标"><a href="#代理级指标" class="headerlink" title="代理级指标"></a>代理级指标</h2><p>可以从每个envoy代理实例的<code>/stats</code>查看代理级指标</p><h2 id="服务级指标"><a href="#服务级指标" class="headerlink" title="服务级指标"></a>服务级指标</h2><p>涵盖前面提到的四个黄金信号.这些指标可以让我们能够监控服务于服务之间的通讯.此外,istio还提供了一组仪表盘,我们可以根据这些指标监控服务行为.</p><p>默认情况下,istio的标准指标集会被导出到Prometheus.</p><h2 id="控制平面度量"><a href="#控制平面度量" class="headerlink" title="控制平面度量"></a>控制平面度量</h2><p>istio的控制平面也会有指标,用于监控istio的控制平面,[指标列表](<a href="https://istio.io/latest/docs/reference/commands/pilot-discovery/#metrics">Istio &#x2F; pilot-discovery</a>).</p><p>包括: 入站&#x2F;出站监听器的数量,没有实例的集群数量,被拒绝或被忽略的配置等指标</p><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用安装包的示例配置文件安装</span><br>kubectl apply -f samples/addons/prometheus.yaml<br><span class="hljs-meta prompt_">#</span><span class="language-bash">打开dashboard,默认监听locahost</span><br>istioctl dashboard prometheus --address 11.0.1.121<br><span class="hljs-meta prompt_">#</span><span class="language-bash">暴露先前创建的deployment my-nginx并请求</span><br>kubectl expose deployment my-nginx  --port 80 --target-port 80 --name my-nginx-svc --type=ClusterIP<br>curl http://&lt;cluster-ip&gt;<br></code></pre></td></tr></table></figure><p>然后在prometheus的dashboard中搜索<code>istio_requests_total</code>就能看到刚刚的请求产生了1个请求数</p><h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用安装包的示例配置文件安装</span><br>kubectl apply -f samples/addons/grafana.yaml<br><span class="hljs-meta prompt_">#</span><span class="language-bash">打开dashboard,默认监听locahost</span><br>istioctl dashboard grafana --address 11.0.1.121<br></code></pre></td></tr></table></figure><p>注意: 这里的配置不建议在生产中运行,因为它没有经过性能和安全方面的调整</p><p>默认已经在grafna配置了一些仪表盘:</p><ul><li><p>istio控制平面仪表盘:control plane dashboard,展示控制平面的资源使用情况(mem,cpu,disk,go goutines),以及ilot,envoy和webhook信息.</p></li><li><p>网格仪表盘: mesh dashboard,提供网格中运行的所有服务的概览,包括全局请求数,成功率以及错误响应数.</p></li><li><p>性能仪表盘: performence,展示istio主要组件在稳定负载下的资源利用率</p></li><li><p>服务仪表盘: service,展示网格中的服务的细节,比如请求量,成功率,持续时间,以及显示按来源和响应代码,持续时间和大小的传入请求的详细图表</p></li><li><p>wash扩展: wash extension:显示于webassembly模块有关的指标,通过这个仪表盘,我们可以监控活动的和创建的wash虚拟机和获取删除wash模块和代理资源使用的数据.</p></li><li><p>istio工作负载: workload:关于工作负载的指标</p></li></ul><h2 id="分布式追踪"><a href="#分布式追踪" class="headerlink" title="分布式追踪"></a>分布式追踪</h2><p>是一种检测微服务apps的方法.</p><blockquote><p>当一个请求进入服务网格时,Envoy都会生成一个唯一的请求ID和追踪信息,并存储在http请求头中,任何apps都可以将这些header转发给它缩调用的其他服务,这样就可以在震哥哥系统中创建一个完整的追踪.</p></blockquote><h3 id="span"><a href="#span" class="headerlink" title="span"></a>span</h3><p>分布式追踪是一个<code>跨度(span)</code>的集合.</p><blockquote><p>每当有请求流经不同的系统组件时,每个组件都会产生一个跨度.每个跨度包含:</p><ul><li><p>一个名称</p></li><li><p>一组&lt;标签tag&gt;:&lt;日志log&gt;的键值对</p></li><li><p>以及一个span context,跨度上下文</p></li></ul></blockquote><p>单个跨度,识别跨度,父跨度和追踪ID的上下文头一起被发送到一个叫做采集器的组件,采集器负责对数据进行验证,索引和存储.</p><p>当请求流经Envoy代理时,Envoy代理会自动生成各个跨度.但是,envoy只能在边缘收集跨度,任何如果需要的额外的跨度,由我们的app需要负责生成.</p><p>我们的app还要确保我们在调用其他服务时转发追踪header.这样,各个跨度才能正确地关联到一个单一的追踪中.</p><h3 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h3><blockquote><p><a href="https://zipkin.io/">Zipkin</a>是一款开源的分布式实时数据追踪系统（Distributed Tracking System），基于 Google Dapper的论文设计而来，由 Twitter 公司开发贡献。其主要功能是聚集来自各个异构系统的实时监控数据。分布式跟踪系统还有其他比较成熟的实现，例如：Naver的Pinpoint、Apache的HTrace、阿里的鹰眼Tracing、京东的Hydra、新浪的Watchman，美团点评的CAT，skywalking等。</p></blockquote><p>上面说到,为了让我们的服务参与分布式追踪,我们需要在进行任何下游服务调用时传播http header.</p><p>但是尽管所有请求都经过istio sidecar,istio没有办法将出站和入站请求关联起来,而zipkin可以利用在服务之间传播的header,将这些请求拼接起来,形成完整的追踪.</p><p>istio依赖B3跟踪头(以x-b3开头的header)和envoy生成的请求id(x-request-id),通常做法是我们的应用程序需要捕获传入请求的以下header并将他们包含在所有从你的app发送出去的请求中:</p><ul><li><p>x-request-id</p></li><li><p>x-b3-traceid</p></li><li><p>x-b3-spanid</p></li><li><p>x-b3-parentspanid</p></li><li><p>x-b3-sampled</p></li><li><p>x-b3-flags</p></li><li><p>b3</p></li><li><p>如果使用lightstep,还需要转发x-ot-span-context</p></li></ul><p>zipkin的安装运行方式于上面的addon类似,在samples&#x2F;addons&#x2F;extras中有示例配置yaml文件.</p><h3 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h3><p>也是一个分布式追踪平台,它与zipkin的对比可以看看这篇文章: <a href="https://www.kubernetes.org.cn/8611.html">Jaeger与Zipkin：分布式跟踪平台该选谁_Kubernetes中文社区</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply - samples/addons/jaeger.yaml<br>istioctl dashboard jaeger --address 11.0.1.121<br></code></pre></td></tr></table></figure><h2 id="Kiali"><a href="#Kiali" class="headerlink" title="Kiali"></a>Kiali</h2><p><a href="https://kiali.io/">Kiali</a>是一个基于istio的service mesh管理控制台.提供dashboard,可视化,允许我们通过web界面配置,验证,操作网格.它通过推断流量拓扑来显示服务网格,并显示网格的健康状况.</p><p>它提供强大的验证,详细的指标,grafana访问,以及于jaeger的分布式追踪的强大集成.</p><p>安装部署与上面其他addon类似,示例配置文件在&#x2F;spamles&#x2F;addon&#x2F;kiali.yaml</p><p>如果遇到报错:<code>unable to recognize &quot;samples/addons/kiali.yaml&quot;: no matches for kind &quot;MonitoringDashboard&quot; in version &quot;monitoring.kiali.io/v1alpha1&quot;</code>,重新执行一次apply即可,原因是在安装CRD(自定义资源定义)和该CRD定义的资源时,会存在一个匹配条件.</p><h1 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h1><p>在<a href="https://anthing.cn/2023/03/21/k8s-istio/#%E5%AE%9E%E9%AA%8C">k8s进阶:Istio - Any &amp; Nothing</a> 一文中我们已经根据官方文档操作了一遍流量管理的功能,这里再进行一些复习或查漏补缺.</p><h2 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h2><p>默认安装了两个gateway: ingressgateway和engressgateway</p><p>入口网关接受入站连接,出口网关接受从集群出去的连接.网关都运行一个envoy代理,他们再网格的边缘作为负载均衡器运行.</p><p>默认使用的是loadbalance类型的svc,私有环境没有外置的负载均衡器可以通过以下方式获取它的nodeIP和nodePort:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="hljs-string">&#x27;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&#x27;</span>)<br><span class="hljs-built_in">export</span> SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=<span class="hljs-string">&#x27;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&#x27;</span>)<br><span class="hljs-built_in">export</span> INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath=<span class="hljs-string">&#x27;&#123;.items[0].status.hostIP&#125;&#x27;</span>)<br><span class="hljs-built_in">export</span> GATEWAY_URL=<span class="hljs-variable">$INGRESS_HOST</span>:<span class="hljs-variable">$INGRESS_PORT</span><br><span class="hljs-comment">#这就是你的gateway访问地址</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$GATEWAY_URL</span>&quot;</span><br></code></pre></td></tr></table></figure><p>有了网关,我们还需要配置网关资源(Gateway)来配置网关.</p><blockquote><p>这两个东西叫法上容易叫混:</p><ul><li><p>网关,ingressgateway和engressgateway部署在网格边缘,可以叫做<code>网关控制器</code>或者叫<code>网关代理</code></p></li><li><p>网关资源,Gateway,是用来配置网关控制器的,也可以叫<code>网关配置</code></p></li></ul></blockquote><p>下面是一个例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-gateway</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">istio:</span> <span class="hljs-string">ingressgateway</span> <span class="hljs-comment"># use istio default controller</span><br>  <span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br>    <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">dev.example.com</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">test.example.com</span>   <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-comment">#支持通配符</span><br></code></pre></td></tr></table></figure><p>网关控制器部署时默认有个istio&#x3D;ingressgateway的标签,网关配置根据这个标签来选择它使用的网关控制器.</p><p>hosts是一个过滤器,只有以符合它配置规则为目的地的流量才能允许通过.</p><h1 id="简单路由"><a href="#简单路由" class="headerlink" title="简单路由"></a>简单路由</h1><h2 id="virtual-service"><a href="#virtual-service" class="headerlink" title="virtual service"></a>virtual service</h2><p>使用virtual service实现路由,通过virtual service我们可以定义流量路由规则,并在客户端连接服务时应用这些规则.例如上一篇文章配置的将流量路由到不同version的pod.下面再举一个例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">customers-route</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">customers.default.svc.cluster.local</span><br>  <span class="hljs-attr">gateway:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">my-gateway</span><br>  <span class="hljs-attr">http:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">customers-v1-route</span><br>    <span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span> <br>        <span class="hljs-attr">host:</span> <span class="hljs-string">customers.default.svc.cluster.local</span><br>        <span class="hljs-attr">subset:</span> <span class="hljs-string">v1</span><br>      <span class="hljs-attr">weight:</span> <span class="hljs-number">70</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">customers-v2-route</span><br>    <span class="hljs-attr">route:</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">customers.default.svc.cluster.local</span><br>        <span class="hljs-attr">subset:</span> <span class="hljs-string">v2</span><br>      <span class="hljs-attr">weight:</span> <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>在这个例子中,我们定义流量发送到customers.default.svc.cluster.local这个kubernetes的SVC,这个SVC下绑定了两个版本的pod,通过virtual service定义70%流量去到v1,30%去到v2.</p><p>http是一个包含http流量的路由规则的有序列表.</p><p>destination是指服务注册表中的一个服务,也是路由规则处理后请求将被发送的目的地.istio的服务注册表上记录的都是合法值,也包括通过serviceEntry手动添加的合法服务.</p><p>gateway字段则用来绑定对应的网关资源,有点类似ingressclass和ingress的关系</p><h2 id="virtual-service和gateway的hosts匹配关系"><a href="#virtual-service和gateway的hosts匹配关系" class="headerlink" title="virtual service和gateway的hosts匹配关系"></a>virtual service和gateway的hosts匹配关系</h2><table><thead><tr><th>gateway hosts</th><th>virtualservice hosts</th><th>action</th></tr></thead><tbody><tr><td>*</td><td>customers.default.svc.cluster.local</td><td>流量会直接通过virtual service发送到目的地customers,因为gateway允许了所有</td></tr><tr><td>customers.default.svc.cluster.local</td><td>customers.default.svc.cluster.local</td><td>host匹配,流量将被发送</td></tr><tr><td>hello.com</td><td>customers.default.svc.cluster.local</td><td>hosts不匹配,无效</td></tr><tr><td>hello.com</td><td>[“hello.com”, “customers.default.svc.cluster.local”]</td><td>只会允许hello.com,这依然是一个有效配置,因为virtual service可以连接到第二个网关,该网关的hosts包含*.default.svc.cluster.local即可</td></tr></tbody></table><h2 id="subset-和-destination-rule"><a href="#subset-和-destination-rule" class="headerlink" title="subset 和 destination rule"></a>subset 和 destination rule</h2><p>目的地指的是不同子集(subset)或服务版本.通过subset,我们可以识别应用程序的不同变体.比如version1和version2.对应于我们对应服务的两个不同版本.</p><p>每个子集都使用label去确定那些pod包含在子集中.</p><p>subset在destination rule中声明,这里前文就有例子.</p><p>另外destination rule还可以配置流量策略.</p><h3 id="destination-rule的流量策略"><a href="#destination-rule的流量策略" class="headerlink" title="destination rule的流量策略"></a>destination rule的流量策略</h3><h4 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">customer-destination</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">customers.default.svc.cluster.local</span><br>  <span class="hljs-attr">trafficPolicy:</span><br>    <span class="hljs-attr">loadBalancer:</span><br>      <span class="hljs-attr">simple:</span> <span class="hljs-string">ROUND_ROBIN</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span><br></code></pre></td></tr></table></figure><p>还可以基于哈希的负载均衡,并基于http头,cookies或其他请求属性实现亲和性,例如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">trafficPolicy:</span><br>  <span class="hljs-attr">loadBalancer:</span><br>    <span class="hljs-attr">consistentHash:</span> <span class="hljs-comment">#基于hash的负载均衡</span><br>      <span class="hljs-attr">httpCookie:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">location</span> <span class="hljs-comment">#使用cookie中的location实现会话亲和</span><br>        <span class="hljs-attr">ttl:</span> <span class="hljs-string">4s</span><br></code></pre></td></tr></table></figure><h4 id="连接池配置"><a href="#连接池配置" class="headerlink" title="连接池配置"></a>连接池配置</h4><p>应用于上游服务的每个主机,用它来控制连接量:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">myredissrv.prod.svc.cluster.local</span><br>  <span class="hljs-attr">trafficPolicy:</span><br>    <span class="hljs-attr">connectionPool:</span><br>      <span class="hljs-attr">http:</span><br>        <span class="hljs-attr">http2MaxRequests:</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h4 id="异常点检测-断路器-熔断"><a href="#异常点检测-断路器-熔断" class="headerlink" title="异常点检测&#x2F;断路器&#x2F;熔断"></a>异常点检测&#x2F;断路器&#x2F;熔断</h4><p>跟踪<code>上游</code>服务中每个主机(pod)的状态,如果一个主机开始返回错误,它就会在预定的时间内被负载均衡池中弹出.</p><p>对于TCP服务,envoy将连接超时或失败计算判定为错误.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">trafficPolicy:</span><br>  <span class="hljs-attr">connectionPool:</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">http2MaxRequests:</span> <span class="hljs-number">500</span> <span class="hljs-comment">#限制500并发http2请求</span><br>      <span class="hljs-attr">maxRequestsPerConnection:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#每个连接不超过10个请求</span><br>  <span class="hljs-attr">outlierDetection:</span><br>    <span class="hljs-attr">interval:</span> <span class="hljs-string">5m</span> <span class="hljs-comment">#每5分钟扫描一次上游主机(pod)</span><br>    <span class="hljs-attr">consecutiveError:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#如果任何一个主机连续失败10次</span><br>    <span class="hljs-attr">bashEjectionTime:</span> <span class="hljs-string">10m</span> <span class="hljs-comment">#就把它弹出10分钟</span><br></code></pre></td></tr></table></figure><h4 id="客户端TLS设置"><a href="#客户端TLS设置" class="headerlink" title="客户端TLS设置"></a>客户端TLS设置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">trafficPolicy:</span><br>  <span class="hljs-attr">tls:</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">MUTUAL</span> <span class="hljs-comment">#mTLS</span><br>    <span class="hljs-attr">clientCertificate:</span> <span class="hljs-string">/etc/certs/cert.pem</span><br>    <span class="hljs-attr">privateKey:</span> <span class="hljs-string">/etc/certs/key.pem</span><br>    <span class="hljs-attr">caCertificates:</span> <span class="hljs-string">/etc/certs/ca.pem</span><br></code></pre></td></tr></table></figure><p>其他支持的TLS模式有:</p><ul><li><p>DISABLE: 没有TLS连接</p></li><li><p>SIMPLE: 在上游端点发起TLS连接</p></li><li><p>ISTIO_MUTUAL: 类似MUTUAL但使用的istio的mTLS证书</p></li></ul><h4 id="端口流量策略"><a href="#端口流量策略" class="headerlink" title="端口流量策略"></a>端口流量策略</h4><p>可以根据不同的端口配置不同的流量策略</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">trafficPolicy:</span><br>  <span class="hljs-attr">portLevelSettings:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">loadBanlancer:</span><br>      <span class="hljs-attr">simple:</span> <span class="hljs-string">LEAST_CONN</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">8000</span><br>    <span class="hljs-attr">loadBalancer:</span><br>      <span class="hljs-attr">simple:</span> <span class="hljs-string">ROUND_ROBIN</span><br></code></pre></td></tr></table></figure><h1 id="弹性-Resiliency"><a href="#弹性-Resiliency" class="headerlink" title="弹性:Resiliency"></a>弹性:Resiliency</h1><p>弹性的目的是故障发生后将服务恢复到一个完全正常的状态.也就是failover.</p><p>服务的可用关键是在提出服务请求时使用超时(timeout)和重试(retry)策略.可以在istio的virtual service上配置这两者.下面是两个例子.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">...</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span> <span class="hljs-string">customers.default.svc.cluster.local</span><br>      <span class="hljs-attr">host:</span> <br>      <span class="hljs-attr">subset:</span> <span class="hljs-string">v1</span><br>   <span class="hljs-attr">timeout:</span> <span class="hljs-string">10s</span> <span class="hljs-comment">#设置10s超时</span><br><span class="hljs-string">...</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">route:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>      <span class="hljs-attr">host:</span> <br>      <span class="hljs-attr">subset:</span> <span class="hljs-string">v1</span><br>  <span class="hljs-attr">retries:</span><br>    <span class="hljs-attr">attempts:</span> <span class="hljs-number">10</span> <span class="hljs-comment">#尝试次数为10</span><br>    <span class="hljs-attr">perTryTimeout:</span> <span class="hljs-string">2s</span> <span class="hljs-comment">#每次超时时间为2s</span><br>    <span class="hljs-comment">#重试任何连接超时(connect-failure)或服务不响应(reset)的失败请求</span><br>    <span class="hljs-attr">retryOn:</span> <span class="hljs-string">connect-failure,reset</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>注意: 如果同时设置超时和重试,超时值是请求等待的最长时间,比如如果我们在上面的第二个例子中设置了超时10s,那么10s一过,即使重试策略还剩下一些尝试,也会终止直接判断服务不可用.</p><blockquote><p>重试策略可以更加细化:</p><p>例如我们可以只在上游服务器返回5xx错误或者网关错误(502,503,504)时重试,或者在请求头中指定可重试的状态代码.</p><p>重试和超时都发生在客户端.</p><p>当envoy重试请求时,最初失败并导致重试的端点就不再包含在负载均衡池中,例如:</p><p>假设kubernetes有3个端点(pod),其中一个失败了,并出现了可重试的错误代码,Envoy重试请求时,将不会向原来的端点重新发送,而只发送给另外两个没有失败的端点的一个.</p></blockquote><h1 id="故障注入-failure-injection"><a href="#故障注入-failure-injection" class="headerlink" title="故障注入: failure injection"></a>故障注入: failure injection</h1>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:Ingress-Nginx</title>
    <link href="/2023/05/21/k8s-ingress/"/>
    <url>/2023/05/21/k8s-ingress/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202305210746876.png" srcset="/img/loading.gif" lazyload></p><h1 id="Ingress-Nginx-和-Nginx-Ingress"><a href="#Ingress-Nginx-和-Nginx-Ingress" class="headerlink" title="Ingress-Nginx 和 Nginx-Ingress"></a>Ingress-Nginx 和 Nginx-Ingress</h1><h2 id="Ingress-Nginx"><a href="#Ingress-Nginx" class="headerlink" title="Ingress-Nginx"></a>Ingress-Nginx</h2><p>是kubernetes社区基于nginx开发的ingress控制器</p><p>作为官方的默认控制器,享有最优的支持</p><p>补充了一组实现额外功能的lua插件</p><p><a href="https://github.com/kubernetes/ingress-nginx">Github</a></p><p><a href="https://kubernetes.github.io/ingress-nginx/deploy/">说明文档</a></p><h2 id="Nginx-ingress"><a href="#Nginx-ingress" class="headerlink" title="Nginx-ingress"></a>Nginx-ingress</h2><p>nginx官方开发的ingress控制器</p><p>很高的稳定性和持续的向后兼容,没有任何第三方模块,消除了lua代码保证较高的速度</p><p><a href="https://github.com/nginxinc/kubernetes-ingress">Github</a></p><p><a href="https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-manifests/">说明文档</a></p><p><a href="https://www.cnblogs.com/leozhanggg/p/13603215.html">更多</a></p><p><strong>本文说的是Ingress-nginx</strong></p><h1 id="Ingress-nginx"><a href="#Ingress-nginx" class="headerlink" title="Ingress-nginx"></a>Ingress-nginx</h1><p>service提供四层基于tcp&#x2F;ip的代理,负载均衡和转发,ingress则提供七层的代理,负载均衡和转发,请求进入kubernetes集群会首先通过ingress-controller,匹配配置的ingress路径规则,转发到具体的service,再转发到具体的pod上.</p><h2 id="ingress和ingress-controller"><a href="#ingress和ingress-controller" class="headerlink" title="ingress和ingress-controller"></a>ingress和ingress-controller</h2><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><blockquote><p> 是k8s的一种资源对象,通过http&#x2F;https暴露集群内部service,给service提供外部URL,loadbalance或基于vhost的代理.</p></blockquote><h3 id="ingress-controller"><a href="#ingress-controller" class="headerlink" title="ingress-controller"></a>ingress-controller</h3><blockquote><p> 并不是k8s自带的组件,ingress-controller是一个统称,有各种各样的controller,本文说的-ingress-nginx是kubernetes社区指定的控制器,所以支持也是最好.</p></blockquote><p>不管那种ingress-controller,实现的机制基本一样,只是配置有区别.</p><p>一般来说,ingress-controller的形式是一个pod,里面跑daemon程序或反向代理程序.</p><ul><li>daemon负责不断监控集群的变化,根据ingress生成配置并应到新配置到反向代理.</li></ul><p>比如ingress-nginx就是动态生成nginx配置,动态生成upstream,并在需要的时候冲i性能加载应用新配置.</p><h2 id="三种部署方式"><a href="#三种部署方式" class="headerlink" title="三种部署方式"></a>三种部署方式</h2><h2 id="1-Deployment-LoadBalance-svc"><a href="#1-Deployment-LoadBalance-svc" class="headerlink" title="1. Deployment+LoadBalance-svc"></a>1. Deployment+LoadBalance-svc</h2><p>以deployment的方式部署controller,再跑LB类型的是svc,这种方式适合部署在公有云,或者paas平台(比如openstack).</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202305210741133.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>一般来说,公有云会为LB类型的svc创建一个负载均衡器,还会绑定一个公网地址,只要解析域名到这个公网地址,就可以实现服务的对外暴露.</p></blockquote><h2 id="2-Deployment-NodePort-svc"><a href="#2-Deployment-NodePort-svc" class="headerlink" title="2. Deployment+NodePort-svc"></a>2. Deployment+NodePort-svc</h2><p>同样deployment方式部署controller,但是svc采用NodePort,svc会在每个node上监听一个端口,此时需要在集群前部部署一个负载均衡器</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202305210741204.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>实际上nodePort本身是一层转发,所以这种方式转发层数比其他方式都多,大流量访问时可能会产生性能问题</p><p>默认nodeport不能使用80&#x2F;443,那么请求节点看上去就不太专业</p></blockquote><h2 id="3-DaemonSet-HostNetwork-NodeSelector"><a href="#3-DaemonSet-HostNetwork-NodeSelector" class="headerlink" title="3. DaemonSet+HostNetwork+NodeSelector"></a>3. DaemonSet+HostNetwork+NodeSelector</h2><p>使用DaemonSet结合NodeSelecter部署controller,同时使用hostnetwork让controller共享宿主机的网络名称空间,此时直接使用宿主机的80&#x2F;443就能访问服务,controller所在的宿主机就是流量入口.</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202305210742905.png" srcset="/img/loading.gif" lazyload></p><blockquote><p>这种方式链路最简单,少了一层nodeport的转发性能更好.</p><p>直接使用宿主机的网络命名空间,一个node只能部署一个controller.</p><p>生产中一般都会部署多台node作为controller,前面再加个负载均衡器.</p></blockquote><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>生产中常用的方式为DaemonSet+HostNetwork+NodeSelecter,本文也将以这种方式记录部署步骤.</p><h2 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h2><p>ingress-nginx: v1.0.0 支持k8s: v1.19+,本文也是使用该版本</p><p>k8s: v1.22+需要使用更高版本的ingress-nginx</p><h2 id="下载yaml"><a href="#下载yaml" class="headerlink" title="下载yaml"></a>下载yaml</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.0/deploy/static/provider/baremetal/deploy.yaml<br></code></pre></td></tr></table></figure><h2 id="修改镜像文件"><a href="#修改镜像文件" class="headerlink" title="修改镜像文件"></a>修改镜像文件</h2><p>默认ingress-nginx的镜像使用k8s.gcr.io,由于总所周知的原因,国内大陆是下载不了的,所以需要替换docker-proxy的代理</p><ul><li><p>controller就是控制器镜像.</p><ul><li><blockquote><p>controller有一个启动参数: –watch-ingress-without-class&#x3D;true</p><p>官方解释:</p><p>    有一些 Ingress 控制器不需要定义默认的 IngressClass。比如：Ingress-NGINX 控制器可以通过参数 –watch-ingress-without-class 来配置.不过仍然推荐设置默认的 IngressClass.</p><p>(<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress | Kubernetes</a>)</p><p>所以这里其实可以不用额外加这个参数,默认的就行.</p></blockquote></li></ul></li><li><p>另外还有两个jobs:</p><ul><li><blockquote><p>在ingress-nginx的配置清单中，<code>ingress-nginx-admission-create</code> 和 <code>ingress-nginx-admission-patch</code> 这两个Job是与admission webhook相关的。Admission webhooks 是 Kubernetes API server 的动态拦截器，它们在创建、修改或删除对象之前或之后运行。ingress-nginx 使用这些webhook来确保ingress 资源在被提交给API服务器之前满足特定的验证条件。</p><h2 id="ingress-nginx-admission-create"><a href="#ingress-nginx-admission-create" class="headerlink" title="ingress-nginx-admission-create"></a>ingress-nginx-admission-create</h2><p>这个 Job 负责创建一个admission webhook的证书和一个对应的 Kubernetes Secret。这些证书是用来加密admission webhook服务与Kubernetes API服务器之间传输的数据的。</p><h2 id="ingress-nginx-admission-patch"><a href="#ingress-nginx-admission-patch" class="headerlink" title="ingress-nginx-admission-patch"></a>ingress-nginx-admission-patch</h2><p>而这个 Job 负责两件事：</p><ol><li>将刚刚生成的证书更新到admission webhook的配置中。</li><li>更新ingress-nginx部署的配置，使得当API服务器调用admission webhook时，使用正确的证书进行通信。</li></ol><p>这两个Job确保了admission webhook 的安全交互，并且是自动化的，通常在你部署或升级ingress-nginx 时会一同执行。成功执行完这两个 Job 后，你的ingress-nginx controller 就能够安全有效地拦截和管理发送到 API 服务器的 ingress 资源请求了。</p></blockquote></li></ul></li></ul><h2 id="给node打label"><a href="#给node打label" class="headerlink" title="给node打label"></a>给node打label</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl label node &lt;node-name&gt; &lt;key=value&gt;<br></code></pre></td></tr></table></figure><h2 id="修改yaml"><a href="#修改yaml" class="headerlink" title="修改yaml"></a>修改yaml</h2><ol><li><p>deployment改为daemonset</p></li><li><p>添加hostnetwork: true</p></li><li><p>根据标签配置nodeSelector</p></li></ol><p>参考:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span> <span class="hljs-comment">#修改</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">helm.sh/chart:</span> <span class="hljs-string">ingress-nginx-4.0.1</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/instance:</span> <span class="hljs-string">ingress-nginx</span><br>    <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br>    <span class="hljs-attr">app.kubernetes.io/managed-by:</span> <span class="hljs-string">Helm</span><br>    <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">controller</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-nginx-controller</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ingress-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">app.kubernetes.io/instance:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">controller</span><br>  <span class="hljs-attr">revisionHistoryLimit:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">ingress-nginx</span><br>        <span class="hljs-attr">app.kubernetes.io/instance:</span> <span class="hljs-string">ingress-nginx</span><br>        <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">controller</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">controller</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">willdockerhub/ingress-nginx-controller:v1.0.0</span><br>          <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>          <span class="hljs-attr">lifecycle:</span><br>            <span class="hljs-attr">preStop:</span><br>              <span class="hljs-attr">exec:</span><br>                <span class="hljs-attr">command:</span><br>                  <span class="hljs-bullet">-</span> <span class="hljs-string">/wait-shutdown</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/nginx-ingress-controller</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--election-id=ingress-controller-leader</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--controller-class=k8s.io/ingress-nginx</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--configmap=$(POD_NAMESPACE)/ingress-nginx-controller</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--validating-webhook=:8443</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--validating-webhook-certificate=/usr/local/certificates/cert</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--validating-webhook-key=/usr/local/certificates/key</span><br>          <span class="hljs-attr">securityContext:</span><br>            <span class="hljs-attr">capabilities:</span><br>              <span class="hljs-attr">drop:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span><br>              <span class="hljs-attr">add:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">NET_BIND_SERVICE</span><br>            <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">101</span><br>            <span class="hljs-attr">allowPrivilegeEscalation:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAME</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">POD_NAMESPACE</span><br>              <span class="hljs-attr">valueFrom:</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">LD_PRELOAD</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">/usr/local/lib/libmimalloc.so</span><br>          <span class="hljs-attr">livenessProbe:</span><br>            <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">5</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">10254</span><br>              <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>            <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>          <span class="hljs-attr">readinessProbe:</span><br>            <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">httpGet:</span><br>              <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>              <span class="hljs-attr">port:</span> <span class="hljs-number">10254</span><br>              <span class="hljs-attr">scheme:</span> <span class="hljs-string">HTTP</span><br>            <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>            <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><br>            <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">1</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>              <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">443</span><br>              <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webhook</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8443</span><br>              <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webhook-cert</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/local/certificates/</span><br>              <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">90Mi</span><br>      <span class="hljs-attr">nodeSelector:</span> <span class="hljs-comment">#修改</span><br>        <span class="hljs-attr">ingress:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#修改</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">ingress-nginx</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">300</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webhook-cert</span><br>          <span class="hljs-attr">secret:</span><br>            <span class="hljs-attr">secretName:</span> <span class="hljs-string">ingress-nginx-admission</span><br></code></pre></td></tr></table></figure><h2 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f deploy.yaml<br></code></pre></td></tr></table></figure><h2 id="Check"><a href="#Check" class="headerlink" title="Check"></a>Check</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get all -n ingress-nginx<br></code></pre></td></tr></table></figure><h2 id="部署pod和ingress验证"><a href="#部署pod和ingress验证" class="headerlink" title="部署pod和ingress验证"></a>部署pod和ingress验证</h2><p>可以参考这个blog进行验证</p><p><a href="https://ealenn.github.io/Echo-Server/pages/quick-start/kubernetes.html">echo-server</a></p><p>创建完后稍等片刻,ingress就会分配到指定node的ip,用任意一个node的ip和80端口就能访问到配置的echo-server.</p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>ingress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Groovy For Devops</title>
    <link href="/2023/04/22/groovy-devops/"/>
    <url>/2023/04/22/groovy-devops/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202304221610024.png" srcset="/img/loading.gif" lazyload></p><h1 id="START"><a href="#START" class="headerlink" title="START &gt;_"></a>START &gt;_</h1><p>有人说groovy是世界上最麻烦的脚本语言,还要加上一个”没有之一”,但是作为运维,经常避免不了跟jenkins打交道,写jenkins file pipeline的时候就需要用到它,我本人其实不喜欢java,groovy又是从groovy来的,不过工作需要,还是要学一学基础的语法,反正也不是太难.本文记录下来,方便以后要写的时候参考.</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>看 <a href="https://groovy.apache.org/download.html">官网</a></p><h1 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h1><p>首先在IDE(vs code) 写个Hello World.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 这是注释</span><br>        <span class="hljs-comment">/*这是多行注释*/</span><br>        println <span class="hljs-string">&#x27;Hello World&#x27;</span><br>        println <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">groovy hello.groovy<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello World<br>Hello World<br></code></pre></td></tr></table></figure><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p><code>def</code>是groovy中用来定义<code>标识符</code>的关键字,<code>标识符</code>被用来定义变量,函数或其他用户定义的变量,标识符以字母,$或_开头,不能以数字开头,例如:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> abc<br><span class="hljs-keyword">def</span> $abc<br><span class="hljs-keyword">def</span> _student<br></code></pre></td></tr></table></figure><p>举个🌰:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        String x = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        println(x);<br>        <span class="hljs-keyword">def</span> _Name = <span class="hljs-string">&quot;你好&quot;</span>;<br>        println(_Name);<br>        println <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">Hello<br>你好<br>Hello World<br></code></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>除了用<code>def</code>定义变量,也可以用一个确定的数字类型来声明一个变量,所以下面这样也可以:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        String str = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">//字符串</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">//整形</span><br>        <span class="hljs-type">long</span> y = <span class="hljs-number">100</span>L; <span class="hljs-comment">//长整形</span><br>        <span class="hljs-type">float</span> a = <span class="hljs-number">10.56</span>f; <span class="hljs-comment">//32位浮点数</span><br>        <span class="hljs-type">double</span> b = <span class="hljs-number">10.5e40</span>; <span class="hljs-comment">//64位浮点数</span><br>        <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">//字符</span><br>        Boolean l = <span class="hljs-literal">true</span>; <span class="hljs-comment">//布尔,true or false</span><br>        println(str)<br>        println(x)<br>        println(y)<br>        println(a)<br>        println(b)<br>        println(c)<br>        println(l)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="变量打印"><a href="#变量打印" class="headerlink" title="变量打印"></a>变量打印</h1><p>格式化输出</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">//初始化两个变量</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> y = <span class="hljs-number">6</span>;<br>        <br>        <span class="hljs-comment">//打印</span><br>        println(<span class="hljs-string">&quot;x = &quot;</span> + x + <span class="hljs-string">&quot; and X =&quot;</span> + X);<br>        println(<span class="hljs-string">&quot;x = $&#123;x&#125; and X = $&#123;X&#125;&quot;</span>);<br>        println(<span class="hljs-string">&#x27;x = $&#123;x&#125; and X = $&#123;X&#125;&#x27;</span>); <span class="hljs-comment">// 注意:单引号不支持插值,容易搞错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">x = 5 and X = 6<br>x = 5 and X = 6<br>x = <span class="hljs-variable">$&#123;x&#125;</span> and X = <span class="hljs-variable">$&#123;X&#125;</span><br></code></pre></td></tr></table></figure><p>从这里就看出有点python的影子也有点shell的感觉(个人感觉),所以说groovy是基于java参考python和其他语言开发出来的新语言.</p><h2 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-comment">// 初始化两个变量</span><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>        <span class="hljs-type">int</span> y = <span class="hljs-number">6</span>;<br>        <br>println <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">x = $&#123;x&#125;</span><br><span class="hljs-string">y = $&#123;y&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment">// 同样单三引号也不能插值</span><br>println <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">x = $&#123;x&#125;</span><br><span class="hljs-string">y = $&#123;y&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">x = 5<br>y = 6<br><br>x = <span class="hljs-variable">$&#123;x&#125;</span><br>y = <span class="hljs-variable">$&#123;X&#125;</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>groovy可以使用<code>返回类型</code>或<code>def</code>定义</li><li>可以接收任意数量的参数</li><li>定义参数时,不必显式定义类型,可以加修饰符例如:<ul><li>public (默认)</li><li>private</li><li>protected</li></ul></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">def</span> PrintHello() &#123;<br>        println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> sum(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-type">int</span> d = a + b + c;<br>        <span class="hljs-keyword">return</span> d;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        PrintHello();<br>        println(sum(<span class="hljs-number">5</span>, <span class="hljs-number">50</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span> a= <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-comment">// 与其他语言类似,都是if/else</span><br>    <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">100</span>) &#123;<br>        <span class="hljs-comment">//</span><br>        println(<span class="hljs-string">&quot;The value is less than 100&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println(<span class="hljs-string">&quot;The value is greater than 100&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">void</span> main(String[] args) &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        println(<span class="hljs-string">&quot;while 循环:&quot;</span>);<br>        <span class="hljs-keyword">while</span>(count &lt; <span class="hljs-number">5</span>) &#123;<br>            println(count);<br>            count++;<br>        &#125;<br>        <br>        println(<span class="hljs-string">&quot;for 循环:&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;<br>            println(i);<br>        &#125;<br>        <br>        println(<span class="hljs-string">&quot;for-in 循环&quot;</span>);<br>        <span class="hljs-type">int</span>[] array = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i <span class="hljs-keyword">in</span> array) &#123;<br>            println(i);<br>        &#125;<br>        <br>        println(<span class="hljs-string">&quot;for-in 范围循环&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.5</span>) &#123; <span class="hljs-comment">//这个比较特殊,1..5表示一个包括1到5的数组(我记得go好像也有个挺相似的写法)</span><br>            println(i);<br>        &#125;<br>        <br>        println(<span class="hljs-string">&quot;for-in 循环map&quot;</span>);<br>        <span class="hljs-keyword">def</span> ageMap = [<span class="hljs-string">&quot;Peter&quot;</span>: <span class="hljs-number">31</span>, <span class="hljs-string">&quot;Zoe&quot;</span>: <span class="hljs-number">33</span>, <span class="hljs-string">&quot;Nancy&quot;</span>: <span class="hljs-number">22</span>]; <span class="hljs-comment">//通过[]定义字典,与python不一样</span><br>        <span class="hljs-keyword">for</span>(am <span class="hljs-keyword">in</span> ageMap) &#123;<br>            println(am); <span class="hljs-comment">//留意它的输出</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">while</span> 循环：<br>0<br>1<br>2<br>3<br>4<br><span class="hljs-keyword">for</span> 循环：<br>0<br>1<br>2<br>3<br>4<br>for-in 循环：<br>0<br>1<br>2<br>3<br>for-in 范围循环：<br>1<br>2<br>3<br>4<br>5<br>for-in 循环map<br>Ken=21<br>John=25<br>Sally=22<br></code></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实这是<a href="https://www.qikqiak.com/post/groovy-simple-tutorial/">这篇博客</a>的”复制粘贴”,查重率高达80%,我自己手敲一遍加深下印象,有些地方稍稍以自己的方式写而已.一篇下来总的来说给我感觉groovy就像是套上java外套的python或者shell,当然它也支持面向对象编程等高级功能.但是对于我来说上面这些知识点对写一下jenkins file的脚本应该也够用了.</p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>groovy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂七杂八笔记本</title>
    <link href="/2023/03/21/anything/"/>
    <url>/2023/03/21/anything/</url>
    
    <content type="html"><![CDATA[<h1 id="shell-命令"><a href="#shell-命令" class="headerlink" title="shell 命令"></a>shell 命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看系统日志,比如你刚部署了istio,可以跑一下这个命令看看有没有报错</span><br>journalctl -f -u <br></code></pre></td></tr></table></figure><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p><code>tar</code>是常用的打包归档命令,但是它的参数有点要注意的地方</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将/tmp/test文件夹打包压缩成test.tar.gz</span><br>tar -czf &quot;/tmp/test.tar.gz&quot; -C &quot;/tmp&quot; &quot;test&quot;<br></code></pre></td></tr></table></figure><p>注意点:</p><ul><li>-f: 要紧跟生成的压缩文件的文件名,如果只写文件名,默认会创建在当前目录下,如果要指定生成路径,建议写<code>绝对路径</code></li><li>-C: 表面tar命令执行的路径,因为tar默认是在当前路径下执行,如果要打包特定路径下的文件,要用<code>-C</code>加<code>绝对路径</code>声明</li><li>“test”: 最后一个参数是你要打包的<code>文件名</code>或<code>文件夹名</code>,因为已经用<code>-C</code>指定了运行路劲,所以这里写<code>相对地址</code>即可</li></ul><h1 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清除集群所有pod,如果该pod配置了minAvailable: 1则至少会保留一个</span><br>kubectl drain<br></code></pre></td></tr></table></figure><h1 id="编译安装python"><a href="#编译安装python" class="headerlink" title="编译安装python"></a>编译安装python</h1><blockquote><p>不要用centos7了,python不知道哪个版本开始就一定要openssl1.1.1+,而centos7默认的是1.0.x,在centos7编译安装要么就不能使用ssl模块,要么就要处理系统的openssl底层开发库,太麻烦了.不仅如此,动了centos7的openssl还会影响它的原生python2和yum.</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里是以django为基准要安装的依赖,django的依赖比较多,基本上也够用了</span><br>dnf -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel libuuid-devel<br>dnf groupinstall -y &quot;Development Tools&quot;<br>wget https://www.python.org/ftp/python/3.10.13/Python-3.10.13.tar.xz<br>tar xf Python-3.10.13.tar.xz<br>cd Python-3.10.13<br>./configure --prefix=/opt/python3 --enable-optimizations<br>make -j$(nproc)<br>make install<br>ln -s /opt/python3/bin/python3 /usr/local/bin/python<br>ln -s /opt/python3/bin/pip3 /usr/local/bin/pip<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>奇技淫巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>anything</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:Istio概述</title>
    <link href="/2023/03/21/k8s-istio/"/>
    <url>/2023/03/21/k8s-istio/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202304170944993.png" srcset="/img/loading.gif" lazyload></p><h1 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h1><blockquote><p> 服务网格<br>概念,不是产品,针对微服务,解决网络层面的问题</p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>Linkerd: <ul><li>1.x基于节点(物理机,虚拟机)</li><li>2.x基于kubernetes</li></ul></li><li>Istio<ul><li>google+IBM+Lyft发起的开源项目</li><li>多平台支持</li></ul></li><li>相同点<ul><li>都基于sidecar<ul><li>每个服务都会被分配到一个单独的代理</li><li>代理负责服务间通讯与转发,将请求的数据路由到目标服务的代理</li><li>该代理再将请求转发到其管理的微服务</li></ul></li><li>都分为数据层和控制层</li></ul></li></ul><h1 id="Istio"><a href="#Istio" class="headerlink" title="Istio"></a>Istio</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202305210730462.svg" srcset="/img/loading.gif" lazyload></p><p>高纬架构: data plane + control plane</p><p>核心组件: (Envoy proxy) + (Envoy + Istiod)</p><p>数据层: 一系列的代理,以sidecar方式运行,负责所有的网络通讯以及策略</p><ul><li>proxy: <a href="https://www.envoyproxy.io/">Envoy</a> Istio的具体工作基本都由其完成.内置很多功能:<ul><li>动态服务发现</li><li>负载均衡</li><li>TLS终端</li><li>HTTP&#x2F;2与gRPC代理</li><li>熔断器</li><li>健康检查</li><li>基于百分比流量分割的分阶段发布</li><li>故障注入</li><li>丰富的指标</li></ul></li></ul><p>控制层: Istiod,提供服务发现,配置和证书管理</p><ul><li>Pilot: 好比是envoy的直接领导或者上司,指导envoy工作,为其提供信息.客户端为Pilot配置,Pilot将其转成envoy可以读取的格式.</li><li>Galley: 控制层的配置管理中心</li><li>Citadel: 安全相关,可以将http服务无感知升级成https;服务授权;RBAC访问控制;访问授权等等</li></ul><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303211638219.png" srcset="/img/loading.gif" lazyload></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303211639147.png" srcset="/img/loading.gif" lazyload><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303211639155.png" srcset="/img/loading.gif" lazyload><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303211640781.png" srcset="/img/loading.gif" lazyload></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="istioctl"><a href="#istioctl" class="headerlink" title="istioctl"></a>istioctl</h3><p>照着官方文档(比如<a href="https://istio.io/v1.13/zh/docs/setup/getting-started/">v1.13.4</a>)做就行了,有几个注意点:</p><ul><li><p>helm安装部署从v1.11就开始废弃了,推荐使用istioctl安装部署</p></li><li><p>istio的版本对k8s的版本有对应要求,先查清楚是否支持</p></li><li><p>基本上部署就是下载release包,解压,进到里面执行istioctl命令</p></li><li><p>部署的版本受两个因素影响</p><ul><li><p>环境变量: ISTIO_VERSION</p></li><li><p>istioctl的版本&#x3D;istio的版本,这是最高优先级</p></li></ul></li><li><p>部署示例应用的时候,可以把istio-ingressgateway svc的type从默认的LoadBalance改成NodePort,这样就可以直接访问示例应用,或者按官方文档的做法获取LoadBanlance监听的NodePort和NodeIP去访问也行.</p></li><li><p>同样,部署dashboard kiali时候,svc默认是clusterIP,端口只监听localhost,改成NodePort就能在集群外访问,其实包括prometheus&#x2F;grafana等addon都可以这么搞(测试环境),或者搞了ingress暴露出来?U can try.</p></li><li><p>列出profiles,istio支持多种不同的profile,不同profile包含不同的组件,demo包含所有组件,适合用来测试,default适合用于生产环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">istioctl profile list<br></code></pre></td></tr></table></figure></li><li><p>预检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">istioctl x precheck<br></code></pre></td></tr></table></figure></li></ul><h3 id="GetMesh"><a href="#GetMesh" class="headerlink" title="GetMesh"></a>GetMesh</h3><p>istio是最受欢迎和发展迅速的开源项目之一,这意味着它的发布和变更有时候会十分激进.GetMesh工具可以帮助我们管理不同版本istio,类似anaconda管理不同版本的python.</p><p>它可以通过针对不同的kubernetes分发版测试所有的istio版本以确保功能的完整性,另外GetMesh的istio版本再安全补丁和其他错误更新方面得到积极的支持.</p><blockquote><p>对于一些安全性要求更高的客户,GetMesh提供两种istio发行版来解决合规性问题:</p><ul><li><p>tetrate发行版,跟踪上有istio并可能应用额外的补丁</p></li><li><p>tetratefips发行版,符合FIPS标准的terate发行版</p></li></ul></blockquote><p>tetrate应该是istio的一个发行版,没有仔细研究.<a href="https://istio.tetratelabs.io/">官网</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">下载getmesh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -sL https://istio.tetratelabs.io/getmesh/install.sh | bash</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">验证</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">getmesh version</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用getmesh安装istio</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">getmesh通过kubernetes配置文件与活跃的kubernetes集群通信</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">通过以下命令安装demo配置文件的istio</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">该命令还会检查集群,以确保它准备好安装istio</span><br>getmesh istioctl install istio --set profile=demo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">config-validate验证配置</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">可以验证有没有当前namespace有没有写<span class="hljs-built_in">enable</span>注入sidecar</span><br>getmesh config-validate<br><span class="hljs-meta prompt_">#</span><span class="language-bash">也可以验证资源的yaml文件</span><br>getmesh config-validate my-resources.yml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">管理多个istio</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示当前集群上的istio版本</span><br>getmesh show<br><span class="hljs-meta prompt_">#</span><span class="language-bash">显示所有可信的istio版本</span><br>getmesh list<br><span class="hljs-meta prompt_">#</span><span class="language-bash">获取一个特定的版本,并设置为活跃</span><br>getmesh fetch --version 1.9.0 --flavor teratefips --flavor-version 1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看当前istioctl版本</span><br>getmesh istioctl version<br><span class="hljs-meta prompt_">#</span><span class="language-bash">切换istioctl版本</span><br>getmesh switch --version 1.9.5 --flavor tetrate --flavor-version 0<br></code></pre></td></tr></table></figure><h3 id="istioctl-operator"><a href="#istioctl-operator" class="headerlink" title="istioctl + operator"></a>istioctl + operator</h3><p>这方式基于1.10.3,<a href="https://istio.tetratelabs.io/">tetrate教程</a>,估计其他版本也差不多.</p><h4 id="初始化operator"><a href="#初始化operator" class="headerlink" title="初始化operator"></a>初始化operator</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建istio-operator命名空间,并部署CRD,operator deployment和operator工作所需的其他资源</span><br>istioctl operator init<br><span class="hljs-meta prompt_">#</span><span class="language-bash">默认会自动创建istio-system命名空间</span><br></code></pre></td></tr></table></figure><h4 id="指定profile"><a href="#指定profile" class="headerlink" title="指定profile"></a>指定profile</h4><p>要安装istio,我们需要创建istioOperator资源,并指定我们要使用的配置文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># profile-demo.yml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">install.istio.io/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">IstioOperator</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">istio-system</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">demo-istio-install</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">profile:</span> <span class="hljs-string">demo</span> <span class="hljs-comment">#指定使用demo配置文件</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f profile-demo.yml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">当operator检测到istioOperator资源的创建,它将会安装istio,大概需要5分钟左右</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看istio-system中的pod状态以检查istio的安装状态</span><br>kubectl get pods -n istio-system<br><span class="hljs-meta prompt_">#</span><span class="language-bash">以下输出表示安装完成</span><br>NAME                                   READY   STATUS    RESTARTS   AGE<br>istio-egressgateway-7bfdcc9d86-5kz2h   1/1     Running   0          3m20s<br>istio-ingressgateway-565bffd4d-v5t48   1/1     Running   0          3m21s<br>istiod-cc7f656cd-rhjm4                 1/1     Running   0          3m47s<br></code></pre></td></tr></table></figure><h4 id="启用sidecar注入"><a href="#启用sidecar注入" class="headerlink" title="启用sidecar注入"></a>启用sidecar注入</h4><p>往任意一个namespace中添加<code>istio-injection=enable</code>标签,就能在该命名空间上启用sidecar注入,这个namespace中每个一pod都被isitio自动注入envoy proxy sidecar.默认下default已被注入.</p><p>也可以使用<code>istioctl kube-inject -h</code>命令</p><p>部署一个deploy测试一下,可以看到里面的直接就有了两个容器,里面会跑一个名为istio-init的init pod和一个名为istio-proxy的sidecar</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl create deploy my-nginx --image=nginx</span><br>NAME                        READY   STATUS    RESTARTS   AGE<br>my-nginx-6b74b79f57-mbkr8   2/2     Running   0          2m15s<br></code></pre></td></tr></table></figure><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>istio本身会在内部维护一个<strong>服务发现表</strong>,里面记录所有基于平台的服务注册信息,例如k8s的services或consul services.也支持手动添加服务入口(<a href="https://istio.io/v1.13/zh/docs/concepts/traffic-management/#service-entries">ServiceEntry</a>)来添加一个入口到istio内部维护的服务注册中心.</p></blockquote><h2 id="虚拟服务-virtual-service-和目标规则-destination-rule"><a href="#虚拟服务-virtual-service-和目标规则-destination-rule" class="headerlink" title="虚拟服务(virtual service)和目标规则(destination rule)"></a>虚拟服务(virtual service)和目标规则(destination rule)</h2><blockquote><p>基于istio与平台(k8s)提供的基本连通性(CNI)和服务发现能力(service),让你配置如何将服务网格内将请求路由到服务,.每个虚拟服务包含一组路由规则,istio按顺序评估他们,将每个给定的请求匹配到虚拟服务指定的实际目标地址</p></blockquote><p>下面是istio的virtual service + destination rule 示例:</p><blockquote><p>默认情况下路由所有http流量到打了”version:v1”reviews pod</p><p>另外匹配&#x2F;wpcatalog和&#x2F;consumercatalog两个uri,重写为&#x2F;newcatalog并路由到打了”version:v2”reviews pod</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-route</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">prod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">reviews.prod.svc.cluster.local</span><br>  <span class="hljs-attr">http:</span> <span class="hljs-comment"># 匹配uri: /wpcatelog 和 /consumercatalog</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;reviews-v2-routes&quot;</span><br>    <span class="hljs-attr">match:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">&quot;/wpcatalog&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">uri:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">&quot;/consumercatalog&quot;</span><br>    <span class="hljs-attr">rewrite:</span> <span class="hljs-comment"># 将上面两个uri重写为/newcatalog</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">&quot;/newcatalog&quot;</span><br>    <span class="hljs-attr">route:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span> <span class="hljs-comment"># 路由到标签为&quot;version:v2&quot;的review pod</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">reviews.prod.svc.cluster.local</span><br>        <span class="hljs-attr">subset:</span> <span class="hljs-string">v2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;reviews-v1-route&quot;</span> <span class="hljs-comment"># 默认下路由所有http流量到标签为&quot;version: v1&quot;的reviews服务的pod</span><br>    <span class="hljs-attr">route:</span>  <span class="hljs-comment"># 没有match条件,为默认规则</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">destination:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">reviews.prod.svc.cluster.local</span><br>        <span class="hljs-attr">subset:</span> <span class="hljs-string">v1</span><br></code></pre></td></tr></table></figure><h3 id="virtual-service"><a href="#virtual-service" class="headerlink" title="virtual service"></a>virtual service</h3><blockquote><p>可以看到,virtual service本质上就是一个istio开发的CRD资源.</p><p>有点类似ingress,与service绑定,可以指定uri转发规则.</p><p>但是与ingress不一样的在于,它还可以根据subset和destination rule转发到指定版本的后端,以及配置一些istio更高级的功能.</p></blockquote><ul><li><p>hosts:</p><ul><li><p>列举虚拟服务的主机,即用户指定的目标或路由规则设定的目标.可以是IP,DNS,或者依赖于平台的短名称,官方建议在kuberbnetes中最好使用FQDN.</p></li><li><p>也可以使用通配符”*”前缀</p></li><li><p>不必是istio服务注册表中的实际内容,可以是虚拟的目标地址,帮助你”虚空建模”</p></li></ul></li><li><p>http: 包含虚拟服务的路由规则,用来描述匹配条件和路由行为,把http&#x2F;1.1,http2和gRPC流量发送到hosts指定的目标</p><ul><li><p>match: 匹配条件,举个例子:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span> <span class="hljs-comment">#此路由匹配headers中含有end-user=json的流量</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">headers:</span><br>      <span class="hljs-attr">end-user:</span><br>        <span class="hljs-attr">exact:</span> <span class="hljs-string">jason</span><br></code></pre></td></tr></table></figure></li><li><p>.rule.destination: 指定实际的目标地址,于hosts不同,这里指定定的host必须真实存在于istio服务注册表中.可以是一个由代理的服务网格,或是一个通过服务入口添加进来的非网格服务,比如kubernetes的SVC.</p><ul><li><p>路由优先级:</p><ul><li><p>默认从上到下</p></li><li><p>官方建议配置一个”无条件”或基于权重的规则作为最后一条规则,此规则也将成为默认规则</p></li></ul></li></ul></li></ul></li></ul><h3 id="destination-rule"><a href="#destination-rule" class="headerlink" title="destination rule"></a>destination rule</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DestinationRule</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">reviews-destination</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">reviews.prod.svc.cluster.local</span> <span class="hljs-comment">#通过指定同一个svc绑定virtual service和destination rule</span><br>  <span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v1</span> <span class="hljs-comment"># 必须显示声明使用使用哪个label给subset指定</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v2</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">version:</span> <span class="hljs-string">v2</span> <span class="hljs-comment"># 每个版本的label都要声明才能被virtual service使用</span><br></code></pre></td></tr></table></figure><blockquote><p>虚拟服务定义如何将流量路由给指定目标地址,目标规则配置该目标的流量.</p><p>也可以指定命名的服务子集(subsets),例如按版本给实例分组,然后在虚拟服务中使用match控制到不同实例的流量</p><p>还可以定制envoy流量策略,比如LB模型,TLS安全模式或熔断器等.</p></blockquote><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>由两部份组成:</p><ol><li><p>网关代理,也叫gateway controller</p><ul><li>比如istio-ingressgateway和istio-egressgateway</li></ul></li></ol><blockquote><p>实际上是运行在网格边界的独立的Envoy代理,可以配置4-6层的LB属性(如端口,TLS设置等),也可以替代7层(应用层)的流量路由功能(ingress-controller).</p><p>绑定一个virtual service到网关,就可以像管理其他数据层面的流量一样去管理网关流量.</p></blockquote><p>一般而言,主要用入口网关来管理进入的流量,当然出口网关也同样支持配置.通过”入门”文档部署的istio,会自动部署好两个预配置好的网关代理(istio-ingressgateway和istio-egressgateway),本质上是svc+pod(Envoy).</p><ul><li>网关配置:</li></ul><blockquote><p>这个例子指定让https流量从ext-host.example.com通过443端口流入网格,但没有指定任何路由规则.</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Gateway</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ext-host-gwy</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">my-gateway-controller</span><br>  <span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span><br>      <span class="hljs-attr">number:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">https</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTPS</span><br>    <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ext-host.example.com</span><br>    <span class="hljs-attr">tls:</span><br>      <span class="hljs-attr">mode:</span> <span class="hljs-string">SIMPLE</span><br>      <span class="hljs-attr">serverCertificate:</span> <span class="hljs-string">/tmp/tls.crt</span><br>      <span class="hljs-attr">privateKey:</span> <span class="hljs-string">/tmp/tls.key</span><br></code></pre></td></tr></table></figure><blockquote><p>要指定路由规则,必须要在virtual service上绑定网关</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.istio.io/v1alpha3</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">VirtualService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">virtual-svc</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hosts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ext-host.example.com</span><br>  <span class="hljs-attr">gateways:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ext-host-gwy</span><br></code></pre></td></tr></table></figure><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>istio的流量配置还支持更多高级功能,例如根据header转发,字符串匹配,重试,百分比转发等</p><ul><li>更多请阅<a href="https://istio.io/latest/zh/docs/reference/config/networking/">Istio &#x2F; 流量管理</a></li></ul><h1 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h1><h2 id="实验架构"><a href="#实验架构" class="headerlink" title="实验架构"></a>实验架构</h2><p>TBD</p><h2 id="流量管理"><a href="#流量管理" class="headerlink" title="流量管理"></a>流量管理</h2><h3 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h3><p><a href="https://raw.githubusercontent.com/istio/istio/release-1.13/samples/bookinfo/platform/kube/bookinfo.yaml">bookinfo.yaml</a></p><p>可以看到,和一般的deployment并没有太大区别,但要注意看deployment和pod都定义了label: version&#x3D;v1&#x2F;v2&#x2F;v3,这个在后面配置中有用.</p><h3 id="网关配置"><a href="#网关配置" class="headerlink" title="网关配置"></a>网关配置</h3><p><a href="https://raw.githubusercontent.com/istio/istio/release-1.13/samples/bookinfo/networking/bookinfo-gateway.yaml">bookinfo-gateway.yaml</a></p><p>根据入门教程在部署istio的时候,部署了一些预先配置好的<a href="https://istio.io/v1.13/zh/docs/concepts/traffic-management/#gateways">网关</a>(istio-ingressgateway和istio-egressgateway),默认使用ClusterIP类型的SVC.为了方便,把istio-ingressgateway的SVC类型改成了NodePort.</p><blockquote><p>与 Kubernetes Ingress API 这种控制进入系统流量的其他机制不同，Istio 网关让您充分利用流量路由的强大能力和灵活性。您可以这么做的原因是 Istio 的网关资源可以配置 4-6 层的负载均衡属性，如对外暴露的端口、TLS 设置等。也可以把应用层流量路由（L7）到相同的 API 资源.如果您绑定了一个常规的 Istio 虚拟服务到网关。这让您可以像管理网格中其他数据平面的流量一样去管理网关流量。</p></blockquote><p>里面定义了一个网关和一个virtual service,配置了uri和网关关联.</p><p>此时通过http:&#x2F;&#x2F;:&#x2F;productpage访问,多次刷新,发现版本会不停变动(review显示的星星).</p><p>那是因为还没有定义具体的review的virtual service,默认会轮询.review由三个版本在跑,所以不停刷新就看到不停变动.</p><h3 id="virtual-service-1"><a href="#virtual-service-1" class="headerlink" title="virtual service"></a>virtual service</h3><p><a href="https://raw.githubusercontent.com/istio/istio/release-1.13/samples/bookinfo/networking/virtual-service-all-v1.yaml">virtual-service-all-v1.yaml</a></p><p>这里面定义的virtual service: productpage其实和上面的bookinfo重复了,可以去掉的.</p><p>在bookinfo中加上subset: v1就可以指定版本</p><h3 id="destination-rule-1"><a href="#destination-rule-1" class="headerlink" title="destination rule"></a>destination rule</h3><p><a href="https://raw.githubusercontent.com/istio/istio/release-1.13/samples/bookinfo/networking/destination-rule-all.yaml">destination-rule-all.yaml</a></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>使用以下命令查看virtual service和destination rule:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get virtualservices -o yaml<br>kubectl get destinationrules -o yaml<br></code></pre></td></tr></table></figure><p>通过浏览器访问http:&#x2F;&#x2F;:&#x2F;productpage,多次刷新,发现版本已经固定,那是因为<a href="https://raw.githubusercontent.com/istio/istio/release-1.13/samples/bookinfo/networking/virtual-service-all-v1.yaml">virtual-service-all-v1.yaml</a>已经指定了使用的review版本,流量只会去到version: v1的pod.</p><p>把review的virtual service改一下,改成subnets: v2就能使用v2版本.实际上不同的版本一直在跑,只是流量的路由被istio控制.</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>istio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:API</title>
    <link href="/2023/03/20/k8s-api/"/>
    <url>/2023/03/20/k8s-api/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303200854365.png" srcset="/img/loading.gif" lazyload></p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303200845403.png" srcset="/img/loading.gif" lazyload></p><ul><li>核心资源: &#x2F;api&#x2F;<version>&#x2F;<resources></li><li>非核心(包括扩展): &#x2F;apis&#x2F;<groups>&#x2F;<version>&#x2F;<version></li></ul><h1 id="Doc"><a href="#Doc" class="headerlink" title="Doc"></a>Doc</h1><p><a href="https://kubernetes.io/zh-cn/docs/reference/using-api/api-concepts/">https://kubernetes.io/zh-cn/docs/reference/using-api/api-concepts/</a></p><h1 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h1><p>ApiServer: 基于http restful API</p><h1 id="允许访问"><a href="#允许访问" class="headerlink" title="允许访问"></a>允许访问</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/kube-api-server.service<br><span class="hljs-comment">#配置insecure-port</span><br>--insecure-port=&lt;port&gt;<br>systemctl daemon-reload<br>systemctl restart apiserver<br></code></pre></td></tr></table></figure><h1 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h1><p><a href="https://kubernetes.io/docs/reference/using-api/client-libraries/">https://kubernetes.io/docs/reference/using-api/client-libraries/</a></p><p><a href="https://github.com/kubernetes-client">https://github.com/kubernetes-client</a></p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:monitor</title>
    <link href="/2023/03/20/k8s-monitor/"/>
    <url>/2023/03/20/k8s-monitor/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303201649638.png" srcset="/img/loading.gif" lazyload></p><h1 id="Promethues"><a href="#Promethues" class="headerlink" title="Promethues"></a>Promethues</h1><p>众所周知,Prometheus+AlertManager+Grafna是当前最流行的云原生监控方案,关于这个方案的实践在<a href="https://anthing.cn/2022/06/17/Prometheus-Grafana-Monitor-System/">本博客</a>已经有记录,本文主要记录一些漏缺的知识以及在kubernetes上如何部署和接入</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据形式: metric: {k-v}</p><p>value的数据类型: long类型的整形值</p><ul><li>Counter: 记录累计值,只增加不减少,比如异常发生次数,请求次数</li><li>Gauge: 常规数组,可以变大可以变小</li><li>Histogram: 类似一个直方图,比如按请求的延迟范围进行分组,记录每个区间的个数</li><li>Summary: 样本排序后,第几个的值是多少</li></ul><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="节点基础指标"><a href="#节点基础指标" class="headerlink" title="节点基础指标"></a>节点基础指标</h3><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303201122895.png" srcset="/img/loading.gif" lazyload></p><h3 id="容器指标"><a href="#容器指标" class="headerlink" title="容器指标"></a>容器指标</h3><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303201124497.png" srcset="/img/loading.gif" lazyload></p><p>kubelet内置一个cAdvisor服务,负责采集容器内部的各种指标(cpu&#x2F;mem&#x2F;etc…),同时也会像exporter一样提供一个http服务供prometheus采集</p><h3 id="k8s组件"><a href="#k8s组件" class="headerlink" title="k8s组件"></a>k8s组件</h3><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303201127884.png" srcset="/img/loading.gif" lazyload></p><p>只需要让prometheus定期通过这些api获取数据即可</p><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><ol><li><p>手动</p></li><li><p>Helm</p></li><li><p>Prometheus Operator</p><blockquote><p>一个源码安装的参考教程: <a href="https://www.qikqiak.com/k8s-book/docs/58.Prometheus%20Operator.html">https://www.qikqiak.com/k8s-book/docs/58.Prometheus%20Operator.html</a></p><p>另外这个网站本身就是一个完整的教程</p></blockquote></li><li><p>Helm + Prometheus Operator: 非常优雅</p></li></ol><h2 id="Helm-Prometheus-Operator-部署"><a href="#Helm-Prometheus-Operator-部署" class="headerlink" title="Helm + Prometheus Operator 部署"></a>Helm + Prometheus Operator 部署</h2><p><a href="https://artifacthub.io/packages/helm/arldka/prometheus-operator">https://artifacthub.io/packages/helm/arldka/prometheus-operator</a></p><p>以下步骤可能已经过时,没有验证过,仅供参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>helm install [RELEASE_NAME] arldka/prometheus-operator<br><span class="hljs-comment"># 查看创建的自定义资源</span><br>kubectl get crd | grep xxx<br><span class="hljs-comment"># 删除,默认会放&quot;回收站&quot;, --purge表示永久删除</span><br>helm delete immoc-prom --purge<br><span class="hljs-comment"># crd需要手动清理</span><br>kubectl delete crd $(kubectl get crd | grep xxx | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>)<br><span class="hljs-comment"># 修改过配置后更新配置, 当然也可以delete再install</span><br>helm upgrade [RELEASE_NAME] ./prometheus-operator -f values.yaml<br><span class="hljs-comment"># 查看helm部署的东西</span><br>helm <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>一般来说都需要把chart包下载到本地,然后通过修改配置,做个性化配置</p><ul><li>节点基础指标: 默认已经配置好</li><li>k8s组件:<ul><li>需要确定各个服务的监听ip和端口(&#x2F;etc&#x2F;systemctl&#x2F;systemd&#x2F;etcd.service) (systemctl daemon -reload) (systemctl kube-scheduler restart)</li><li>修改chart包内的配置文件,配置对应的配置,一般是values.yaml</li><li>证书: &#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F; 导入到对应命名空间的secret,然后再配置使用</li></ul></li><li>容器指标: 配置好kubelet即可</li><li>rules<ul><li>default: values.yaml –&gt; templates&#x2F;prometheus&#x2F;rules&#x2F; 本质上也是一个CRD</li><li>custom: 参考它重新定义新的CRD (自己手动添加的不受helm控制)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>prometheus-operator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:日志收集</title>
    <link href="/2023/03/20/k8s-logging/"/>
    <url>/2023/03/20/k8s-logging/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303201043309.png" srcset="/img/loading.gif" lazyload></p><h1 id="日志收集"><a href="#日志收集" class="headerlink" title="日志收集"></a>日志收集</h1><p>网上有很多更新更多样的监控方案,这里仅作记录</p><h2 id="k8s的日志"><a href="#k8s的日志" class="headerlink" title="k8s的日志"></a>k8s的日志</h2><ul><li>stdout,stderr: 默认会保存在宿主机的固定目录(&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;<cname>&#x2F;<cname>-json.log)</li><li>应用的日志文件: 重启丢失</li></ul><h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><ol><li>远程存储: 应用直接将日志写到远端</li><li>sidecar: 每个pod加一个小容器,与主容器共享volume,负责获取日志并发送到远端,对应用无侵入,但对pod有侵入,有一定资源消耗<br><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303200936323.png" srcset="/img/loading.gif" lazyload></li><li>LogAgent: 将应用日志挂载到宿主机特定目录,用daemonset方式每个节点跑一个agent负责将宿主机上日志收集,对应用,pod无侵入,但要约定好所有应用的日志都挂载到特定目录,且保持一致的后缀名,否则维护起来比较困难,且难以判断哪个日志来自哪个pod,日志还要规划定期清理<br><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303200939105.png" srcset="/img/loading.gif" lazyload></li></ol><h2 id="LogPilot-ES-Kibana"><a href="#LogPilot-ES-Kibana" class="headerlink" title="LogPilot+ES+Kibana"></a>LogPilot+ES+Kibana</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303200944539.png" srcset="/img/loading.gif" lazyload></p><h3 id="LogPilot"><a href="#LogPilot" class="headerlink" title="LogPilot"></a>LogPilot</h3><p>阿里开源LogAgent,相比其他agent,这个是动态的,比较适合容器的动态环境,既可以采集docker的stdout和stderr也可以采集日志文件</p><ul><li>智能的容器日志采集工具</li><li>自动发现机制</li><li>开源: <a href="https://github.com/AliyunContainerService/log-pilot">https://github.com/AliyunContainerService/log-pilot</a></li><li>本质上是在静态采集工具的基础上再封装一层,比如filebeat,实现动态配置</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>以下yaml来自慕课网,仅供参考</p><h4 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch-api</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">es</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">transport</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">9200</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch-discovery</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">es</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">transport</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">9300</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;elasticsearch-service&quot;</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">es</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">es</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-comment">#允许调度到主节点(实验环境节点数不够)</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">node-role.kubernetes.io/master</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">dashboard-admin</span><br>      <span class="hljs-comment">#用一个小容器修改系统参数</span><br>      <span class="hljs-attr">initContainers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-sysctl</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">busybox:1.27</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">sysctl</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">-w</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">vm.max_map_count=262144</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">elasticsearch</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/imooc/elasticsearch:5.5.1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9200</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">9300</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">capabilities:</span><br>            <span class="hljs-attr">add:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">IPC_LOCK</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-string">SYS_RESOURCE</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">4000Mi</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">2000Mi</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;http.host&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;0.0.0.0&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;network.host&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;_eth0_&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;cluster.name&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;docker-cluster&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;bootstrap.memory_lock&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;false&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;discovery.zen.ping.unicast.hosts&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;elasticsearch-discovery&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;discovery.zen.ping.unicast.hosts.resolve_timeout&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;10s&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;discovery.zen.ping_timeout&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;6s&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;discovery.zen.minimum_master_nodes&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;2&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;discovery.zen.fd.ping_interval&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;2s&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;discovery.zen.no_master_block&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;write&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;gateway.expected_nodes&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;2&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;gateway.expected_master_nodes&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;1&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;transport.tcp.connect_timeout&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;60s&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;ES_JAVA_OPTS&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;-Xms2g -Xmx2g&quot;</span><br>        <span class="hljs-attr">livenessProbe:</span><br>          <span class="hljs-attr">tcpSocket:</span><br>            <span class="hljs-attr">port:</span> <span class="hljs-string">transport</span><br>          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">20</span><br>          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">es-data</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/data</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">es-data</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/es-data</span><br></code></pre></td></tr></table></figure><h4 id="Logpilot"><a href="#Logpilot" class="headerlink" title="Logpilot"></a>Logpilot</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">DaemonSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">log-pilot</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">log-pilot</span><br>    <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">log-es</span><br>        <span class="hljs-attr">kubernetes.io/cluster-service:</span> <span class="hljs-string">&quot;true&quot;</span><br>        <span class="hljs-attr">version:</span> <span class="hljs-string">v1.22</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">tolerations:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">node-role.kubernetes.io/master</span><br>        <span class="hljs-attr">effect:</span> <span class="hljs-string">NoSchedule</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">dashboard-admin</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">log-pilot</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/imooc/log-pilot:0.9-filebeat</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>            <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;FILEBEAT_OUTPUT&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;elasticsearch&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;ELASTICSEARCH_HOST&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;elasticsearch-api&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;ELASTICSEARCH_PORT&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;9200&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;ELASTICSEARCH_USER&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;elastic&quot;</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;ELASTICSEARCH_PASSWORD&quot;</span><br>            <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;changeme&quot;</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">sock</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/run/docker.sock</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">root</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/host</span><br>          <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlib</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/filebeat</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/filebeat</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">capabilities:</span><br>            <span class="hljs-attr">add:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">SYS_ADMIN</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">30</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment">#通过挂载这个目录获得获取访问宿主机docker信息的权限</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">sock</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/run/docker.sock</span><br>      <span class="hljs-comment">#挂载宿主机整个文件系统,只有这样才能拿到docker任意配置</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">root</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlib</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/lib/filebeat</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">varlog</span><br>        <span class="hljs-attr">hostPath:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log/filebeat</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br></code></pre></td></tr></table></figure><h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">kibana</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-string">http</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#ingress</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">kibana.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">kibana</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">component:</span> <span class="hljs-string">kibana</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>     <span class="hljs-attr">component:</span> <span class="hljs-string">kibana</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">component:</span> <span class="hljs-string">kibana</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">kibana</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/imooc/kibana:5.5.1</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">CLUSTER_NAME</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">docker-cluster</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ELASTICSEARCH_URL</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">http://elasticsearch-api:9200/</span><br>        <span class="hljs-attr">resources:</span><br>          <span class="hljs-attr">limits:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">1000m</span><br>          <span class="hljs-attr">requests:</span><br>            <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5601</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><br></code></pre></td></tr></table></figure><h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#deploy</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">web-demo</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">web-demo</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web-demo</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">hub.mooc.com/kubernetes/web:v1</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>        <span class="hljs-attr">env:</span><br>        <span class="hljs-comment">#这个名字有特定要求,aliyun_logs_是固定前缀,最后一段是&lt;自定义名字&gt;,如果对接es就是索引名,如果对接kafka就是topic名</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">aliyun_logs_catalina</span><br>          <span class="hljs-comment">#容器的标准输出</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;stdout&quot;</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">aliyun_logs_access</span><br>          <span class="hljs-comment">#具体要采集的日志文件</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;/usr/local/tomcat/logs/*&quot;</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/local/tomcat/logs</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">accesslogs</span><br>      <span class="hljs-comment">#将容器内的目录挂载到宿主机上的默认位置</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">accesslogs</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br><span class="hljs-meta">---</span><br><span class="hljs-comment">#service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">web-demo</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-comment">#ingress</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">web.mooc.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">web-demo</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s集群部署(持续更新)</title>
    <link href="/2023/03/20/k8s-cluster-deploy/"/>
    <url>/2023/03/20/k8s-cluster-deploy/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303200905760.png" srcset="/img/loading.gif" lazyload></p><h1 id="组件架构及版本"><a href="#组件架构及版本" class="headerlink" title="组件架构及版本"></a>组件架构及版本</h1><ul><li>k8s: 1.20.5</li><li><del>glusterfs : 6.0</del></li><li>calico: 3.8</li><li>docker-ce: 19.03</li><li>containerd: 1.4.9</li></ul><h1 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h1><p>centos7 升级到最新内核5.4+</p><p>三节点: k8s-node1-3</p><p>&#x2F;etc&#x2F;hosts做好主机名解析</p><table><thead><tr><th>节点</th><th>部署组件</th></tr></thead><tbody><tr><td>k8s-node1</td><td>glusterFS&#x2F;k8s-master</td></tr><tr><td>k8s-node2</td><td>glusterFS&#x2F;k8s-worker</td></tr><tr><td>k8s-node3</td><td>heketi&#x2F;k8s-worker</td></tr></tbody></table><h1 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h1><p>tbd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">daemon.json修改cgroup driver不生效,还有一个地方需要修改</span><br>vim /etc/systemd/system/multi-user.target.wants/docker.service<br>ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd<br></code></pre></td></tr></table></figure><h1 id="部署gluterFS集群"><a href="#部署gluterFS集群" class="headerlink" title="部署gluterFS集群"></a><del>部署gluterFS集群</del></h1><p>测试环境双节点glusterfs;heketi提供resetful API给k8s</p><p>生产建议至少三节点glusterfs,避免脑裂</p><p>gluster+heketi直接使用块存储设备,即无需分区无需格式化直接使用(类似&#x2F;dev&#x2F;sdb)</p><p>相比ceph,部署简单好多,ceph是对象存储–&gt;块存储,glusterFS是块存储–&gt;对象存储</p><h2 id="安装glusterfs"><a href="#安装glusterfs" class="headerlink" title="安装glusterfs"></a>安装glusterfs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install centos-release-gluster<br>yum -y install glusterfs glusterfs-fuse glusterfs-server<br>systemctl <span class="hljs-built_in">enable</span> glusterd --now<br>systemctl status glusterd<br></code></pre></td></tr></table></figure><h2 id="安装heketi"><a href="#安装heketi" class="headerlink" title="安装heketi"></a>安装heketi</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y centos-release-gluster<br>yum install -y heketi heketi-client<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>&#x2F;etc&#x2F;heketi&#x2F;heketi.json</p><p>“#”号注释需去掉,密码自定义,最好备份一下原模版配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br><span class="hljs-comment">#默认端口8080</span><br>  <span class="hljs-string">&quot;_port_comment&quot;</span>: <span class="hljs-string">&quot;Heketi Server Port Number&quot;</span>,<br>  <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;8080&quot;</span>,<br><span class="hljs-comment">#默认值false，不需要认证</span><br>  <span class="hljs-string">&quot;_use_auth&quot;</span>: <span class="hljs-string">&quot;Enable JWT authorization. Please enable for deployment&quot;</span>,<br>  <span class="hljs-string">&quot;use_auth&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-comment">#设置密码</span><br>  <span class="hljs-string">&quot;_jwt&quot;</span>: <span class="hljs-string">&quot;Private keys for access&quot;</span>,<br>  <span class="hljs-string">&quot;jwt&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;_admin&quot;</span>: <span class="hljs-string">&quot;Admin has access to all APIs&quot;</span>,<br>    <span class="hljs-string">&quot;admin&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;admin@123&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;_user&quot;</span>: <span class="hljs-string">&quot;User only has access to /volumes endpoint&quot;</span>,<br>    <span class="hljs-string">&quot;user&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;user@123&quot;</span><br>    &#125;<br>  &#125;,<br> <br>  <span class="hljs-string">&quot;_glusterfs_comment&quot;</span>: <span class="hljs-string">&quot;GlusterFS Configuration&quot;</span>,<br>  <span class="hljs-string">&quot;glusterfs&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;_executor_comment&quot;</span>: [<br>      <span class="hljs-string">&quot;Execute plugin. Possible choices: mock, ssh&quot;</span>,<br>      <span class="hljs-string">&quot;mock: This setting is used for testing and development.&quot;</span>,<br>      <span class="hljs-string">&quot;      It will not send commands to any node.&quot;</span>,<br>      <span class="hljs-string">&quot;ssh:  This setting will notify Heketi to ssh to the nodes.&quot;</span>,<br>      <span class="hljs-string">&quot;      It will need the values in sshexec to be configured.&quot;</span>,<br>      <span class="hljs-string">&quot;kubernetes: Communicate with GlusterFS containers over&quot;</span>,<br>      <span class="hljs-string">&quot;            Kubernetes exec api.&quot;</span><br>    ],<br>    <span class="hljs-comment">#使用ssh</span><br>    <span class="hljs-string">&quot;executor&quot;</span>: <span class="hljs-string">&quot;ssh&quot;</span>,<br> <br>    <span class="hljs-string">&quot;_sshexec_comment&quot;</span>: <span class="hljs-string">&quot;SSH username and private key file information&quot;</span>,<br>    <span class="hljs-string">&quot;sshexec&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;keyfile&quot;</span>: <span class="hljs-string">&quot;/etc/heketi/heketi_key&quot;</span>,<br>      <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;root&quot;</span>,<br>      <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-string">&quot;22&quot;</span>,<br>      <span class="hljs-string">&quot;fstab&quot;</span>: <span class="hljs-string">&quot;/etc/fstab&quot;</span><br>    &#125;,<br> <br>    <span class="hljs-string">&quot;_kubeexec_comment&quot;</span>: <span class="hljs-string">&quot;Kubernetes configuration&quot;</span>,<br>    <span class="hljs-string">&quot;kubeexec&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;host&quot;</span> :<span class="hljs-string">&quot;https://kubernetes.host:8443&quot;</span>,<br>      <span class="hljs-string">&quot;cert&quot;</span> : <span class="hljs-string">&quot;/path/to/crt.file&quot;</span>,<br>      <span class="hljs-string">&quot;insecure&quot;</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;kubernetes username&quot;</span>,<br>      <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;password for kubernetes user&quot;</span>,<br>      <span class="hljs-string">&quot;namespace&quot;</span>: <span class="hljs-string">&quot;OpenShift project or Kubernetes namespace&quot;</span>,<br>      <span class="hljs-string">&quot;fstab&quot;</span>: <span class="hljs-string">&quot;Optional: Specify fstab file on node.  Default is /etc/fstab&quot;</span><br>    &#125;,<br> <br>    <span class="hljs-string">&quot;_db_comment&quot;</span>: <span class="hljs-string">&quot;Database file name&quot;</span>,<br>    <span class="hljs-string">&quot;db&quot;</span>: <span class="hljs-string">&quot;/var/lib/heketi/heketi.db&quot;</span>,<br> <br>    <span class="hljs-string">&quot;_loglevel_comment&quot;</span>: [<br>      <span class="hljs-string">&quot;Set log level. Choices are:&quot;</span>,<br>      <span class="hljs-string">&quot; none, critical, error, warning, info, debug&quot;</span>,<br>      <span class="hljs-string">&quot;Default is warning&quot;</span><br>    ],<br><span class="hljs-comment">#默认日志输出debug</span><br><span class="hljs-comment">#日志信息输出在/var/log/message</span><br>    <span class="hljs-string">&quot;loglevel&quot;</span> : <span class="hljs-string">&quot;warning&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成key"><a href="#生成key" class="headerlink" title="生成key"></a>生成key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -q -f /etc/heketi/heketi_key -N <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">chown</span> heketi:heketi /etc/heketi/heketi_key<br>ssh-copy-id -i /etc/heketi/heketi_key.pub root@k8s-node1<br>ssh-copy-id -i /etc/heketi/heketi_key.pub root@k8s-node2<br></code></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#启动前确保/usr/lib/systemd/system/heketi.service 包含配置--config=/etc/heketi/heketi.json</span><br>systemctl <span class="hljs-built_in">enable</span> heketi --now<br>systemctl status heketi<br></code></pre></td></tr></table></figure><h3 id="拓扑配置"><a href="#拓扑配置" class="headerlink" title="拓扑配置"></a>拓扑配置</h3><p>&#x2F;etc&#x2F;heketi&#x2F;topology.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs json"># 通过topology.json文件定义组建GlusterFS集群；<br># topology指定了层级关系：clusters--&gt;nodes--&gt;node/devices--&gt;hostnames/zone；<br># node/hostnames字段的manage填写主机ip，指管理通道，在heketi服务器不能通过hostname访问GlusterFS节点时不能填写hostname；<br># node/hostnames字段的storage填写主机ip，指存储数据通道，与manage可以不一样；<br># node/zone字段指定了node所处的故障域，heketi通过跨故障域创建副本，提高数据高可用性质，如可以通过rack的不同区分zone值，创建跨机架的故障域；<br># devices字段指定GlusterFS各节点的盘符（可以是多块盘&#x27;<span class="hljs-punctuation">,</span>&#x27;分割），必须是未创建文件系统的裸设备<br>#本次两台glusterfs主机添加硬盘/dev/sdb<br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;clusters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;hostnames&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;manage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;192.168.1.61&quot;</span><br>              <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;storage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;192.168.1.61&quot;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zone&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;devices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;/dev/sdb&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;node&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;hostnames&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;manage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;192.168.1.62&quot;</span><br>              <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;storage&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;192.168.1.62&quot;</span><br>              <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;zone&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;devices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;/dev/sdb&quot;</span><br>          <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>激活拓扑配置及常用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">heketi-cli --server http://localhost:8080 --user admin --secret admin@123 topology load --json=/etc/heketi/topology.json<br><span class="hljs-comment">#查看集群信息</span><br>heketi-cli --user admin --secret admin@123 topology info --server http://localhost:8080<br><span class="hljs-comment">#集群列表</span><br>heketi-cli --user admin --secret admin@123 cluster list<br><span class="hljs-comment">#查看集群信息 需要加集群cluster ID</span><br>heketi-cli --user admin --secret admin@123 cluster info ca501b26cc0cfdf391dfe1d7fc7ad242<br><span class="hljs-comment">#查看node列表</span><br>heketi-cli --user admin --secret admin@123 node list<br><span class="hljs-comment">#查看node详细信息info 需要加node id</span><br>heketi-cli --user admin --secret admin@123 node info 4f58f2c0691b92014c6d3b83c390c0a2<br><span class="hljs-comment">#查看磁盘详细信息info需要加磁盘ID</span><br>heketi-cli --user admin --secret admin@123 device info deeb6efc0e8821ba4a443e683dfdf041<br></code></pre></td></tr></table></figure><h1 id="部署miniIO"><a href="#部署miniIO" class="headerlink" title="部署miniIO"></a>部署miniIO</h1><p>TBD</p><h1 id="部署k8s"><a href="#部署k8s" class="headerlink" title="部署k8s"></a>部署k8s</h1><p>关闭selinux</p><h2 id="安装依赖或工具"><a href="#安装依赖或工具" class="headerlink" title="安装依赖或工具"></a>安装依赖或工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp net-tools<br></code></pre></td></tr></table></figure><h2 id="防火墙及端口"><a href="#防火墙及端口" class="headerlink" title="防火墙及端口"></a>防火墙及端口</h2><p><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#configure-cgroup-driver-used-by-kubelet-on-control-plane-node">查看官方说明</a>或者直接关闭</p><h2 id="前置参数配置"><a href="#前置参数配置" class="headerlink" title="前置参数配置"></a>前置参数配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/hosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将集群ip和主机名都加进去</span><br>swapoff -a<br>vim /etc/fstab<br><span class="hljs-meta prompt_">#</span><span class="language-bash">注释掉swap</span><br></code></pre></td></tr></table></figure><h2 id="内核模块参数配置"><a href="#内核模块参数配置" class="headerlink" title="内核模块参数配置"></a>内核模块参数配置</h2><h3 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h3><p>&#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">net.bridge.bridge-nf-call-iptables=1 <span class="hljs-comment"># 节点上的iptables能够正确地查看桥接流量</span><br>net.bridge.bridge-nf-call-ip6tables=1   <span class="hljs-comment"># 节点上的iptables能够正确地查看桥接流量</span><br>net.ipv4.ip_forward=1<br>vm.swappiness=0         <span class="hljs-comment"># 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它</span><br>vm.overcommit_memory=1  <span class="hljs-comment"># 不检查物理内存是否够用</span><br>vm.panic_on_oom=0       <span class="hljs-comment"># 开启 OOM</span><br>fs.inotify.max_user_instances=8192<br>fs.inotify.max_user_watches=1048576<br>fs.file-max=52706963<br>fs.nr_open=52706963<br>net.ipv6.conf.all.disable_ipv6=1<br>net.netfilter.nf_conntrack_max=2310720<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">生效</span><br>sysctl -p /etc/sysctl.d/k8s.conf<br></code></pre></td></tr></table></figure><h3 id="ipvs必备模块"><a href="#ipvs必备模块" class="headerlink" title="ipvs必备模块"></a>ipvs必备模块</h3><p>&#x2F;etc&#x2F;sysconfig&#x2F;modules&#x2F;ipvs.modules</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>modprobe -- ip_vs<br>modprobe -- ip_vs_rr<br>modprobe -- ip_vs_wrr<br>modprobe -- ip_vs_sh<br>modprobe -- nf_conntrack_ipv4<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">生效验证</span><br>chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4<br><span class="hljs-meta prompt_">#</span><span class="language-bash">提示modprobe: FATAL: Module nf_conntrack_ipv4 not found.为正常现象</span><br></code></pre></td></tr></table></figure><h2 id="调整时区"><a href="#调整时区" class="headerlink" title="调整时区"></a>调整时区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置系统时区为中国/上海</span><br>timedatectl set-timezone Asia/Shanghai<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前的 UTC 时间写入硬件时钟</span><br>timedatectl set-local-rtc 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启依赖于系统时间的服务</span><br>systemctl restart rsyslog<br>systemctl restart crond<br></code></pre></td></tr></table></figure><h2 id="安装容器运行时"><a href="#安装容器运行时" class="headerlink" title="安装容器运行时"></a>安装容器运行时</h2><p>docker18+后自带containerd,如果不确定也可以手动装一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y yum-utils device-mapper-persistent-data lvm2<br>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo<br>yum -y install docker-ce-19.03.15-3.el7<br>systemctl enable docker --now<br>systemctl enable containerd --now<br></code></pre></td></tr></table></figure><h2 id="配置containerd"><a href="#配置containerd" class="headerlink" title="配置containerd"></a>配置containerd</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成默认配置</span><br>containerd config default &gt; /etc/containerd/config.toml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启cgoup driver 为 systemd,修改镜像源</span><br>sed -i &quot;s#k8s.gcr.io#registry.cn-hangzhou.aliyuncs.com/google_containers#g&quot;              /etc/containerd/config.toml<br>sed -i &quot;s#SystemdCgroup = false#SystemdCgroup = true#g&quot; /etc/containerd/config.toml<br>sed -i &quot;s#https://registry-1.docker.io#https://registry.cn-hangzhou.aliyuncs.com#g&quot;      /etc/containerd/config.toml<br><span class="hljs-meta prompt_">#</span><span class="language-bash">注意sanbox image也需要改，不然会下载失败，可以通过kubeadm config images <span class="hljs-built_in">ls</span> --config kubeadm.yml 获取镜像版本列表</span><br>sed -i &quot;s#registry.k8s.io/pause:3.6#registry.aliyuncs.com/google_containers/pause:3.2#g&quot; /etc/containerd/config.toml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启</span><br>systemctl daemon-reload<br>systemctl restart containerd<br></code></pre></td></tr></table></figure><h2 id="安装k8s组件"><a href="#安装k8s组件" class="headerlink" title="安装k8s组件"></a>安装k8s组件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &lt;&lt; EOF &gt; /etc/yum.repos.d/kubernetes.repo <br>[kubernetes]<br>name=Kubernetes<br>baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64<br>enabled=1<br>gpgcheck=0<br>repo_gpgcheck=0<br>gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg<br>http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>EOF<br>yum makecache fast<br>yum install -y kubeadm-1.20.5 kubectl-1.20.5 kubelet-1.20.5<br>systemctl enable kubelet --now<br><span class="hljs-meta prompt_">#</span><span class="language-bash">kubelet暂时还启动不了 是正常现象</span><br></code></pre></td></tr></table></figure><h2 id="设置k8s运行时为containerd"><a href="#设置k8s运行时为containerd" class="headerlink" title="设置k8s运行时为containerd"></a>设置k8s运行时为containerd</h2><ul><li>安装crictl<br> containerd的命令行客户端工具<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.19.0/crictl-v1.19.0-linux-amd64.tar.gz<br>tar -xzvf crictl-v1.19.0-linux-amd64.tar.gz <br>mv crictl /usr/local/bin/<br></code></pre></td></tr></table></figure></li><li>修改crictl配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/crictl.yaml<br>runtime-endpoint: unix:///var/run/containerd/containerd.sock<br>image-endpoint: unix:///var/run/containerd/containerd.sock<br>timeout: 10<br>debug: true<br></code></pre></td></tr></table></figure></li><li>检查containerd配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">如果有下面的配置要注释掉</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">disabled_plugins = [<span class="hljs-string">&quot;cri&quot;</span>]</span><br></code></pre></td></tr></table></figure><ul><li>修改kubelet启动参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysconfig/kubelet<br>KUBELET_EXTRA_ARGS=&quot;--container-runtime=remote --container-runtime-endpoint=unix:///var/run/containerd/containerd.sock&quot;<br></code></pre></td></tr></table></figure><ul><li>crictl基本命令</li></ul><p>​使用containerd作为容器运行时后，docker命令就基本用不上，查看镜像列表和进程都要用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">crictl images<br>crictl ps<br></code></pre></td></tr></table></figure><h2 id="使用kubeadm初始化k8s"><a href="#使用kubeadm初始化k8s" class="headerlink" title="使用kubeadm初始化k8s"></a>使用kubeadm初始化k8s</h2><ul><li>生成默认配置并按需修改</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm config print init-defaults &gt; kubeadm.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常用修改项</span><br>advertiseAddress: 192.168.1.111 #api server ip,双网卡一般用内网ip,供k8s各组件访问<br>criSocket: /run/containerd/containerd.sock #使用containerd<br>imageRepository: registry.aliyuncs.com/google_containers <br>kubernetesVersion: v1.20.5 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 dnsDomain: cluster.local 添加，与 dnsDomain 平级</span><br>  podSubnet: 172.16.0.0/16 #pod网段,不配置的话默认为10.244.0.0/24,后面部署calico需要用到<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在最后添加</span><br>---<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用ipvs</span><br>apiVersion: kubeproxy.config.k8s.io/v1alpha1<br>kind: KubeProxyConfiguration<br>mode: ipvs <br>---<br><span class="hljs-meta prompt_"># </span><span class="language-bash">cgroup driver使用systemd</span><br>apiVersion: kubelet.config.k8s.io/v1beta1<br>kind: KubeletConfiguration<br>cgroupDriver: systemd<br></code></pre></td></tr></table></figure><ul><li>初始化集群</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm init --config=kubeadm.yaml<br></code></pre></td></tr></table></figure><ul><li>初始化后操作</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br></code></pre></td></tr></table></figure><ul><li>获取节点添加命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubeadm token create --print-join-command<br></code></pre></td></tr></table></figure><ul><li><p>将上一步输出的命令在worker节点上执行</p></li><li><p>检查集群状态</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查kubelet状态以及新加的启动参数是否生效</span><br>systemctl status kubelet<br>ps -ef | grep kubelet <br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查k8s集群,container runtime一列显示正在使用的运行时</span><br>kubectl get nodes -o wide<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查组件状态</span><br>kubectl get cs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">一般scheduler和controller-manager会显示会unhealthy 但不影响使用 修正方法如下</span><br>vim /etc/kubernetes/manifests/kube-scheduler.yaml<br>vim /etc/kubernetes/manifests/kube-controller-manager.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将上面两个文档中 port=0 这个环境变量注释掉 等待一段时间即可恢复</span><br></code></pre></td></tr></table></figure><ul><li>部署calico</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://docs.projectcalico.org/v3.8/manifests/calico.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置项</span><br>- name: calico-node<br>          image: calico/node:v3.8.9<br>          env:<br>            # Use Kubernetes API as the backing datastore.<br>            - name: DATASTORE_TYPE<br>              value: &quot;kubernetes&quot;<br>              # 增加下面变量和值，与自己的系统匹配,一般写内网网卡<br>            - name: IP_AUTODETECTION_METHOD              <br>              value: &quot;interface=eth0&quot;<br>              # 找到 CALICO_IPV4POOL_CIDR 修改成上面定义的pod_subnet<br>            - name: CALICO_IPV4POOL_CIDR<br>              value: &quot;172.16.0.0/16&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">部署</span><br>kubectl apply -f calico.yaml<br></code></pre></td></tr></table></figure><ul><li>等待节点ready及calico pod启动完成</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get nodes<br>kubectl get pods -n kube-system -w<br><span class="hljs-meta prompt_"># </span><span class="language-bash">calico部署并启动完成后 coredns 才会正常running</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">偶尔calico某个节点长时间都启动不了可以尝试delete再重新apply</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubectl delete -f calico.yaml</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">kubectl apply -f calico.yaml</span><br></code></pre></td></tr></table></figure><ul><li>测试dns</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl run -it --rm dns-test --image=busybox sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">容器内执行下面命令，查看能否正常解析出 kubernetes</span><br>nslookup kubernetes<br></code></pre></td></tr></table></figure><ul><li>kubectl命令自动补全</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install bash-completion -y<br>echo &#x27;source /usr/share/bash-completion/bash_completion&#x27; &gt;&gt; ~/.bashrc<br>echo &#x27;source &lt;(kubectl completion bash)&#x27; &gt;&gt; ~/.bashrc<br>source ~/.bashrc<br></code></pre></td></tr></table></figure><h1 id="k8s使用存储类动态挂载glusterFS"><a href="#k8s使用存储类动态挂载glusterFS" class="headerlink" title="k8s使用存储类动态挂载glusterFS"></a>k8s使用存储类动态挂载glusterFS</h1><h2 id="创建存储类"><a href="#创建存储类" class="headerlink" title="创建存储类"></a>创建存储类</h2><p>使用yaml文件创建存储类</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># provisioner：表示存储分配器，需要根据后端存储的不同而变更；</span><br><span class="hljs-comment"># reclaimPolicy: 默认即”Delete”，删除pvc后，相应的pv及后端的volume，brick(lvm)等一起删除；设置为”Retain”时则保留数据，需要手工处理</span><br><span class="hljs-comment"># resturl：heketi API服务提供的url；</span><br><span class="hljs-comment"># restauthenabled：可选参数，默认值为”false”，heketi服务开启认证时必须设置为”true”；</span><br><span class="hljs-comment"># restuser：可选参数，开启认证时设置相应用户名；</span><br><span class="hljs-comment"># secretNamespace：可选参数，开启认证时可以设置为使用持久化存储的namespace；</span><br><span class="hljs-comment"># secretName：可选参数，开启认证时，需要将heketi服务的认证密码保存在secret资源中；</span><br><span class="hljs-comment"># clusterid：可选参数，指定集群id，也可以是1个clusterid列表，格式为”id1,id2”；</span><br><span class="hljs-comment"># volumetype：可选参数，设置卷类型及其参数，如果未分配卷类型，则有分配器决定卷类型；如”volumetype: replicate:3”表示3副本的replicate卷，”volumetype: disperse:4:2”表示disperse卷，其中‘4’是数据，’2’是冗余校验，”volumetype: none”表示distribute卷#</span><br><span class="hljs-comment"># cat gluster-heketi-storageclass.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gluster-heketi-storageclass</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/glusterfs</span><br><span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">resturl:</span> <span class="hljs-string">&quot;http://192.168.1.61:8080&quot;</span> <span class="hljs-comment"># heketi ip及端口</span><br>  <span class="hljs-attr">restauthenabled:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">restuser:</span> <span class="hljs-string">&quot;admin&quot;</span><br>  <span class="hljs-attr">secretNamespace:</span> <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">secretName:</span> <span class="hljs-string">&quot;heketi-secret&quot;</span><br>  <span class="hljs-comment">#restuserkey: &quot;xiaotech&quot;</span><br>  <span class="hljs-attr">volumetype:</span> <span class="hljs-string">&quot;replicate:2&quot;</span> <span class="hljs-comment">#默认为副本模式,本文档为双节点所以副本数为2,生产建议至少3节点</span><br> <br><span class="hljs-comment"># 生成secret资源，其中”key”值需要转换为base64编码格式</span><br> <span class="hljs-string">echo</span> <span class="hljs-string">-n</span> <span class="hljs-string">&quot;admin@123&quot;</span><span class="hljs-string">|base64</span><br> <br><span class="hljs-comment"># 注意name/namespace与storageclass资源中定义一致；</span><br><span class="hljs-comment"># 密码必须有“kubernetes.io/glusterfs” type</span><br><span class="hljs-comment"># cat heketi-secret.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">heketi-secret</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-comment"># base64 encoded password. E.g.: echo -n &quot;mypassword&quot; | base64</span><br>  <span class="hljs-attr">key:</span> <span class="hljs-string">YWRtaW5AMTIz</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">kubernetes.io/glusterfs</span><br></code></pre></td></tr></table></figure><p>创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f heketi-secret.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意：storageclass资源创建后不可变更，如修改只能删除后重建</span><br>kubectl apply -f gluster-heketi-storageclass.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">验证</span><br>kubectl describe storageclass gluster-heketi-storageclass<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 定义pvc</span><br><span class="hljs-comment"># cat gluster-heketi-pvc.yaml</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gluster-heketi-pvc</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br>  <span class="hljs-comment">#annotations:</span><br>  <span class="hljs-comment">#  volume.beta.kubernetes.io/storage-class: &quot;glusterfs&quot;</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment">#与storageclass名字对应</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">gluster-heketi-storageclass</span><br>  <span class="hljs-comment"># ReadWriteOnce：简写RWO，读写权限，且只能被单个node挂载；</span><br>  <span class="hljs-comment"># ReadOnlyMany：简写ROX，只读权限，允许被多个node挂载；</span><br>  <span class="hljs-comment"># ReadWriteMany：简写RWX，读写权限，允许被多个node挂载；</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">2Gi</span><br> <br><span class="hljs-comment">#创建pvc资源</span><br><span class="hljs-comment"># kubectl create -f gluster-heketi-pvc.yaml</span><br><span class="hljs-string">persistentvolumeclaim/gluster-heketi-pvc</span> <span class="hljs-string">created</span><br><br><span class="hljs-comment"># 查看</span><br><span class="hljs-string">kubectl</span> <span class="hljs-string">describe</span> <span class="hljs-string">pvc</span> <span class="hljs-string">gluster-heketi-pvc</span><br></code></pre></td></tr></table></figure><p>pvc创建后,k8s会自动生成对应的pv,可以根据上面查到的pv id(也可以通过get获取)查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl get pv<br>kubectl describe pv pvc-345664d6-052f-4b4b-bf6f-24df1e582fb4<br></code></pre></td></tr></table></figure><p>在glusterFS中,事实上是在两个节点都分别创立一个lvm并挂载,可以通过heketi查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">heketi-cli --user admin --secret admin@123 topology info --server http://localhost:8080<br></code></pre></td></tr></table></figure><p>也可以进到两个节点中直接lvdisplay和查看&#x2F;etc&#x2F;fstab</p><h2 id="pod使用pvc示例"><a href="#pod使用pvc示例" class="headerlink" title="pod使用pvc示例"></a>pod使用pvc示例</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># cat gluster-heketi-pod.yaml</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gluster-heketi-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gluster-heketi-container</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3600&quot;</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gluster-heketi-volume</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/pv-data&quot;</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gluster-heketi-volume</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">gluster-heketi-pvc</span><br> <br><span class="hljs-comment">#创建Pod</span><br><span class="hljs-comment">#kubectl apply -f gluster-heketi-pod.yaml</span><br></code></pre></td></tr></table></figure><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>heketi服务停止不会影响pvc正常使用,但会影响下一次pvc的创建</p><p>如果在heketi停止期间通过kubectl删除了pvc则不会自动删除gluster volume 逻辑卷LVM磁盘挂载等信息</p><h1 id="calico增强功能"><a href="#calico增强功能" class="headerlink" title="calico增强功能"></a>calico增强功能</h1><h2 id="固定ip"><a href="#固定ip" class="headerlink" title="固定ip"></a>固定ip</h2><h3 id="检查k8s每个节点的calico配置文件是否支持"><a href="#检查k8s每个节点的calico配置文件是否支持" class="headerlink" title="检查k8s每个节点的calico配置文件是否支持"></a>检查k8s每个节点的calico配置文件是否支持</h3><p>cat &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;10-calico.conflist</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;ipam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;calico-ipam&quot;</span><br> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>看到calico有使用ipam插件,即可使用固定ip功能</li><li>如果没有ipam或者该配置文件不存在,则不能使用</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在pod.metadata.annotations中添加**”cni.projectcalico.org&#x2F;ipAddrs”: “[&quot;192.168.0.1&quot;]”**即可<br>例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">myapp</span><br>      <span class="hljs-attr">annotations:</span><br>        <span class="hljs-attr">&quot;cni.projectcalico.org/ipAddrs&quot;:</span> <span class="hljs-string">&quot;[\&quot;10.244.36.98\&quot;]&quot;</span><br><span class="hljs-string">......</span><br></code></pre></td></tr></table></figure><p>注意: 虽然ip地址是列表形式,但目前仅支持一个pod一个ip这样配置,所以replica不能大于1</p><h2 id="浮动ip"><a href="#浮动ip" class="headerlink" title="浮动ip"></a>浮动ip</h2><h3 id="修改calico的configmap"><a href="#修改calico的configmap" class="headerlink" title="修改calico的configmap"></a>修改calico的configmap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl edit cm -n kube-system calico-config<br></code></pre></td></tr></table></figure><h3 id="增加feature-control配置"><a href="#增加feature-control配置" class="headerlink" title="增加feature_control配置"></a>增加feature_control配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">cni_network_config:</span> <span class="hljs-string">|-</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;name&quot;: &quot;k8s-pod-network&quot;,</span><br><span class="hljs-string">      &quot;cniVersion&quot;: &quot;0.3.0&quot;,</span><br><span class="hljs-string">      &quot;plugins&quot;: [</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">          &quot;type&quot;: &quot;calico&quot;,</span><br><span class="hljs-string">          &quot;log_level&quot;: &quot;info&quot;,</span><br><span class="hljs-string">          &quot;datastore_type&quot;: &quot;kubernetes&quot;,</span><br><span class="hljs-string">          &quot;nodename&quot;: &quot;__KUBERNETES_NODE_NAME__&quot;,</span><br><span class="hljs-string">          &quot;mtu&quot;: __CNI_MTU__,</span><br><span class="hljs-string">          &quot;ipam&quot;: &#123;</span><br><span class="hljs-string">              &quot;type&quot;: &quot;calico-ipam&quot;</span><br><span class="hljs-string">          &#125;,</span><br><span class="hljs-string">          &quot;policy&quot;: &#123;</span><br><span class="hljs-string">              &quot;type&quot;: &quot;k8s&quot;</span><br><span class="hljs-string">          &#125;,</span><br><span class="hljs-string">          &quot;kubernetes&quot;: &#123;</span><br><span class="hljs-string">              &quot;kubeconfig&quot;: &quot;__KUBECONFIG_FILEPATH__&quot;</span><br><span class="hljs-string">          &#125;,</span><br><span class="hljs-string">          # 开启浮动ip功能</span><br><span class="hljs-string">          &quot;feature_control&quot;: &#123;</span><br><span class="hljs-string">              &quot;floating_ips&quot;: true</span><br><span class="hljs-string">          &#125;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">          &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="hljs-string">          &quot;snat&quot;: true,</span><br><span class="hljs-string">          &quot;capabilities&quot;: &#123;&quot;portMappings&quot;: true&#125;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">      ]</span><br><span class="hljs-string">    &#125;</span><br></code></pre></td></tr></table></figure><h3 id="重启所有calico-node"><a href="#重启所有calico-node" class="headerlink" title="重启所有calico-node"></a>重启所有calico-node</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete pod -n kube-system calico-node-xxxxx<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>类似固定ip,也是添加annotations</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">annotations:</span><br>  <span class="hljs-attr">&quot;cni.projectcalico.org/floatingIPs&quot;:</span> <span class="hljs-string">&quot;[\&quot;10.244.36.98\&quot;, \&quot;10.244.36.99\&quot;]&quot;</span><br></code></pre></td></tr></table></figure><p>更多请阅<a href="https://docs.projectcalico.org/networking/use-specific-ip">官方文档</a></p><h1 id="关于镜像导出导入的注意事项"><a href="#关于镜像导出导入的注意事项" class="headerlink" title="关于镜像导出导入的注意事项"></a>关于镜像导出导入的注意事项</h1><p>国内环境由于众所周知的原因,时常会有镜像下载失败的情况,此时我们通常需要手动下载镜像并导入,有几个坑点需要注意:</p><ol><li><p>官方yaml中的镜像配置一般会带上sha摘要信息,当手动下载镜像并重新tag后,sha会变化,因此应该将yaml中的sha去掉,不然会判断为不是同一个镜像</p></li><li><p>先重新tag,再导出导入</p></li><li><p>最好使用以下命令导出导入,最好不要用重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save &lt;images-id&gt; -o &lt;images-name&gt;.tag<br>docker load -i &lt;images-name&gt;.tag<br></code></pre></td></tr></table></figure></li><li><p>私人harbor很必要</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:Pod</title>
    <link href="/2023/03/17/k8s-pod/"/>
    <url>/2023/03/17/k8s-pod/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303171744002.png" srcset="/img/loading.gif" lazyload></p><h1 id="About-Pod"><a href="#About-Pod" class="headerlink" title="About Pod"></a>About Pod</h1><ul><li><p>k8s的最少调度单位</p></li><li><p>pod内容器共享network namespace 和volume(docker run也能实现但对容器的启动顺序有要求)</p></li><li><p>本质上是容器的逻辑隔离(类似namespace)</p></li><li><p>中间容器: Pause容器</p><ul><li>每个pod内第一个启动的容器</li><li>什么都不做,永远处于暂停状态镜像只有700k左右</li></ul><blockquote><p>又称infra container;当一个pod内含有多个容器,就需要共享network namespace,k8s的解决方案是,创建一个小容器,其他所有的容器通过join namespace的方式加入到这个小容器的network container中实现共享.</p><p>主要作用:</p><ol><li>在pod中担任linux 命名空间共享的基础</li><li>启用pid命名空间,开启init进程</li></ol></blockquote></li><li><p>pod维护并生成容器内的hosts文件,保证一个pod内的所有容器都使用同一份hosts文件</p><ul><li><p>修改:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hostAliases:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-string">&quot;x.x.x.x&quot;</span><br>    <span class="hljs-attr">hostname:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;domain.com&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>所有namespace层面都由pod维护</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment">#是否使用宿主机的network namespace和 PID namespace</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">hostPID:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-attr">lifecycle:</span><br>      <span class="hljs-comment">#与entrypoint同时执行,容器一启动就执行</span><br>      <span class="hljs-attr">postStart:</span><br>        <span class="hljs-attr">exec:</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo web starting ... &gt;&gt; /var/log/messages&quot;</span>]<br>      <span class="hljs-comment">#容器停止前执行,并且等待执行完成后,才会给容器发出停止信号,当然有超时;一般做容器的优雅退出</span><br>      <span class="hljs-attr">preStop:</span><br>        <span class="hljs-attr">exec:</span><br>          <span class="hljs-comment">#如果脚本执行太快,用docker exec再tail -f 可能看不出效果(屏幕刷新来不及),所以加个sleep</span><br>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo web stopping ... &gt;&gt; /var/log/messages &amp;&amp; sleep 3&quot;</span>]<br></code></pre></td></tr></table></figure><h1 id="pod的生命周期"><a href="#pod的生命周期" class="headerlink" title="pod的生命周期"></a>pod的生命周期</h1><ol><li>Pendding: 等待调度</li><li>containterCreating: 调度完成,创建容器</li><li>Running: 成功创建</li><li>Succeded: 成功退出, $?&#x3D;0</li><li>Failed: 错误退出</li><li>Ready: 通过健康检查</li><li>CrashLoopBackoff: 没有通过健康检查</li><li>Unknow: ApiServer没有收到pod的信息</li></ol><h1 id="ProjectedVolume"><a href="#ProjectedVolume" class="headerlink" title="ProjectedVolume"></a>ProjectedVolume</h1><p>投射数据卷: ApiServer将文件投射到容器中</p><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><p>secret的修改是动态实时的,不需要重启容器</p><p>base64加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;123456&quot;</span> | <span class="hljs-built_in">base64</span><br></code></pre></td></tr></table></figure><p>创建secret</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dbpass</span><br><span class="hljs-comment">#不透明的,混浊的</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">Opaque</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">&lt;base64加密后的字符串&gt;</span><br>  <span class="hljs-attr">passwd:</span> <span class="hljs-string">&lt;base64加密后的字符串&gt;</span><br></code></pre></td></tr></table></figure><p>挂载secret</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">db-secret</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/db-secret</span><br>      <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">db-secret</span><br>    <span class="hljs-attr">projectd:</span><br>      <span class="hljs-attr">sources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">secret:</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">dbpass</span><br></code></pre></td></tr></table></figure><h2 id="Configmap"><a href="#Configmap" class="headerlink" title="Configmap"></a>Configmap</h2><p>与secret类似,但不加密,也是可以实时修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl create configmap &lt;cm-name&gt; --from-file &lt;config-file&gt;<br>kubectl edit cm &lt;cm-name&gt;<br></code></pre></td></tr></table></figure><p>也可以通过KV方式创建,创建pod时作为环境变量传入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">env:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">JAVA_OPTS</span><br>    <span class="hljs-attr">valueFrom:</span><br>      <span class="hljs-attr">configMapKeyRef:</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">configs</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">JAVA_OPTS</span><br></code></pre></td></tr></table></figure><h2 id="DownwardAPI"><a href="#DownwardAPI" class="headerlink" title="DownwardAPI"></a>DownwardAPI</h2><p>将pod本身的信息以文件形式挂载到容器中</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-attr">volumeMounts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>        <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/podinfo</span><br>  <span class="hljs-attr">volumes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">podinfo</span><br>      <span class="hljs-attr">projected:</span><br>        <span class="hljs-attr">source:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">downwardAPI:</span><br>            <span class="hljs-attr">items:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;labels&quot;</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">filedPath:</span> <span class="hljs-string">metadata.labels</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;name&quot;</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.name</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;namespace&quot;</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">metadata.namespace</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;mem-request&quot;</span><br>                <span class="hljs-attr">fieldRef:</span><br>                  <span class="hljs-attr">containerName:</span> <span class="hljs-string">web</span><br>                  <span class="hljs-attr">fieldPath:</span> <span class="hljs-string">limits.memory</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:Scheduler和部署策略</title>
    <link href="/2023/03/17/k8s-scheduler/"/>
    <url>/2023/03/17/k8s-scheduler/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303171519073.png" srcset="/img/loading.gif" lazyload></p><h1 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h1><h2 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h2><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202303171533035.png" srcset="/img/loading.gif" lazyload></p><ol><li>ETCD存储节点配置信息,ApiServer类似集群大脑.首先调度器会维护一个优先级队列,根据优先级将需要调度的pods存在队列中,informer当有新pod需要调度时,负责通知ApiServer.</li><li>ApiServer会将ETCD中的节点配置信息下发给Scheduler,Scheduler会维护一个Cache存储节点信息,以免每次调度都要请求.</li><li>Scheduler根据优先级队列以及内部策略(预选&#x2F;优选)为pod选择出具体节点,形成pod与node的绑定关系(bonding)<ul><li>预选策略: 选出哪些node不能跑这个pod (根据node selector &#x2F; tag &#x2F; label …)</li><li>优选策略: 在可选的node当中算出各自的分值,分值最高的就是最合适该pod运行的节点</li></ul></li><li>Apiserver根据绑定关系通知具体node上的kubelet,实施pod的生存周期</li></ol><h2 id="Affinity"><a href="#Affinity" class="headerlink" title="Affinity"></a>Affinity</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">affinity:</span><br>  <span class="hljs-comment">#节点亲和性</span><br>  <span class="hljs-attr">nodeAffinity:</span><br>    <span class="hljs-comment">#require:强制要求,必须match</span><br>    <span class="hljs-attr">requireDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-comment">#节点选择策略,定义多个nodeSelectorTerms之间是或关系</span><br>      <span class="hljs-attr">nodeSelectorTerms:</span><br>      <span class="hljs-comment">#多个matchExpressions之间是且关系</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">beta.kubernetes.io/arch</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>          <span class="hljs-attr">values:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">amd64</span><br>    <span class="hljs-comment">#prefer:优选要求,非必须</span><br>    <span class="hljs-attr">preferredDuringSchedulingIgnoreDuringExecution:</span><br>    <span class="hljs-comment">#权重</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">preference:</span><br>        <span class="hljs-attr">matchExpressions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">disktype</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">NotIn</span><br>          <span class="hljs-attr">values:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">ssd</span><br>  <span class="hljs-comment">#pod亲和性</span><br>  <span class="hljs-attr">podAffinity:</span><br>    <span class="hljs-attr">requireDuringSchedulingIgnoredDuringExecution:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>        <span class="hljs-attr">matchExpressions:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>          <span class="hljs-attr">values:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">web-demo</span><br>      <span class="hljs-comment">#限制范围,kubernetes.io/hostname是k8s集群每个节点默认有的一个label,所以这里意思就是集群的所有节点都在调度范围内;所以这里的意思是这个pod要求与拥有label: app=web-demo 的pod运行在同一个节点上</span><br>      <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>    <span class="hljs-attr">preferredDuringSchedulingIgnoreDuringExecution:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">weight:</span> <span class="hljs-number">100</span><br>      <span class="hljs-attr">podAffinityTerm:</span><br>        <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchExpressions:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><br>            <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>            <span class="hljs-attr">values:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">web-demo-node</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>  <span class="hljs-comment">#加上Anti表示取反</span><br>  <span class="hljs-attr">podAntiAffinity:</span><br>    <span class="hljs-attr">requireDuringSchedulingIgnoredDuringExecution:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>        <span class="hljs-attr">matchExpressions:</span><br>        <span class="hljs-comment">#比如这里配置这个pod自己的label,且这个pod跑两个副本时,则表示这两个pod不跑在同一节点上</span><br>        <span class="hljs-comment">#如果这里配置别的pod的label,则这两个pod不跑在同一节点山</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">app</span><br>          <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>          <span class="hljs-attr">values:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">web-demo</span><br>      <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br></code></pre></td></tr></table></figure><h3 id="Taint"><a href="#Taint" class="headerlink" title="Taint"></a>Taint</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl taint nodes &lt;node-hostname&gt; gpu=<span class="hljs-literal">true</span>:NoSchedule<br>                                    <span class="hljs-comment">#taint:#具体操作</span><br></code></pre></td></tr></table></figure><p>具体操作:</p><ul><li>NoSchedule: 强制不调度</li><li>PerferNoSchedule: 不调度(非强制) </li><li>NoExcuete: 不仅不能调度,如果pod已经运行在该节点,也会把它kill掉(最严格)</li></ul><h4 id="污点容忍"><a href="#污点容忍" class="headerlink" title="污点容忍"></a>污点容忍</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">tolerations:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">&quot;gpu&quot;</span><br>    <span class="hljs-attr">operator:</span> <span class="hljs-string">&quot;Equal&quot;</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-comment">#与打污点时配置的操作要一致</span><br>    <span class="hljs-attr">effect:</span> <span class="hljs-string">&quot;NoSchedule&quot;</span><br></code></pre></td></tr></table></figure><h1 id="deploy-policy"><a href="#deploy-policy" class="headerlink" title="deploy-policy"></a>deploy-policy</h1><h2 id="Recreate"><a href="#Recreate" class="headerlink" title="Recreate"></a>Recreate</h2><p>重新创建,先停掉旧的再启动新的,服务有间断</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><br></code></pre></td></tr></table></figure><h2 id="Rolling-update"><a href="#Rolling-update" class="headerlink" title="Rolling-update"></a>Rolling-update</h2><p>默认25%,逐个更新,有些用户访问到新服务,有些用户访问到旧服务,服务无间断</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">RollingUpdate</span><br>    <span class="hljs-attr">rollingUpdate:</span><br>      <span class="hljs-comment">#可以超出总pod数的百分比,比如我总共有4个实例,每次只能启动25%个新版本的pod,即每次新启动一个</span><br>      <span class="hljs-attr">maxSurge:</span> <span class="hljs-number">25</span><span class="hljs-string">%</span><br>      <span class="hljs-comment">#最大不可用:比如我总共有4个实例,则可以有1个实例不可用</span><br>      <span class="hljs-attr">maxUnavailable:</span> <span class="hljs-number">25</span><span class="hljs-string">%</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#暂停rolling-update</span><br>kubectl rollout pause deploy &lt;deployment-name&gt; -n &lt;namespace&gt;<br><span class="hljs-comment">#继续</span><br>kubectl rollout resume deploy &lt;deployment-name&gt; -n &lt;namespace&gt;<br><span class="hljs-comment">#回滚</span><br>kubectl rollout undo deploy &lt;deployment-name&gt; -n &lt;namespace&gt;<br></code></pre></td></tr></table></figure><h2 id="Blue-Green"><a href="#Blue-Green" class="headerlink" title="Blue-Green"></a>Blue-Green</h2><p>蓝绿发布: 先跑一批旧版本pod(Blue),再跑一批新版本pod(Green),等Green测试完成,通过修改services的selector,把流量指到Green,Green运行一段时间没问题,再删除Blue.方便回滚.服务无间断</p><h3 id="A-B-testing"><a href="#A-B-testing" class="headerlink" title="A&#x2F;B testing"></a>A&#x2F;B testing</h3><p>A&#x2F;B测试是以蓝绿的方式部署,相关人员通过分析不同版本的运行效果(订单&#x2F;用户体验&#x2F;满意度等),选择其中一个版本.是一种效果验证方式不是部署方式.</p><h2 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h2><p>金丝雀&#x2F;灰度发布: service同时把流量指向新旧版本,有些用户会使用旧版本,有些用户使用新版本.配合istio使用才能更好配置.</p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s进阶:Resource</title>
    <link href="/2022/07/11/k8s-advanced-resource/"/>
    <url>/2022/07/11/k8s-advanced-resource/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202207112259389.png" srcset="/img/loading.gif" lazyload></p><h1 id="K8S进阶知识"><a href="#K8S进阶知识" class="headerlink" title="K8S进阶知识"></a>K8S进阶知识</h1><p>本系列笔记记录一些本人在学习k8s后,额外补充到的一些知识,或者是重新梳理.对我个人来说,就是进阶,比较碎片化,记录为主.</p><h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><h2 id="request和limit"><a href="#request和limit" class="headerlink" title="request和limit"></a>request和limit</h2><ol><li>当使用docker作为运行时,通过yaml指定request和limit,并apply后,可以通过以下命令查看一些传给docker的实际资源参数:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect &lt;container-id&gt;<br></code></pre></td></tr></table></figure><ul><li><p>CpuShares:</p><blockquote><p>yaml中request.cpu(100m&#x3D;0.1核)*1024&#x3D;CpuShares(102.4)</p></blockquote><p>docker中一个相对权重,作用是当docker发生资源竞争时候,决定分配给容器资源的比例.</p><p>比如某节点起了两个容器,分别cpu配置为1和2,那两个容器的CpuShares就是1024和2048,当节点发生资源竞争,docker就会按CpuShares的比例(1:2)将cpu资源分配给两个容器.</p></li><li><p>Memory: 内存,B单位</p></li><li><p>CpuPeriod和CpuQuota:</p><p>CpuPeriod是docker默认值(100000),单位是纳秒;CpuQuota就是limit.cpu,单位微核(200m&#x3D;0.2核*100000&#x3D;20000)</p><blockquote><p>CpuPeriod: 100000</p><p>CpuQuota: 20000</p><p>表示容器在100毫秒最多分配给它cpu0.2核</p></blockquote></li></ul><ol start="2"><li><p>模拟增加cpu和内存使用</p><p>内存使用脚本:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>str = &quot;&lt;任选一段比较长的字符串&gt;&quot;<br>while [ TRUE ]<br>do<br>str = &quot;$&#123;str&#125;$&#123;str&#125;&quot;<br>done<br></code></pre></td></tr></table></figure><p>字符串不停翻倍,内存使用不停扩大,当该进程使用的内存不停扩大到limit,docker会直接将其杀掉,但不会重启容器(该脚本并不是容器的主进程&#x2F;启动进程).</p><p>cpu使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dd if=/dev/zero of=/dev/null &amp;<br></code></pre></td></tr></table></figure><p>不停创建新进程,cpu使用率不停增加,但cpu使用最大只能用到limit,且进程不会被杀掉.因为cpu可压缩.</p></li></ol><h2 id="LimitRange"><a href="#LimitRange" class="headerlink" title="LimitRange"></a>LimitRange</h2><p>K8S提供的另一种资源限制手段,本身也是K8S的一种资源,作用在namespace下的pod和container生效.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">LimitRange</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-limits</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">limits:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">max:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">4000m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">2Gi</span><br>    <span class="hljs-attr">min:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">100Mi</span><br>    <span class="hljs-comment"># request和limit比值最大不能超过多少</span><br>    <span class="hljs-attr">maxLimitRequestRatio:</span><br>      <span class="hljs-comment"># limit.cpu最大比request.cpu大3倍</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-number">3</span><br>      <span class="hljs-comment"># limit.mem最大比request.mem大2倍</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-number">2</span><br>    <span class="hljs-comment"># Pod的资源限制</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Pod</span><br><span class="hljs-comment">####################Container比Pod多了默认值,因为Pod是一个逻辑概念,里面可以跑多个容器,所以无法配置默认值#####################</span><br>  <span class="hljs-comment"># limit的默认值</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">default:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">300m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">200Mi</span><br>    <span class="hljs-comment"># request的默认值</span><br>    <span class="hljs-attr">defaultRequest:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">200m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">100Mi</span><br>    <span class="hljs-attr">max:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">2000m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">1Gi</span><br>    <span class="hljs-attr">min:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">100m</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">100Mi</span><br>    <span class="hljs-attr">maxLimitRequestRatio:</span><br>      <span class="hljs-attr">cpu:</span> <span class="hljs-number">5</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Container</span><br></code></pre></td></tr></table></figure><h2 id="ResourceQuota"><a href="#ResourceQuota" class="headerlink" title="ResourceQuota"></a>ResourceQuota</h2><p>针对namespace做资源限制,限制该namespace的request和limit最多使用多少资源以及pod数量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ResourceQuota</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">resource-quota</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hard:</span><br>    <span class="hljs-attr">pods:</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">request.cpu:</span> <span class="hljs-string">2000m</span><br>    <span class="hljs-attr">requests.memory:</span> <span class="hljs-string">4Gi</span><br>    <span class="hljs-attr">limits.cpu:</span> <span class="hljs-string">4000m</span><br>    <span class="hljs-attr">limits.memory:</span> <span class="hljs-string">8Gi</span><br></code></pre></td></tr></table></figure><p>也可以限制namespace下各种资源的数量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ResourceQuota</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">object-counts</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">test</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">hard:</span><br>    <span class="hljs-attr">configmaps:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">persistentvolumeclaims:</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">replicationcontrollers:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">secrets:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>查看:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl &lt;get|describe&gt; quota -n test<br></code></pre></td></tr></table></figure><h2 id="Pod驱逐-Eviction"><a href="#Pod驱逐-Eviction" class="headerlink" title="Pod驱逐-Eviction"></a>Pod驱逐-Eviction</h2><blockquote><p>request &#x3D;&#x3D; limit: 可靠</p><p>不设置: 不可靠</p><p>limit&gt;request: 基本可靠</p></blockquote><p>kublet持续监控节点资源情况,当符合对应驱逐策略时,便开始驱逐pod</p><p>常见驱逐策略配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">节点可用内存少于1.5G,开始驱逐,结合第二个参数与一起使用</span><br>--eviction-soft=memory.available&lt;1.5Gi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">soft意味着不是马上驱逐,而是优雅<span class="hljs-built_in">kill</span>(grace),此参数配置与上一条一起使用,但节点内存持续1m30s都少于1.5G时,才开始驱逐</span><br>--eviction-soft-grace-period=memory.available=1m30s<br><span class="hljs-meta prompt_"># </span><span class="language-bash">hard就是硬驱逐,当条件满足,便立即执行驱逐,或关系</span><br>--eviction-hard=memory.available&lt;100Mi,nodefs.available&lt;1Gi,nodefs.inodesFree&lt;5%<br></code></pre></td></tr></table></figure><p>kubelet的驱逐处理:</p><blockquote><p>磁盘紧缺时候:</p><ol><li>删除死掉的pod&#x2F;容器</li><li>删除没用的镜像</li><li>按优先级&#x2F;资源占用情况驱逐pod(同级别中优先驱逐占用资源最多的)</li></ol><p>内存紧缺时:</p><ol><li>驱逐不可靠的pod(优先驱逐占用内存最大的)</li><li>驱逐基本可靠的pod<ol><li>实际使用内存&gt;request内存的pod中找超过最多的优先驱逐</li><li>如果没有则优先驱逐占用内存最大的</li></ol></li><li>驱逐可靠的pod(过程与基本可靠一致)</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>websocket-http</title>
    <link href="/2022/07/02/websocket-http/"/>
    <url>/2022/07/02/websocket-http/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202207022348646.png" srcset="/img/loading.gif" lazyload></p><h1 id="START"><a href="#START" class="headerlink" title="START &gt;_"></a>START &gt;_</h1><blockquote><p>最近工作上接触到了websocket这概念,发现自己以前对它的理解一直都是错的,于是搜索了一下资料,决定写下来记录下来.</p></blockquote><h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><h2 id="单向"><a href="#单向" class="headerlink" title="单向"></a>单向</h2><ul><li><p>客户端发起请求,服务端接收请求并响应,request–&gt;response.</p></li><li><p>http建立在tcp之上,每个http请求发送到服务器时,客户端和服务端会打开TCP连接,客户端收到响应后,连接断开.</p></li><li><p>例如如果客户端向服务器发送10个请求，则将打开10个单独的<code>HTTP</code>连接。并在获得响应后关闭。</p></li></ul><h2 id="http与tcp"><a href="#http与tcp" class="headerlink" title="http与tcp"></a>http与tcp</h2><ul><li>http的长连接和短连接实际上是TCP长链接和短连接</li><li>每个<code>HTTP</code>连接完成后，其对应的<code>TCP</code>连接并不是每次都会关闭。从 <code>HTTP/1.1</code>起，默认使用长连接，用以保持连接特性。使用长连接的<code>HTTP</code>协议，会在响应头加入这个头部字段：<code>Connection:keep-alive</code></li><li>长连接状态下,当一个网页打开完成,就是请求响应完成后,客户端和服务端之间的<code>TCP</code>连接不会关闭,如果客户端再次访问这个网页,将再次使用这条已经建立的<code>TCP</code>连接.当然也不会永久保持,有一个超时时间,一般是服务器端设定(如<code>nginx</code>默认时间是<code>75s</code>).</li><li>长连接需要客户端和服务端都支持</li><li><code>http</code>是应用层协议,在传输层使用<code>TCP</code>协议,在网络层使用<code>IP</code>协议.<ul><li><code>IP</code>协议: 解决网络路由和寻址</li><li><code>TCP</code>协议: 解决如何在IP层之上可靠地传递数据包.(可靠收发,重传机制,保证顺序等)</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HTTP消息信息是用<code>ASCII</code>编码的，每个<code>HTTP</code>请求消息均包含<code>HTTP</code>协议版本（<code>HTTP/1.1</code>，<code>HTTP/2</code>），<code>HTTP</code>方法（<code>GET</code>&#x2F;<code>POST</code>等），<code>HTTP</code>标头（<code>Content-Type</code>，<code>Content-Length</code>），主机信息等。以及包含要传输到服务器的实际消息的正文（<code>body</code>）。</p><p><code>HTTP</code>标头的大小从200字节到2<code>KB</code>不等，<code>HTTP</code>标头的常见大小是700-800字节。当<code>Web</code>应用程序在客户端使用更多的如<code>cookie</code>等其他工具扩展代理的存储功能时，它将减少<code>HTTP</code>标头的荷载。</p><h1 id="websocket协议"><a href="#websocket协议" class="headerlink" title="websocket协议"></a>websocket协议</h1><h2 id="双向"><a href="#双向" class="headerlink" title="双向"></a>双向</h2><ul><li>全双工协议,以<code>ws://</code>或者<code>wss://</code>开头</li><li>有状态协议,这意味着客户端和服务端之间的连接将保持活动状态,直到被任何一方终止.终止时,连接将从两端终止.</li></ul><h2 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h2><ol><li><p>比如<code>client</code>要向<code>server</code>建立连接,首先会发送一个request到服务端,此时类似<code>http</code></p></li><li><p><code>server</code>收到请求,会跟<code>client</code>开始建立<code>TCP</code>连接,三次握手,此时类似<code>socket/tcp</code>连接</p></li><li><p>当连接建立起来后,就会一直保持,并以全双工模式交换数据,直到某一方断开.</p><blockquote><p>忘记了在哪里看到类似的比喻:</p><p>客户端骑马(http request)拉着两条水管到服务端请求建立连接,服务端收到后就跟客户端连起来两条水管(全双工长链接).直到某一端要拔掉水管(断开连接),则另一端也会拔掉水管(断开连接)</p></blockquote></li></ol><h1 id="http长连接和websocket持久连接"><a href="#http长连接和websocket持久连接" class="headerlink" title="http长连接和websocket持久连接"></a>http长连接和websocket持久连接</h1><h2 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h2><ul><li>即在一定的期限内保持链接，客户端会需要在固定时间内向服务端请求大量的资源，保持TCP连接不断开。客户端与服务器通信，必须要由客户端发起然后服务器返回结果。客户端是主动的，服务器是被动的。</li><li>实际上是在一个TCP连接上传输多个<code>request</code>|<code>respone</code>消息对,存在资源浪费,实时性不强等缺点</li><li>长轮询,即客户端发送一个超时时间很长的<code>request</code>,服务器hold住这个连接,在有新数据到达时<code>response</code></li></ul><h2 id="websocket持久连接"><a href="#websocket持久连接" class="headerlink" title="websocket持久连接"></a>websocket持久连接</h2><ul><li>只需建立一次<code>request</code>|<code>respone</code>消息对，之后都是<code>TCP</code>连接，避免了需要多次建立<code>request</code>|<code>respone</code>消息对而产生的冗余头部信息。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>WEBSOCKET</th><th>HTTP</th></tr></thead><tbody><tr><td>全双工</td><td>单向,服务端不能主动推数据到客户端</td></tr><tr><td>一次建立持续使用</td><td>一次请求一个连接,每次连接都要重新tcp握手</td></tr></tbody></table><p>具体要看使用场景:</p><p>如果需要长时间保持连接,持续交换数据时,使用<code>websocket</code>,此时比起使用特定时间的<code>http</code>长连接速度更快,也不存在断连重连的情况,如:</p><ul><li>IM</li><li>实时更新的页面</li></ul><p>如果只是简单的一次请求获取数据,使用<code>HTTP</code>即可</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>websocket</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prometheus+Grafana联邦监控系统</title>
    <link href="/2022/06/17/Prometheus-Grafana-Monitor-System/"/>
    <url>/2022/06/17/Prometheus-Grafana-Monitor-System/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>  <a href="https://prometheus.io/">Prometheus</a> 是由 SoundCloud 开源监控告警解决方案，从 2012 年开始编写代码，再到 2015 年 github 上开源以来，已经吸引了 9k+ 关注，以及很多大公司的使用；2016 年 Prometheus 成为继 k8s 后，第二名 CNCF(<a href="https://cncf.io/">Cloud Native Computing Foundation</a>) 成员。</p><p>  作为新一代开源解决方案，很多理念与 Google SRE 运维之道不谋而合。</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>多维 <a href="https://prometheus.io/docs/concepts/data_model/">数据模型</a>（时序由 metric 名字和 k&#x2F;v 的 labels 构成）。</li><li>灵活的查询语句（<a href="https://prometheus.io/docs/querying/basics/">PromQL</a>）。</li><li>无依赖存储，支持 local 和 remote 不同模型。</li><li>采用 http 协议，使用 pull 模式，拉取数据，简单易懂。</li><li>监控目标，可以采用服务发现或静态配置的方式。</li><li>支持多种统计数据模型，图形化友好</li></ul><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><ul><li><a href="https://github.com/prometheus/prometheus">Prometheus Server</a>， 主要用于抓取数据和存储时序数据，另外还提供查询和 Alert Rule 配置管理。</li><li><a href="https://prometheus.io/docs/instrumenting/clientlibs/">client libraries</a>，用于对接 Prometheus Server, 可以查询和上报数据。</li><li>各种汇报数据的 <a href="https://prometheus.io/docs/instrumenting/exporters/">exporters</a> ，例如汇报机器数据的 node_exporter, 汇报 MongoDB 信息的 <a href="https://github.com/dcu/mongodb_exporter">MongoDB exporter</a> 等等。</li><li>用于告警通知管理的 <a href="https://github.com/prometheus/alertmanager">alertmanager</a> 。</li></ul><h2 id="官方架构图"><a href="#官方架构图" class="headerlink" title="官方架构图"></a>官方架构图</h2><blockquote><p>官方就是透明png,我也不知道为什么</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206172127251.png" srcset="/img/loading.gif" lazyload></p><p>大致使用逻辑如下:</p><ol><li>Prometheus server 定期从静态配置的 targets 或者服务发现的 targets 拉取数据。</li><li>当新拉取的数据大于配置内存缓存区的时候，Prometheus 会将数据持久化到磁盘（如果使用 remote storage 将持久化到云端）。</li><li>Prometheus 可以配置 rules，然后定时查询数据，当条件触发的时候，会将 alert 推送到配置的 Alertmanager。</li><li>Alertmanager 收到警告的时候，可以根据配置，聚合，去重，降噪，最后发送警告。</li><li>可以使用 API， Prometheus Console 或者 Grafana 查询和聚合数据。</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>Prometheus 属于一站式监控告警平台，依赖少，功能齐全。</li><li>Prometheus 支持对云或容器的监控，其他系统主要对主机监控。</li><li>Prometheus 数据查询语句表现力更强大，内置更强大的统计函数。</li><li>Prometheus 在数据存储扩展性以及持久性上没有 InfluxDB，OpenTSDB，Sensu 好。</li></ul><h1 id="项目拓扑"><a href="#项目拓扑" class="headerlink" title="项目拓扑"></a>项目拓扑</h1><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206172201362.png" srcset="/img/loading.gif" lazyload alt="image-20220617220106291"></p><p>各个组件介绍:</p><ul><li>联邦集群: 由master定期向各个节点拉取数据,节点包括多个不同局域网的prometheus.</li><li>prometheus节点,各节点根据配置文件,定期向监控的target(exporters)pull监控数据</li><li>alertmanager作为统一的告警处理点,当prometheus拉取到的数据触发了rules配置的规则,则将信息发送给alertmanager,由alertmanager负责处理告警信息,包括通过什么发送告警,是否分组,是否静默,如何抑制等.</li><li>prom-wx&#x2F;prom-dingding: 第三方告警发送程序,本项目主要通过这两个程序发送告警,主要发送微信,根据项目需求,在本来的源代码上增加了一些修改,实现根据项目分发给各个管理员,而dingding则是专门监控prom-wx,当prom-wx由于各种原因down掉,告警则通过prom-dingding发送给管理员.prom-wx有代码修改,prom-dingding则是直接使用原作者的代码.两者会在下文有详细说明.</li><li>blackbox-exporter: 网络探测用的exporter,可以探测http&#x2F;https&#x2F;icmp等多种网络协议,目前在内网和阿里云上各部署一个节点.</li><li>blackupjob-exporter: 使用prometheus官网python客户端包开发的exporter,主要功能是定时读取备份工作结果文件,获取(0&#x2F;1)成功与否的结果供prometheus获取.</li><li>process-exporter: 进程监控用的exporter,主要作用是监控prom-wx的进程是否存活.</li><li>grafana: 通过promql获取prometheus数据,实现可视化.</li></ul><p><em>以上各个组件都将在下文根据项目实际情况逐一讲解</em></p><h1 id="Prometheus-Server"><a href="#Prometheus-Server" class="headerlink" title="Prometheus Server"></a>Prometheus Server</h1><h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p><strong>开箱即用</strong></p><p>到<a href="prometheus.io">官网</a>下载最新版的prometheus tar包,解压,即可使用</p><p>二进制可执行文件: prometheus</p><p>帮助说明: .&#x2F;prometheus -h</p><p>启动方式: 可使用nohup &amp;的方式放置后台运行</p><p>常用选项参数:</p><ul><li><p>–storage.tsdb.path&#x3D;&#x2F;path&#x2F;to&#x2F;somewhere : 数据存放位置,默认是.&#x2F;data</p></li><li><p>–web.enable-lifecycle: 开启接受web请求热重启功能,开启后,可以通过以下命令让prometheus重新加载配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -X POST http://prometheus-server-ip:9090/-/reload<br></code></pre></td></tr></table></figure></li><li><p>–config.file&#x3D;: 指定配置文件,默认为.&#x2F;prometheus.yml</p></li><li><p>–storage.tsdb.retention.time&#x3D;30d: 数据保存时间</p></li><li><p>–web.enable-admin-api: 开启管理api接口,开启后可以通过api删除过时的时序数据等管理操作</p></li><li><p>–web.external-url&#x3D;http:&#x2F;&#x2F;…: 指定prometheus-server的url,api的调用就根据这个指定的url来.</p></li></ul><h3 id="配置检查工具"><a href="#配置检查工具" class="headerlink" title="配置检查工具"></a>配置检查工具</h3><p>随包附送的配置文件检查工具: promtool</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./promtool check config ./prometheus.yml<br></code></pre></td></tr></table></figure><h3 id="UI界面"><a href="#UI界面" class="headerlink" title="UI界面"></a>UI界面</h3><p>访问<a href="http://prome-server-ip:9090即可看到prometheus">http://prome-server-ip:9090即可看到prometheus</a> server的图形界面,通过该图形界面可以执行查询数据,查看配置,查看规则,查看targets等操作</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206172204015.png" srcset="/img/loading.gif" lazyload alt="图片源自网络"></p><h2 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h2><p>PromQL (Prometheus Query Language) 是 Prometheus 自己开发的数据查询 DSL 语言，语言表现力非常丰富，内置函数很多，在日常数据可视化以及rule 告警中都会使用到它。要使用它,首先要理解prometheus的数据格式:</p><blockquote><p>  Prometheus 存储的是时序数据，而它的时序是由名字和一组标签构成的.</p></blockquote><p>监控的时序数据中名字,一般就是exporter中定义的metrics,类似于zabbix的监控项概念.而标签则是由系统生成的默认表情+用户在配置文件中定义的标签组成.例如,通过prometheus的webUI查到的某条时序数据类似如下显示:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206172207206.png" srcset="/img/loading.gif" lazyload alt="图片源自网络"></p><p>其中,up是exporter定义的metrics名,{}里面的就是用户定义的所有标签,用户可以通过metrics和标签筛选想要查询的数据.</p><p>更多promql使用方式以及函数等使用,请参考:</p><ul><li><a href="https://songjiayang.gitbooks.io/prometheus/content/promql/summary.html">prometheus实战</a></li><li><a href="https://yunlzheng.gitbook.io/prometheus-book/">prometheus-book</a></li></ul><p><strong>promql是prometheus使用中的核心技能,必须加深理解,否则下面的操作将难以开展</strong></p><h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><h3 id="主配置文件prometheus-yml"><a href="#主配置文件prometheus-yml" class="headerlink" title="主配置文件prometheus.yml"></a>主配置文件prometheus.yml</h3><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>全局配置包含以下4个属性,均有默认值</p><ul><li>scrape_interval: 拉取 targets 的默认时间间隔。默认15s</li><li>scrape_timeout: 拉取一个 target 的超时时间。默认10s</li><li>evaluation_interval: 执行 rules 的时间间隔。默认15s</li><li>external_labels: 额外的标签，会添加到拉取的数据并存到数据库中。默认为空,本属性用于联邦集群拉取子节点信息时,可统一往所有数据中加上一个自定义标签.</li></ul><p>本项目中联邦主的全局配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">30s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br></code></pre></td></tr></table></figure><p>本项目中联邦节点的全局配置如下(内网节点做例子)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">15s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br>  <span class="hljs-attr">external_labels:</span><br>    <span class="hljs-attr">zone:</span> <span class="hljs-string">&#x27;内网&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="告警配置"><a href="#告警配置" class="headerlink" title="告警配置"></a>告警配置</h4><p>本块配置主要用于指向alertmanager的地址</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-number">10.18</span><span class="hljs-number">.39</span><span class="hljs-number">.208</span><span class="hljs-string">:9093</span><br></code></pre></td></tr></table></figure><h4 id="rules规则配置"><a href="#rules规则配置" class="headerlink" title="rules规则配置"></a>rules规则配置</h4><p>本块配置主要用于指向自定义的规则配置文件,可以使用通配符</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./rules/*.yml</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./rules/linux-rules/*.yml</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">./rules/windows-rules/*.yml</span><br></code></pre></td></tr></table></figure><p>具体规则配置文件范例如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 规则可以分组,下面的-name定义组名</span><br><span class="hljs-attr">groups:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">RedisAlert</span><br><span class="hljs-comment"># rules关键字表示下面定义详细规则</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-comment">#告警名</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">Redis</span> <span class="hljs-string">is</span> <span class="hljs-string">down</span><br>  <span class="hljs-comment">#告警表达式基于promql</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">redis_up</span> <span class="hljs-type">!=</span> <span class="hljs-number">1</span><br>    <span class="hljs-comment">#for表示满足表达式持续多长时间就告警</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-comment">#此处的lablels是告警时候会添加上的标签,跟targets中的标签不冲突</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">zone:</span> <span class="hljs-string">内网</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">redis-alert</span><br>      <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>    <span class="hljs-comment">## 下面就是告警时候要发送的说明文字,summary标题,description详细描述</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-comment"># &#123;&#123; $labels.xxx &#125;&#125;是模版变量,可以通过它调用实例的标签的值,</span><br>      <span class="hljs-comment"># 另外&#123;&#123; $value &#125;&#125;可以调用表达式获取到的值</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;redis实例 <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> 停止服务&quot;</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;redis实例 <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> 停止服务&quot;</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">Redis</span> <span class="hljs-string">create</span> <span class="hljs-string">connections</span> <span class="hljs-string">too</span> <span class="hljs-string">fast</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">irate(redis_connections_received_total[1m])</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">zone:</span> <span class="hljs-string">内网</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">redis-alert</span><br>      <span class="hljs-attr">severity:</span> <span class="hljs-string">warning</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;redis实例 <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> 单位时间内新建连接数太过频繁&quot;</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;redis实例 <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> 单位时间内新建连接数太过频繁&quot;</span><br></code></pre></td></tr></table></figure><h4 id="监控对象配置"><a href="#监控对象配置" class="headerlink" title="监控对象配置"></a>监控对象配置</h4><p>本块配置即指明prometheus需要监控的具体目标(target),以job归类,均属于scrape_config块,包含的参数有:</p><ul><li>job_name：任务名称</li><li>honor_labels： 用于解决拉取数据标签有冲突，当设置为 true, 以拉取数据为准，否则以服务配置为准</li><li>params：数据拉取访问时带的请求参数</li><li>scrape_interval： 拉取时间间隔</li><li>scrape_timeout: 拉取超时时间</li><li>metrics_path： 拉取节点的 metric 路径</li><li>scheme： 拉取数据访问协议</li><li>sample_limit： 存储的数据标签个数限制，如果超过限制，该数据将被忽略，不入存储；默认值为0，表示没有限制</li><li>relabel_configs： 拉取数据重置标签配置</li><li>metric_relabel_configs：metric 重置标签配置</li></ul><p>以上是静态配置的参数,例子如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;prometheus&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;localhost:9090&#x27;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;node&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;localhost:9100&#x27;</span>]<br></code></pre></td></tr></table></figure><p>本项目实际生产中主要使用prometheus的文件发现功能来配置监控对象,例子如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;file_ds&#x27;</span><br>  <span class="hljs-attr">file_sd_configs:</span><br>  <span class="hljs-comment"># refresh_interval是指每隔多长时间重新读取配置文件内容,默认是5m</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">refresh_interval:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">files:</span><br>  <span class="hljs-comment"># 此处指定监控目标配置文件路径,支持通配符</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">./conf.d/ds/*.yml</span><br></code></pre></td></tr></table></figure><p>指定的配置文件支持json和yaml的格式,项目使用的均为yaml格式,例子如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 本项目约定必须要有环境和管理员两个标签(env/admin),实例名instance约定为: targets_项目名英文缩写大写_&#123;用途描述|组件描述&#125;</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;x.x.x.x:9100&#x27;</span>]<br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-string">&quot;开发环境&quot;</span><br>    <span class="hljs-attr">admin:</span> <span class="hljs-string">&quot;陈xx&quot;</span><br>    <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;x.x.x.x:9100_xx_开发环境服务器&quot;</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;x.x.x.x:9100&#x27;</span>]<br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-string">&quot;联调环境&quot;</span><br>    <span class="hljs-attr">admin:</span> <span class="hljs-string">&quot;陈xx&quot;</span><br>    <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;x.x.x.x:9100_xx_单点登录_tomcat&quot;</span><br></code></pre></td></tr></table></figure><h4 id="特殊配置项目"><a href="#特殊配置项目" class="headerlink" title="特殊配置项目"></a>特殊配置项目</h4><p>某些exporter需要独特的配置,例如blackbox-expoter等,但是都符合prometheus的配置语法格式</p><h4 id="relable机制"><a href="#relable机制" class="headerlink" title="relable机制"></a>relable机制</h4><p>prometheus具有标签重写机制,称为relable.默认情况下，当Prometheus加载Target实例完成后，这些Target时候都会包含一些默认的标签：</p><ul><li>__address__ : 当前target实例的访问地址 <host>:<port></li><li>_<em>scheme</em>_ : 采集目标服务访问地址的http scheme, HTTP或HTTPS</li><li>_<em>metrics_path</em>_ : 采集目标服务反问地址的访问路径</li><li>__param_<name> :  采集任务目标服务中包含的请求参数</li></ul><p>以上是静态采集目标的默认标签,文件发现的默认标签,以及不同版本prometheus的默认标签也许会有出入,但是原理不变.我们可以利用relabel机制,将某个job下的所有metrics的某个标签改成自己想要的,或者增加不存在的标签.以blackbox的配置作例子说明</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;Http_Post_Monitor&#x27;</span><br>  <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/probe</span><br>  <span class="hljs-comment"># 这是blackbox需要的参数</span><br>  <span class="hljs-attr">params:</span><br>    <span class="hljs-attr">module:</span> [<span class="hljs-string">http_post_2xx</span>]<br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>    <span class="hljs-comment"># targets下可以写多个监控对象</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://xxxxxx.cn</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">http://xxxxxx.cn</span><br>      <span class="hljs-comment"># 每个targets下可以自定义labels,生效范围为本targets下所有对象</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">job:</span> <span class="hljs-string">财务核算系统_FC</span> <br>        <span class="hljs-attr">admin:</span> <span class="hljs-string">何德滨</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">https://xxxxxxx.com</span><br>  <span class="hljs-comment"># relable_configs及使用relabel机制的配置块,生效范围为本job的所有targets</span><br>  <span class="hljs-attr">relabel_configs:</span><br>    <span class="hljs-comment"># 以下两行表示将__address__源标签的值赋给目标标签__param_target,以下同理</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__address__</span>]<br>      <span class="hljs-attr">target_label:</span> <span class="hljs-string">__param_target</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__param_target</span>]<br>      <span class="hljs-attr">target_label:</span> <span class="hljs-string">instance</span><br>    <span class="hljs-comment"># target_label+replacement可以实现标签重写或者新增标签</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">__address__</span><br>      <span class="hljs-attr">replacement:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9115</span><br>    <span class="hljs-comment"># 标签不存在就会自动创建</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">env</span> <br>      <span class="hljs-attr">replacement:</span> <span class="hljs-string">生产环境</span><br></code></pre></td></tr></table></figure><h4 id="联邦集群配置"><a href="#联邦集群配置" class="headerlink" title="联邦集群配置"></a>联邦集群配置</h4><p>联邦主节点通过pull方式定期拉取子节点的监控信息,配置与静态配置类似,例子如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;阿里云gitlab-federate&#x27;</span><br>  <span class="hljs-attr">honor_labels:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/federate&#x27;</span><br>  <span class="hljs-attr">params:</span><br>  <span class="hljs-comment"># match支持正则,表示只拉取符合正则的metric</span><br>    <span class="hljs-string">&#x27;match[]&#x27;</span><span class="hljs-string">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;&#123;job=~&quot;.+&quot;&#125;&#x27;</span><br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;x.x.x.x:9090&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="Recoding-Rules机制"><a href="#Recoding-Rules机制" class="headerlink" title="Recoding Rules机制"></a>Recoding Rules机制</h3><blockquote><p>  通过PromQL可以实时对Prometheus中采集到的样本数据进行查询，聚合以及其它各种运算操作。而在某些PromQL较为复杂且计算量较大时，直接使用PromQL可能会导致Prometheus响应超时的情况。这时需要一种能够类似于后台批处理的机制能够在后台完成这些复杂运算的计算，对于使用者而言只需要查询这些运算结果即可。Prometheus通过Recoding Rule规则支持这种后台计算的方式，可以实现对复杂查询的性能优化，提高查询效率。</p></blockquote><p>recoding rules的配置方式与一般rules的方式一致,在主配置文件中通过rule_files:指定yaml格式的文本文件即可读取,范例如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">groups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">rules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">record:</span> <span class="hljs-string">job:http_inprogress_requests:sum</span><br>      <span class="hljs-attr">expr:</span> <span class="hljs-string">sum(http_inprogress_requests)</span> <span class="hljs-string">by</span> <span class="hljs-string">(job)</span><br></code></pre></td></tr></table></figure><p>以上配置相当于把http_inprogress_requests这个metrics做根据job标签的sum聚合操作后的得到的序列,另外建立一条新的序列,在做数据量大的统计或操作时,这个机制可以有效减低系统资源消耗.</p><h1 id="alertmanager"><a href="#alertmanager" class="headerlink" title="alertmanager"></a>alertmanager</h1><h2 id="安装启动-1"><a href="#安装启动-1" class="headerlink" title="安装启动"></a>安装启动</h2><p><strong>同样开箱即用</strong></p><p>到<a href="prometheus.io">官网</a>下载最新版的alertmanager tar包,解压,即可使用</p><p>二进制可执行文件: alertmanager</p><p>帮助说明: .&#x2F;alertmanager -h</p><p>启动方式: 可使用nohup &amp;的方式放置后台运行</p><p>alertmanager也支持不少参数,但是都用默认值即可</p><h2 id="WebUI界面"><a href="#WebUI界面" class="headerlink" title="WebUI界面"></a>WebUI界面</h2><p>启动后,默认监听9093端口,访问它即可看到webui</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206172356112.png" srcset="/img/loading.gif" lazyload alt="图片源自网络"></p><h2 id="配置文件说明-1"><a href="#配置文件说明-1" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><h3 id="主配置文件alertmanager-yml"><a href="#主配置文件alertmanager-yml" class="headerlink" title="主配置文件alertmanager.yml"></a>主配置文件alertmanager.yml</h3><h4 id="全局配置-1"><a href="#全局配置-1" class="headerlink" title="全局配置"></a>全局配置</h4><p>用于定义一些全局的公共参数，如全局的SMTP配置，Slack配置等内容,本项目告警均使用webhook发送,因此全局配置只有如下一行:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-comment">#定义了当Alertmanager持续多长时间未接收到告警后标记告警状态为resolved（已解决）</span><br>  <span class="hljs-attr">resolve_timeout:</span> <span class="hljs-string">2m</span><br></code></pre></td></tr></table></figure><h4 id="告警路由"><a href="#告警路由" class="headerlink" title="告警路由"></a>告警路由</h4><p>根据标签匹配，确定当前告警应该如何处理</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;to-wx&#x27;</span><br>  <span class="hljs-comment">#按标签alertname和instance分组</span><br>  <span class="hljs-attr">group_by:</span> [<span class="hljs-string">&#x27;alertname&#x27;</span>, <span class="hljs-string">&#x27;instance&#x27;</span>]<br>  <span class="hljs-comment">#告警重复时间间隔</span><br>  <span class="hljs-attr">repeat_interval:</span> <span class="hljs-string">8h</span><br>  <span class="hljs-comment">#组等待时间</span><br>  <span class="hljs-attr">group_wait:</span> <span class="hljs-string">30s</span><br>  <span class="hljs-attr">group_interval:</span> <span class="hljs-string">5m</span><br>  <span class="hljs-comment">#具体告警路由,以下配置意思是符合match中定义的标签的告警,就发送给名为to-dingding的接收人</span><br>  <span class="hljs-attr">routes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;to-dingding&#x27;</span><br>    <span class="hljs-attr">match:</span><br>      <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;x.x.x.x:9256_processes-exporter&quot;</span><br></code></pre></td></tr></table></figure><h4 id="接收人"><a href="#接收人" class="headerlink" title="接收人"></a>接收人</h4><p>接收人是一个抽象的概念，它可以是一个邮箱也可以是微信，Slack或者Webhook等，接收人一般配合告警路由使用,本项目均使用webhook作为接收人</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">receivers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;to-wx&#x27;</span><br>  <span class="hljs-attr">webhook_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:5000/alert_to_wechat</span><br>  <span class="hljs-comment">#以下参数表示是否发送恢复通知</span><br>    <span class="hljs-attr">send_resolved:</span> <span class="hljs-literal">true</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;to-dingding&#x27;</span><br>  <span class="hljs-attr">webhook_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">http://x.x.x.x:8060/dingtalk/ops_dingding/send</span><br>    <span class="hljs-attr">send_resolved:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h4 id="抑制规则"><a href="#抑制规则" class="headerlink" title="抑制规则"></a>抑制规则</h4><p>当某个prometheus子节点发生故障,会引发山洪&#x2F;雪崩效应,子节点下的所有targets也会一并告警,合理配置抑制规则,可以避免这类情况</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">inhibit_rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source_match:</span><br>      <span class="hljs-attr">level:</span> <span class="hljs-string">&#x27;critical&#x27;</span><br>    <span class="hljs-attr">target_match:</span><br>      <span class="hljs-attr">level:</span> <span class="hljs-string">&#x27;warning&#x27;</span><br>    <span class="hljs-attr">equal:</span> [<span class="hljs-string">&#x27;alertname&#x27;</span>, <span class="hljs-string">&#x27;instance&#x27;</span>]<br> <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source_match:</span><br>      <span class="hljs-attr">alertname:</span> <span class="hljs-string">nodeAliveAlert</span><br>      <span class="hljs-attr">instance:</span> <span class="hljs-number">10.18</span><span class="hljs-number">.40</span><span class="hljs-number">.34</span><span class="hljs-string">:9090</span><br>    <span class="hljs-attr">target_match:</span><br>      <span class="hljs-attr">zone:</span> <span class="hljs-string">内网</span><br> <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source_match:</span><br>      <span class="hljs-attr">alertname:</span> <span class="hljs-string">nodeAliveAlert</span><br>      <span class="hljs-attr">instance:</span> <span class="hljs-number">10.19</span><span class="hljs-number">.3</span><span class="hljs-number">.88</span><span class="hljs-string">:9090</span><br>    <span class="hljs-attr">target_match:</span><br>      <span class="hljs-attr">zone:</span> <span class="hljs-string">阿里云</span><br></code></pre></td></tr></table></figure><p>说明:当已经发送的告警通知匹配到source_match规则，当有新的告警规则如果满足target_match和target_match_re或者定义的匹配规则，并且以发送的告警与新产生的告警中equal定义的标签完全相同，则启动抑制机制，新的告警不会发送。</p><h1 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h1><h2 id="安装启动-2"><a href="#安装启动-2" class="headerlink" title="安装启动"></a>安装启动</h2><p>参考<a href="https://grafana.com/docs/installation/rpm/">官网</a></p><p>启动管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl &#123;status|start|stop&#125; grafana-server<br></code></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>本项目用到两个插件,一个是node-exporter的饼图插件grafana-piechart-panel,还有一个k8s集群的kubernetes-app</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grafana-cli plugins install grafana-piechart-panel<br>grafana-cli plugins install kubernetes-app<br></code></pre></td></tr></table></figure><h2 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h2><p>都是图形界面操作,请参考官网或自行google</p><h1 id="prom-wx"><a href="#prom-wx" class="headerlink" title="prom-wx"></a>prom-wx</h1><h2 id="日常管理"><a href="#日常管理" class="headerlink" title="日常管理"></a>日常管理</h2><p>github上的第三方项目,用于为alertmanager提供webhook,将告警发送到微信工作号,提供翻译,格式化文本等功能,源项目地址:<a href="https://github.com/simanchou/prometheus_alert_wechat">simanchou&#x2F;prometheus_alert_wechat</a></p><p>根据项目需求,在源代码的基础上进行修改,增加了日志,根据项目发送对应负责人,输出格式修改等功能添加.</p><p>组件部署在联邦主节点,路径如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/prometheus/prometheus_alert_wechat<br></code></pre></td></tr></table></figure><p>默认监听5000端口,编写了启动和停止脚本,分别为组件路径下的run.sh和stop.sh.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">手动启动,先进入虚拟环境,先启动receiver再启动sender</span><br>source ./venv/bin/activate<br>python receiver.py<br>python sender.py<br><span class="hljs-meta prompt_"># </span><span class="language-bash">脚本启动or停止,无需进入虚拟环境,直接执行脚本</span><br>./run.sh<br>./stop.sh<br></code></pre></td></tr></table></figure><p>运行环境: python3.6.8,虚拟环境路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/prometheus/prometheus_alert_wechat/venv<br></code></pre></td></tr></table></figure><p>正常情况下可以用以下命令grep出两个python进程,一个为sender.py,一个为receiver.py</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep python<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>以下为配置文件说明: &#x2F;prometheus&#x2F;prometheus_alert_wechat&#x2F;prom_alert_wechat.conf,由于服务器在内网,url通过nginx正向代理实现转发.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 请正确填写如下各项信息，如还没有注册企业微信将无法使用本程序</span><br><span class="hljs-comment"># 关于企业微信开发文档请参考http://qydev.weixin.qq.com/wiki/index.php</span><br><span class="hljs-comment"># 或自行搜索相关信息</span><br>[weixin]<br><span class="hljs-comment"># 获取token的url</span><br>token_url = http://<span class="hljs-number">172.18</span><span class="hljs-number">.4</span><span class="hljs-number">.138</span>:<span class="hljs-number">8888</span><br><span class="hljs-comment"># 发送消息的url</span><br>send_msg_url = http://<span class="hljs-number">172.18</span><span class="hljs-number">.4</span><span class="hljs-number">.138</span>:<span class="hljs-number">8888</span>/send<br><span class="hljs-comment"># 企业号中的企业id。</span><br>corpid = xxxxxxxxxx<br><span class="hljs-comment"># 企业号中的应用secret。</span><br>secret = xxxxxxxxxxxxx<br><span class="hljs-comment"># 企业号中的应用id。</span><br>agentid = <span class="hljs-number">1000021</span><br><span class="hljs-comment"># 企业号中的部门id，群发时使用。</span><br>toparty =<br><span class="hljs-comment"># 企业号中的用户帐号（消息接收者，多个接收者用‘|’分隔，最多支持1000个）。特殊情况：指定为@all，则向该企业应用的全部成员发送。</span><br><span class="hljs-comment"># 等号左边是自定义的项目名，右边是该项目对应的接收人员,接收人员填eip账号id,|分割。</span><br><span class="hljs-comment"># 如果告警中的项目不存在本配置中，默认发送所有成员ALL。</span><br>[jobs]<br><span class="hljs-comment">#这一行请勿更改</span><br>ALL = ex_panwj3<br><span class="hljs-comment">#项目名 = 接收人</span><br>prometheus模块_modules = linzj3|ex_luks|ex_panwj3<br>Icmp_Gateway = ex_luks<br>新成本系统_NCS = caolei5<br>统一报表平台_URP = zengxc4<br>全面预算系统_CBS = chenda<br>...<br> <br>[mq]<br>host = <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>port = <span class="hljs-number">5672</span><br>user = admin<br>password = xxxxxx<br>heartbeat_interval = <span class="hljs-number">300</span><br> <br>[webserver]<br><span class="hljs-comment"># 绑定主机IP</span><br>host = <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-comment"># 监听端口</span><br>port = <span class="hljs-number">5000</span><br><span class="hljs-comment"># 用于请求的uri，配置到Alertmanager的配置文件中的web_hook选项</span><br>uri = /alert_to_wechat<br> <br>[lang-cn]<br><span class="hljs-comment"># 如果收到告警消息内容中冒号左边有没翻译的英文，按下面的格式添加即可实现翻译</span><br>status = 状态<br>alertname = 标题<br>env = 环境<br>...<br></code></pre></td></tr></table></figure><h2 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h2><p>该组件会使用rabbitmq作为信息队列,rabbitmq需要自行安装配置,配置好后信息填写到上文的配置文件中的[mq]配置块内</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载rpm包</span><br>wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.10/rabbitmq-server-3.6.10-1.el7.noarch.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>yum -y install erlang<br>erl --version<br>yum -y install socat<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装时注意rabbitmq和erlang相互会有版本要求</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装rpm</span><br>rpm -Uvh rabbitmq-server-3.6.10-1.el7.noarch.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">管理</span><br>systemctl &#123;status|stop|start|enable&#125; rabbitmq-server<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动webUI,默认端口15672</span><br>rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure><h2 id="日常管理-1"><a href="#日常管理-1" class="headerlink" title="日常管理"></a>日常管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">添加用户</span><br>sudo rabbitmqctl add_user admin pwd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置用户角色</span><br>sudo rabbitmqctl set_user_tags admin administrator<br><span class="hljs-meta prompt_">#</span><span class="language-bash">tag（administrator，monitoring，policymaker，management）</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置用户权限(接受来自所有Host的所有操作)</span><br>sudo rabbitmqctl  set_permissions -p &quot;/&quot; admin &#x27;.*&#x27; &#x27;.*&#x27; &#x27;.*&#x27;  <br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看用户权限</span><br>sudo rabbitmqctl list_user_permissions admin<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看当前用户列表</span><br>rabbitmqctl  list_users<br><span class="hljs-meta prompt_">#</span><span class="language-bash">列出当前队列</span><br>rabbitmqctl list_queues<br><span class="hljs-meta prompt_">#</span><span class="language-bash">清空队列,需要重新创建用户账号</span><br>rabbitmqctl stop_app<br>rabbitmqctl reset<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><p>另外,建议删除guest账号,可以使用webUI图形界面操作,也可命令行.</p><h1 id="prom-dingding"><a href="#prom-dingding" class="headerlink" title="prom-dingding"></a>prom-dingding</h1><p>由于项目初期,prom-wx组件修改代码后经常出现不稳定现场,于是额外使用process-exporter监控peom-wx,该告警则通过prom-dingding作为发送的webhook,项目后期prom-wx已经足够稳定,保留该组件只是为了以防万一.</p><p>项目地址: <a href="https://github.com/timonwong/prometheus-webhook-dingtalk">timonwong&#x2F;prometheus-webhook-dingtalk</a></p><p>同样部署联邦主节点10.18.39.208,默认监听端口8060</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/prometheus/prometheus-webhook-dingtalk-0.3.0<br></code></pre></td></tr></table></figure><p>启动命令</p><p>下文中的url为钉钉机器人的webhook地址,由于在内网,所以做了转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令行启动</span><br>./prometheus-webhook-dingtalk --ding.profile=ops_dingding=http://172.18.4.138:8888/dingding<br><span class="hljs-meta prompt_"># </span><span class="language-bash">脚本启动</span><br>./run.sh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭组件,直接<span class="hljs-built_in">kill</span>进程</span><br></code></pre></td></tr></table></figure><h1 id="Exporters"><a href="#Exporters" class="headerlink" title="Exporters"></a>Exporters</h1><p>下面列举介绍本项目用到的一些配置部署可能有点特殊的exporters</p><h2 id="blackupjob-exporter"><a href="#blackupjob-exporter" class="headerlink" title="blackupjob-exporter"></a>blackupjob-exporter</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>由于项目需求,需要额外开发一个exporter,定时读取备份任务结果输出文件,0&#x3D;成功,1&#x3D;失败,于是使用prometheus官方python-sdk做开发,每15s读一次结果输出文件,供prometheus捉取.</p><p>sdk地址:  <a href="https://github.com/prometheus/client_python">prometheus&#x2F;client_python</a></p><p>组件部署在10.18.50.173,监听端口9111,运行环境python3.6.8,组件路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/prometheus/diy-exporter.py<br></code></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /prometheus/py36-venv/bin/activate<br>python diy-exporter.py<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>组件监听的结果文件路径写在脚本头的两个字典内,字典的key为metrics的前缀,value为监听文件的路径,如有需要添加新的结果文件,只需要添加进该字典并重启进程即可,注意使用绝对路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">backupjob_file = &#123;<br>    <span class="hljs-string">&#x27;4a&#x27;</span>: <span class="hljs-string">&#x27;/home/backup/monitor/4a_binlog.sign&#x27;</span>,<br>    <span class="hljs-string">&#x27;cms&#x27;</span>: <span class="hljs-string">&#x27;/home/backup/monitor/cms_binlog.sign&#x27;</span>,<br>...<br>&#125;<br><span class="hljs-comment">#</span><br>recoverjob_file = &#123;<br>    <span class="hljs-string">&#x27;mysql&#x27;</span>: <span class="hljs-string">&#x27;/home/backup/monitor/mysqlrecover.sign&#x27;</span>,<br>    <span class="hljs-string">&#x27;rds&#x27;</span>: <span class="hljs-string">&#x27;/home/backup/monitor/rdsrecover.sign&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="blackbox-exporter"><a href="#blackbox-exporter" class="headerlink" title="blackbox-exporter"></a>blackbox-exporter</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>本exporter负责探测网络情况,支持多种协议.内网子节点和阿里云子节点均有部署,默认端口为9115</p><p>项目地址: <a href="https://github.com/prometheus/blackbox_exporter">prometheus&#x2F;blackbox_exporter</a></p><p>部署路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">/prometheus/blackbox_exporter-VERSION<br></code></pre></td></tr></table></figure><h3 id="prometheus配置"><a href="#prometheus配置" class="headerlink" title="prometheus配置"></a>prometheus配置</h3><p>需要在主配置文件中加入形如如下的配置,类似配置在上文有描述,请结合起来看</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;Http_Post_Monitor&#x27;</span><br>  <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/probe</span><br>  <span class="hljs-attr">params:</span><br>  <span class="hljs-comment">#使用blackbox的模块,在blackbox配置文件中有定义</span><br>    <span class="hljs-attr">module:</span> [<span class="hljs-string">http_post_2xx</span>]<br>  <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-comment">#- http://</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">job:</span> <span class="hljs-string">财务核算系统_FC</span> <br>        <span class="hljs-attr">admin:</span> <span class="hljs-string">何德滨</span><br>  <span class="hljs-attr">relabel_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__address__</span>]<br>      <span class="hljs-attr">target_label:</span> <span class="hljs-string">__param_target</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__param_target</span>]<br>      <span class="hljs-attr">target_label:</span> <span class="hljs-string">instance</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">__address__</span><br>      <span class="hljs-attr">replacement:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9115</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">env</span> <br>      <span class="hljs-attr">replacement:</span> <span class="hljs-string">生产环境</span><br></code></pre></td></tr></table></figure><h3 id="blackbox配置"><a href="#blackbox配置" class="headerlink" title="blackbox配置"></a>blackbox配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">modules:</span><br><span class="hljs-comment"># module名,供prometheus配置文件中引用</span><br>  <span class="hljs-attr">http_2xx:</span><br>  <span class="hljs-comment">#协议等其他参数</span><br>    <span class="hljs-attr">prober:</span> <span class="hljs-string">http</span><br>  <span class="hljs-attr">http_post_2xx:</span><br>    <span class="hljs-attr">prober:</span> <span class="hljs-string">http</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">method:</span> <span class="hljs-string">POST</span><br>  <span class="hljs-attr">tcp_connect:</span><br>    <span class="hljs-attr">prober:</span> <span class="hljs-string">tcp</span> <br>  <span class="hljs-attr">pop3s_banner:</span><br>    <span class="hljs-attr">prober:</span> <span class="hljs-string">tcp</span> <br>    <span class="hljs-attr">tcp:</span><br>      <span class="hljs-attr">query_response:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">expect:</span> <span class="hljs-string">&quot;^+OK&quot;</span><br>      <span class="hljs-attr">tls:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">tls_config:</span><br>        <span class="hljs-attr">insecure_skip_verify:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">ssh_banner:</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>所有参数默认即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./blackbox-exporter<br></code></pre></td></tr></table></figure><h2 id="mysql-exporter"><a href="#mysql-exporter" class="headerlink" title="mysql-exporter"></a>mysql-exporter</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>项目地址: <a href="https://github.com/prometheus/mysqld_exporter">prometheus&#x2F;mysqld_exporter</a></p><p>默认监听端口: 9104</p><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先创建mysql账号</span><br>CREATE USER &#x27;exporter&#x27;@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;Midea2019&#x27; WITH MAX_USER_CONNECTIONS 3;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WITH MAX_USER_CONNECTIONS 3参数部分版本的mysql不支持,可去掉</span><br>GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO &#x27;exporter&#x27;@&#x27;127.0.0.1&#x27;;<br>flush privileges;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加环境变量</span><br>vim /etc/profile<br>export DATA_SOURCE_NAME=&#x27;exporter:Midea2019@(127.0.0.1:3306)/&#x27;<br></code></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>参数默认即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./mysqld_exporter<br></code></pre></td></tr></table></figure><h2 id="oracledb-exporter"><a href="#oracledb-exporter" class="headerlink" title="oracledb-exporter"></a>oracledb-exporter</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>项目地址: <a href="https://github.com/iamseth/oracledb_exporter">iamseth&#x2F;oracledb_exporter</a></p><p>默认监听端口: 9161</p><h3 id="部署方式-1"><a href="#部署方式-1" class="headerlink" title="部署方式"></a>部署方式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装oracle实例客户端</span><br>rpm -ivh oracle-instantclient18.5-basic-18.5.0.0.0-3.x86_64.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">oracle启动tns</span><br>vim /oracle安装目录/tnsnames.ora<br>oracledb-exporter =<br>   (DESCRIPTION =<br>       (ADDRESS_LIST =<br>           (ADDRESS = (PROTOCOL = TCP)(HOST = &lt;本机ip&gt;)(PORT = 1521))<br>       )<br>       (CONNECT_DATA =<br>           (SERVER = DEDICATED)<br>           (SERVICE_NAME = xxx)<br>       )<br>    )<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置环境变量</span><br>vim /etc/profile<br>export LD_LIBRARY_PATH=/usr/lib/oracle/18.5/client64/lib:$LD_LIBRARY_PATH<br>export DATA_SOURCE_NAME=system/passwd@实例名(tns名)<br></code></pre></td></tr></table></figure><h3 id="启动-2"><a href="#启动-2" class="headerlink" title="启动"></a>启动</h3><p>需要切换到oracle的用户,随包有默认metrics的定义文件,default-metrics.toml,可直接使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./oracledb_exporter log.level error web.listen-address :9161 default.metrics ./default-metrics.toml<br></code></pre></td></tr></table></figure><h1 id="其他exporter"><a href="#其他exporter" class="headerlink" title="其他exporter"></a>其他exporter</h1><p>请参考<a href="https://prometheus.io/docs/instrumenting/exporters/">官方文档</a></p><p>有官方推荐的第三方exporter</p>]]></content>
    
    
    <categories>
      
      <category>工作笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
      <tag>grafana</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu20.04安装配置</title>
    <link href="/2022/06/14/ubuntu20-04-install-init/"/>
    <url>/2022/06/14/ubuntu20-04-install-init/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-20-04"><a href="#Ubuntu-20-04" class="headerlink" title="Ubuntu 20.04"></a>Ubuntu 20.04</h1><blockquote><p>由于需要搭建一个用于开发&#x2F;虚拟化测试&#x2F;容器化测试的环境,<del>又买不起macbook,</del>所以选择了windows和ubuntu双系统,并在ubuntu上部署kvm及开发环境的方案.涉及的工具步骤太多且繁琐,所以记录下来,以防以后还要再折腾一遍.一开始安装了ubuntu最新的22.04,但是发现太新了,有些功能和工具的支持还不够,所以最后还是用20.04 LTS.</p></blockquote><h1 id="双系统安装"><a href="#双系统安装" class="headerlink" title="双系统安装"></a>双系统安装</h1><p>这一步网上很多教程且没什么难度,不写了.</p><p>唯一要注意的地方就是,我是一张ssd+一个sata盘,然后直接将ssd分一个空闲区(不要格式化)出来,然后把sata拔掉,ubuntu会自动识别到ssd的空闲区装上去.省去手动分区的步骤.</p><h1 id="Ubuntu安装好后的优化及美化"><a href="#Ubuntu安装好后的优化及美化" class="headerlink" title="Ubuntu安装好后的优化及美化"></a>Ubuntu安装好后的优化及美化</h1><h2 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h2><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华大学镜像官网</a></p><h2 id="设置ibus输入法"><a href="#设置ibus输入法" class="headerlink" title="设置ibus输入法"></a>设置ibus输入法</h2><p>在<strong>设置</strong>中打开<strong>区域与语言</strong>删除<strong>汉语</strong>输入法,只保留<strong>中文(智能拼音)</strong></p><p>关闭 ibus 表情快捷键，避免冲突，执行命令<strong>ibus-setup</strong>,将<strong>表情符号</strong>的快捷键设为空</p><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br>sudo apt upgrade<br></code></pre></td></tr></table></figure><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>我使用的是在github上找到的<a href="https://github.com/v2rayA/v2rayA">v2rayA</a>,go写的后端,vue写的前端,浏览器打开界面(以为着没那么多乱七八糟的桌面端问题).</p><p>国人开发<del>应该</del>,跟着文档装即可</p><h2 id="界面主题美化"><a href="#界面主题美化" class="headerlink" title="界面主题美化"></a>界面主题美化</h2><p>在<strong>设置-&gt;外观</strong>中选择<strong>Dark</strong>主题</p><h3 id="安装tweaks"><a href="#安装tweaks" class="headerlink" title="安装tweaks"></a>安装tweaks</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt update<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 gnome-tweak 优化软件</span><br>sudo apt install gnome-tweak-tool<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使支持浏览器安装 gnome 插件</span><br>sudo apt install chrome-gnome-shell<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启 gnome shell 扩展</span><br>sudo apt install gnome-shell-extensions<br></code></pre></td></tr></table></figure><h3 id="firefox-chrome安装GNOME-Shell-integration插件"><a href="#firefox-chrome安装GNOME-Shell-integration插件" class="headerlink" title="firefox&#x2F;chrome安装GNOME Shell integration插件"></a>firefox&#x2F;chrome安装GNOME Shell integration插件</h3><p>百度即可&#x2F;有了科学上网,chrome的安装也不是问题</p><h3 id="到gnome插件官网选择安装需要的插件"><a href="#到gnome插件官网选择安装需要的插件" class="headerlink" title="到gnome插件官网选择安装需要的插件"></a>到gnome插件官网选择安装需要的插件</h3><p><a href="https://extensions.gnome.org/">gnome 插件官网</a></p><p>我装了以下插件:</p><ul><li>Dash to Dock 基本每个ubuntu用户都装了<del>我觉得</del></li><li>TopIcons Plus 将后台应用托盘置于顶栏: 后面装微信后要用到</li></ul><p>网上的一些推荐:</p><ul><li>Hide Top Bar 自动隐藏顶栏</li><li>Dynamic Panel Transparency 将顶栏变透明</li><li>Resource Monitor 在顶栏显示资源使用情况</li><li>croll Workspace 在屏幕右侧边缘滚轮切换工作区</li><li>Status Area Horizontal Spacing 调整顶栏右上角图标间距</li><li>Workspace Wraparound 工作区循环切换(第一个工作区向上切换至最后一个工作区)</li></ul><p>只需要简单点击即可装:</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206141049131.png" srcset="/img/loading.gif" lazyload alt="image-20220614104903082"></p><h3 id="主题-图标-鼠标"><a href="#主题-图标-鼠标" class="headerlink" title="主题&#x2F;图标&#x2F;鼠标"></a>主题&#x2F;图标&#x2F;鼠标</h3><p>访问<a href="https://www.gnome-look.org/browse/">gnome主题网站</a>选择心仪的主题安装,注意ubuntu20.04要选GTK3&#x2F;4 分类下的主题,我个人选用的是:</p><ul><li><p>系统主题:<a href="https://www.gnome-look.org/p/1357889/">Orchis gtk theme</a></p></li><li><p>图标:<a href="https://www.pling.com/p/1279924/">Tela icon theme</a></p></li><li><p>鼠标:BigData</p><p>ps: 该网站大陆访问不太稳定,good luck.</p><p>安装配置方法都有说明,上面的主题&#x2F;图标&#x2F;鼠标资源都会放到github上,github上都有doc.</p><p>安装后在<strong>tweak–&gt;外观</strong>中的<strong>应用程序</strong>选择系统主题,<strong>图标</strong>选择图标主题,<strong>光标</strong>选择鼠标主题</p></li></ul><h3 id="登陆-锁定界面"><a href="#登陆-锁定界面" class="headerlink" title="登陆&#x2F;锁定界面"></a>登陆&#x2F;锁定界面</h3><p>ubuntu自带的登陆&#x2F;锁定界面有点简单,用<a href="https://www.gnome-look.org/p/1207015/">High Ubunterra</a>进行美化,同样安装看作者github,其实就是执行一个脚本就行了<del>好像</del>.</p><h3 id="双屏幕壁纸设置及自动轮换壁纸设置"><a href="#双屏幕壁纸设置及自动轮换壁纸设置" class="headerlink" title="双屏幕壁纸设置及自动轮换壁纸设置"></a>双屏幕壁纸设置及自动轮换壁纸设置</h3><p>我喜欢双屏用同一张壁纸,并自动轮换,实现这两个功能也很简单:</p><p>壁纸根据你的屏幕分辨率来找,比如我是两个1080*1920屏幕那就找1080*3840的壁纸,然后在<strong>tweak</strong>中的<strong>外观</strong>设置中的<strong>调整</strong>调为Wallpaper即可</p><p>轮换就用ubuntu自带的shotwell软件即可实现</p><h1 id="技术环境搭建"><a href="#技术环境搭建" class="headerlink" title="技术环境搭建"></a>技术环境搭建</h1><h2 id="重新启用rc-local"><a href="#重新启用rc-local" class="headerlink" title="重新启用rc.local"></a>重新启用rc.local</h2><blockquote><p>ubuntu16开始取消了rc.local,但是有时候开机启动的命令或者脚本还是脚本方便,于是将它重新启用</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /lib/systemd/system/rc-local.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加以下配置</span><br>[Install]<br>WantedBy=multi-user.target  <br>Alias=rc-local.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建脚本并赋予可执行权限</span><br>sudo vim /etc/rc.local<br><span class="hljs-meta prompt_"># </span><span class="language-bash">参考如下</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>xxx.sh &amp;<br>exit 0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立软链</span><br>sudo ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/<br></code></pre></td></tr></table></figure><h2 id="编译安装python"><a href="#编译安装python" class="headerlink" title="编译安装python"></a>编译安装python</h2><blockquote><p>20.04默认有个python3.8,但我喜欢我掌控一切,所以不用他的</p></blockquote><ol><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libreadline-dev libbz2-dev libsqlite3-dev wget curl llvm libncurses5-dev gcc<br></code></pre></td></tr></table></figure></li><li><p>下载源码包编译安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://www.python.org/ftp/python/3.6.14/Python-3.6.14.tgz<br>tar -xvf Python-3.6.14.tgz<br>cd Python-3.6.14<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--enable-optimizations 用 PROFILE_TASK 启用以配置文件主导的优化（PGO）会增加编译时间</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--with-lto 在编译过程中启用链接时间优化（LTO）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--enable-shared 启用共享 Python 库 libpython 的编译</span><br>./configure --prefix=/opt/python36 --enable-optimizations --with-lto --enable-shared<br>sudo make &amp;&amp; sudo make install<br></code></pre></td></tr></table></figure></li><li><p>链接动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">找到 libpython 的位置,其实就在perfix下的lib中</span><br>whereis libpython3.6m.so.1.0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 /usr/lib/ 下创建 libpython 的符号链接</span><br>sudo ln -s /opt/python36/lib/libpython3.6m.so.1.0 /usr/lib/<br></code></pre></td></tr></table></figure></li><li><p>创建软链</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i<br>cd /opt/python36/bin<br>ls -s python3.6 python<br></code></pre></td></tr></table></figure></li><li><p>写入环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo -i<br>vim /etc/profile<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入以下内容,编译安装的python路径一定要写在<span class="hljs-variable">$PATH</span>前面,这样系统就会优先找到我编译安装的python了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">python3.6</span><br>export PATH=/opt/python36/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python --version<br></code></pre></td></tr></table></figure></li></ol><h2 id="安装kvm"><a href="#安装kvm" class="headerlink" title="安装kvm"></a>安装kvm</h2><ol><li><p>前置条件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看cpu是否支持虚拟化</span><br>grep -Eoc &#x27;(vmx|svm)&#x27; /proc/cpuinfo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查bios是否开启虚拟化之</span><br>sudo apt install cpu-check<br><span class="hljs-meta prompt_"># </span><span class="language-bash"></span><br><span class="language-bash">kvm-ok</span><br></code></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install qemu qemu-kvm libvirt-daemon-system libvirt-clients virt-manager virtinst bridge-utils<br></code></pre></td></tr></table></figure></li><li><p>添加用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">想要创建和管理虚拟机，你需要添加你的用户到“libvirt” 和 “kvm” 用户组</span><br>sudo usermod -aG libvirt $USER<br>sudo usermod -aG kvm $USER<br></code></pre></td></tr></table></figure></li><li><p>启动</p><blockquote><p>如果报连不上libvirtd(最开始我没有执行第三步,可能有影响,后面好像又好了),可以用root启动</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动服务</span><br>systemctl enable libvirtd --now<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动虚拟机管理器</span><br>virt-manager<br></code></pre></td></tr></table></figure></li><li><p>修改nat网段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出虚拟网络</span><br>virsh net-list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改&lt;ip address&gt;和&lt;range&gt;</span><br>virsh net-edit default<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用</span><br>virsh net-destroy  default<br>virsh net-start default<br></code></pre></td></tr></table></figure><blockquote><p>destroy之前，建议先通过net-dumpxml将配置导出.<del>但我没有</del></p></blockquote></li></ol><h2 id="使用onedrive"><a href="#使用onedrive" class="headerlink" title="使用onedrive"></a>使用onedrive</h2><p><a href="https://gist.github.com/starlinq/0f98c6d9339497bb8ac42d67f66f60eb">github教程</a></p><p>大致列一下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装前置依赖</span><br>sudo apt install build-essential<br>sudo apt install libcurl4-openssl-dev<br>sudo apt install libsqlite3-dev<br>sudo apt install pkg-config<br>sudo apt install git<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载安装dmd</span><br>cd ~/下载/<br>wget http://downloads.dlang.org/releases/2.x/2.093.1/dmd_2.093.1-0_amd64.deb<br>sudo dpkg -i dmd_2.093.1-0_amd64.deb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译安装onecould</span><br>git clone https://github.com/abraunegg/onedrive.git<br>cd onedrive<br>./configure<br>make<br>sudo make install<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动(初始化)</span><br>onedrive<br><span class="hljs-meta prompt_"># </span><span class="language-bash">然后会输出一个url,用浏览器访问并登陆你的windows账号成功后会跳转到一个空白页面,将空白页的url复制粘贴到shell然后回车即可</span><br>mkdir -p ~/OneDrive<br>cp config ~/.config/onedrive/config<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查配置</span><br>onedrive --display-config<br><span class="hljs-meta prompt_"># </span><span class="language-bash">one time <span class="hljs-built_in">sync</span></span><br>onedrive --synchronize<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启实时同步(需要手动添加到开机启动或者登陆启动)</span><br>onedrive --monitor<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>奇技淫巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>kvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github自动化部署个人博客</title>
    <link href="/2022/06/12/github-hexo-blog-CI/"/>
    <url>/2022/06/12/github-hexo-blog-CI/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p> python+django的博客放到一个便宜vps上,结果突然整个vps说没就没了,多年的总结的经验文档说没就没,心中一万个mmp,奉劝大家千万别买便宜的,资历不明的vps服务商,血的教训…</p></blockquote><blockquote><p>后来搜到了这个hexo前端框架,试了一下还挺好玩的,完全满足我写blog的需求,还能用github作为网站,意味着免费,还能用github action实现CI,听上去是不错,但是还是有不少坑,所以还是写个doc记录下吧:)</p></blockquote><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>hexo是一个前端框架,由一个台湾作者开发,所以中文支持啥的完全没问题,通过使用社区写好的各种模板,简单配置再简单几条命令,就能生成需要的静态文件,直接放到github上使用github page就能访问.这就是我对这个框架的理解,更多就自己看看官方吧.<a href="https://hexo.io/zh-cn/">hexo官方网站</a></p><p>ps: 模板也在上面找</p><h1 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h1><ol><li><p>创建一个public repo用于网站展示</p><p>repo名字要固定格式: ${github username}.github.io</p></li><li><p>创建一个private repo用于存放hexo源码</p></li><li><p>创建secret token</p><p>听说是某个情人节之后,github就要求不能用账号密码登陆,只能用token.<del>不愧是全球最大同性交友网站</del></p><p><a href="https://github.com/settings/tokens/new">github create new token</a></p><p>token只显示一次,先记录下来,后面会用到,权限需要repo和workflow就行了</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206121454081.png" srcset="/img/loading.gif" lazyload alt="image-20220612145409036"></p></li><li><p>创建ssh-key用于免密连接git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;你的GitHub用户名&quot;<br>git config --global user.email &quot;你的GitHub注册邮箱&quot;<br>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">复制公钥</span><br>cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>到<a href="https://link.zhihu.com/?target=https://github.com/settings/keys">github setting keys</a>,新建new SSH Key,粘贴上去,标题随意</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206121447391.jpg" srcset="/img/loading.gif" lazyload></p></li></ol><h1 id="BLOG部署"><a href="#BLOG部署" class="headerlink" title="BLOG部署"></a>BLOG部署</h1><ol><li><p>安装nodejs和hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt install nodejs<br>npm install hexo-cli<br></code></pre></td></tr></table></figure></li><li><p>clone刚创建的private repo到本地</p><p>记得要用ssh来clone</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone ssh://github.com/xxx/xxx<br></code></pre></td></tr></table></figure></li><li><p>hexo初始化</p><p>这就是hexo的工作目录也是blog的源码目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd xxx<br>hexo init<br></code></pre></td></tr></table></figure></li><li><p>安装配置主题</p><p>我用的是 <del><a href="https://keep-docs.xpoet.cn/usage-tutorial/quick-start.html#%E5%AE%89%E8%A3%85">keep</a></del> <a href="https://hexo.fluid-dev.com/">Fluid</a></p><p>跟着官方文档安装配置即可,但还是有坑需要记录以下</p><ul><li>主题安装最好不要用npm install的方式,这种方式的主题会安装在hexo工作目录的node_module底下,但是默认的.gitignore会ignore掉这个文件夹,主题的配置文件也在这个路径下,这个文件可能需要修改更新,所以最好直接用把release包下载到themes下这种方式即可</li></ul></li><li><p>本地测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在工作目录下执行</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理无用数据</span><br>hexo clean<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成静态文件(/public)</span><br>hexo g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动测试服务器,默认端口4000</span><br>hexo s<br></code></pre></td></tr></table></figure><p>浏览器访问本地4000端口即可验证效果</p></li><li><p>部署git depoly</p><p>在hexo工作目录下的_config.yml添加如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Deployment</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span><br>deploy:<br>  type: &#x27;git&#x27;<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">这里写入之前申请的token以及之前申请的public repo,格式如下</span><br>  repo: &#x27;https://$&#123;github personal token&#125;@github.com/xxx/xxx.github.io.git&#x27;<br>  branch: main<br></code></pre></td></tr></table></figure><p>测试是否可以部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo d<br></code></pre></td></tr></table></figure><p>部署成功可以在github的public repo上看到生成的静态文件,此时访问https:&#x2F;&#x2F;${your github name}.github.io就能访问你的blog</p></li><li><p>同步到private repo</p><p>这一步不太明确,主要因为对git不够熟悉,我自己搞了很久搞来搞去才搞好,就是将本地仓库同步到远端private repo,仅作参考</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add remote ogigin ssh://github.com/xxx/xxx.git<br>git add .<br>git commit -m &quot;xxx&quot;<br>git push<br></code></pre></td></tr></table></figure></li><li><p>配置自定义域名</p><p>在hexo工作目录下新建source&#x2F;CNAME文件并写入你的自定义域名然后hexo -d发布到public repo即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xxx.com<br></code></pre></td></tr></table></figure><p>配置完成可以在repo的settings中看到</p></li></ol><h1 id="github-actions实现CI"><a href="#github-actions实现CI" class="headerlink" title="github actions实现CI"></a>github actions实现CI</h1><ol><li><p>配置token</p><p>private repo需要有权限部署public repo需要在pricate repo settings中部署secret</p><p>settings–&gt;Secrets–&gt;Actions–&gt;new repository secret</p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206121614701.png" srcset="/img/loading.gif" lazyload alt="image-20220612161421669"></p><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202206121615272.png" srcset="/img/loading.gif" lazyload alt="image-20220612161544225"></p><p>名字自定,将上面生成的token粘贴到Value上然后点击”Add secret”</p></li><li><p>写CI YAML</p><p>在hexo工作目录新建如下文件</p></li></ol><p>​.&#x2F;.github&#x2F;workflow&#x2F;CI.yml</p><p>​文件名可以自定义,写入如下内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">CI</span><br><br><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># checkout repo</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br>      <span class="hljs-comment"># 部署nodejs环境</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 指定版本,跟你本地保持一致即可</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14.x&#x27;</span><br>      <span class="hljs-comment"># 默认ubuntu镜像时区不是东八,所以要调整下不然会影响hexo d部署时候commit的字符串中显示的时间</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">cp</span> <span class="hljs-string">/usr/share/zoneinfo/Asia/Shanghai</span> <span class="hljs-string">/etc/localtime</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">date</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">-g</span> <span class="hljs-string">hexo-cli</span><br>      <span class="hljs-comment"># 安装blog的依赖</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">cd</span> <span class="hljs-string">$&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-comment"># 配置github需要的信息</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.email</span> <span class="hljs-string">&quot;$&#123;your github email addr&#125;&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">user.name</span> <span class="hljs-string">&quot;$&#123;your github username&#125;&quot;</span><br>      <span class="hljs-comment"># hexo三步骤</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">cd</span> <span class="hljs-string">$&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">cd</span> <span class="hljs-string">$&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">g</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">cd</span> <span class="hljs-string">$&#123;</span> <span class="hljs-string">github.workspace</span> <span class="hljs-string">&#125;</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure><blockquote><p>它的原理就是github检测到这个yaml文件,就会跑一个工作流,启动一个镜像,在镜像内你自定义操作实现部署</p></blockquote><p>​更多可以参考<a href="https://docs.github.com/cn/actions">官方文档</a></p><h1 id="windows本地部署"><a href="#windows本地部署" class="headerlink" title="windows本地部署"></a>windows本地部署</h1><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>首先安装nodeJs,官网下载安装包不停下一步即可,安装完重启一下让环境变量生效.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置npm</span><br>npm config set registry https://registry.npm.taobao.org<br><span class="hljs-meta prompt_"># </span><span class="language-bash">taobao源头使用的是自签证书,npm新版不支持,所以要设置</span><br>npm config set strict-ssl false<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装hexo</span><br>npm install hexp-cli -g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">已有hexo project</span><br>cd $&#123;hexo_project_path&#125;<br>hexo clean<br>hexo g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地开启测试服务</span><br>hexo server<br></code></pre></td></tr></table></figure><h2 id="picgo"><a href="#picgo" class="headerlink" title="picgo"></a>picgo</h2><p>我在本地使用的是typora+picgo写文章和上传图片,图床直接使用github.在typora中可以下载安装picgo命令行,点击配置,打开配置文件,配置文件示例如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;picBed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;uploader&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;github&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;github&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;repo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 仓库名，格式是 username/reponame</span><br>        <span class="hljs-attr">&quot;token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// github token</span><br>        <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义存储路径，比如 img/</span><br>        <span class="hljs-attr">&quot;customUrl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/username/reponame&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义域名，注意要加 http://或者 https:// 这里加的是cdn加速地址,以免国内访问github失败</span><br>        <span class="hljs-attr">&quot;branch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 分支名，默认是 main</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;picgoPlugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">// 为插件预留</span><br>  <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>奇技淫巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
      <tag>action</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h1 id="Peter-Pan"><a href="#Peter-Pan" class="headerlink" title="Peter Pan"></a>Peter Pan</h1><p><img src="https://cdn.jsdelivr.net/gh/occultagg/blog-pics/hexo-blog/202305210819434.jpg"></p><p>Not from wonderland, but from china.</p><p>不会吉他的运维工程师不是一个好的python开发.</p><h2 id="E-mail"><a href="#E-mail" class="headerlink" title="E-mail"></a>E-mail</h2><p><a href="mailto:&#100;&#x65;&#x72;&#111;&#x67;&#103;&#64;&#113;&#113;&#46;&#99;&#111;&#109;">&#100;&#x65;&#x72;&#111;&#x67;&#103;&#64;&#113;&#113;&#46;&#99;&#111;&#109;</a><br><a href="mailto:&#x6f;&#99;&#99;&#117;&#108;&#116;&#x61;&#103;&#103;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#x6f;&#99;&#99;&#117;&#108;&#116;&#x61;&#103;&#103;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><ul><li>粤语&#x2F;国语: 母语</li><li>English: workable</li></ul><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><ul><li>CET-4</li><li>CKA</li><li>AWS SAP(pending)</li><li>CCNP</li></ul><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li><p>linux</p><blockquote><ul><li>shell</li><li>centos</li><li>ubuntu</li></ul></blockquote></li><li><p>python</p><blockquote><ul><li>django</li><li>函数式编程</li></ul></blockquote></li><li><p>云原生</p><blockquote><ul><li>kubernetes</li><li>docker</li><li>containerd</li><li>istio</li><li>prometheus</li></ul></blockquote></li><li><p>golang(初学者)</p></li><li><p>中间件</p><blockquote><ul><li>nginx</li><li>redis</li><li>zookeeper</li><li>kafka</li></ul></blockquote></li><li><p>db</p><blockquote><ul><li>mysql主从</li><li>mongodb副本集</li><li>SQL基本</li></ul></blockquote></li><li><p>公有云</p><blockquote><ul><li>terraform</li><li>AWS</li></ul></blockquote></li><li><p>CI&#x2F;CD</p><blockquote><ul><li>github action</li><li>jenkins file</li><li>groovy</li></ul></blockquote></li></ul><h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><p>&gt;<a href="https://github.com/occultagg?tab=repositories">github</a></p><p>&gt;<a href="https://anthing.cn/">blog</a></p>]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>links</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>tags</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
